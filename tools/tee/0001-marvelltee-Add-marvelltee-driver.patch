From 8531bf4b5a176f0e33670ac3243234b1e71036d7 Mon Sep 17 00:00:00 2001
From: Kevin Peng <kevinp@marvell.com>
Date: Tue, 11 Apr 2017 16:42:51 +0800
Subject: [PATCH 1/6] marvelltee: Add marvelltee driver

Marvell Trust Execution Environment (TEE) Solution in non-trusted world

Change-Id: I4b5eae3d134cfc4428436219164956c351e4a4bc
Signed-off-by: Kevin Peng <kevinp@marvell.com>
---
 arch/arm64/configs/mvebu_v8_lsp_defconfig          |    1 +
 drivers/Kconfig                                    |    2 +
 drivers/Makefile                                   |    1 +
 .../security/marvelltee/inc/marvelltee_ioctl.h     |  119 ++
 .../security/marvelltee/inc/marvelltee_types.h     |   27 +
 .../marvell/security/marvelltee/inc/tee-addr-map.h |   59 +
 .../security/marvelltee/inc/tee_cb_common.h        |   27 +
 .../security/marvelltee/inc/tee_cb_common_local.h  |   53 +
 .../security/marvelltee/inc/tee_client_api.h       |  180 +++
 .../security/marvelltee/inc/tee_shd_common.h       |   55 +
 drivers/marvell/security/marvelltee/inc/teec_cb.h  |   46 +
 drivers/marvell/security/marvelltee/inc/teec_shd.h |   52 +
 .../marvell/security/marvelltee/inc/teec_types.h   |   23 +
 drivers/marvell/security/marvelltee/src/Kconfig    |    6 +
 drivers/marvell/security/marvelltee/src/Makefile   |  117 ++
 .../marvelltee/src/comm/ntw/tee_cm_init_ntw.c      |  119 ++
 .../marvelltee/src/comm/ntw/tee_cm_internal.h      |   44 +
 .../marvelltee/src/comm/ntw/tee_cm_misc_ntw.c      |   88 ++
 .../security/marvelltee/src/comm/ntw/tee_cm_ntw.c  |  230 +++
 .../security/marvelltee/src/comm/tee_cm_smi.32b.S  |   15 +
 .../security/marvelltee/src/comm/tee_cm_smi.64b.S  |   28 +
 .../security/marvelltee/src/dbg/ntw/tee_dbg_log.c  |  273 ++++
 .../security/marvelltee/src/dbg/tee_dump.sh        |    4 +
 .../security/marvelltee/src/dbg/tee_enable_dbg.sh  |    4 +
 .../marvell/security/marvelltee/src/inc/tee_cm.h   |   69 +
 .../marvell/security/marvelltee/src/inc/tee_memm.h |   37 +
 .../security/marvelltee/src/inc/tee_mrvl_imp.h     |   70 +
 .../security/marvelltee/src/inc/tee_msgm_ntw.h     |  240 ++++
 .../marvell/security/marvelltee/src/inc/tee_perf.h |   43 +
 .../marvelltee/src/main/marvelltee_application.h   |   24 +
 .../marvelltee/src/main/marvelltee_call_tw.c       |   32 +
 .../marvelltee/src/main/marvelltee_compat.c        |  679 +++++++++
 .../marvelltee/src/main/marvelltee_internal.h      |  183 +++
 .../security/marvelltee/src/main/marvelltee_list.h |   31 +
 .../security/marvelltee/src/main/marvelltee_main.c |  871 ++++++++++++
 .../marvelltee/src/main/marvelltee_main_core.c     |  800 +++++++++++
 .../security/marvelltee/src/main/marvelltee_pt.c   |  199 +++
 .../marvelltee/src/main/marvelltee_pt_core.c       |  136 ++
 .../marvelltee/src/main/marvelltee_pt_core.h       |   29 +
 .../security/marvelltee/src/main/marvelltee_sstd.h |   23 +
 .../marvell/security/marvelltee/src/main/teec_cb.c |  365 +++++
 .../security/marvelltee/src/main/teec_cb_local.h   |   33 +
 .../security/marvelltee/src/main/teec_client_api.c | 1459 ++++++++++++++++++++
 .../security/marvelltee/src/main/teec_seed_src.c   |  107 ++
 .../security/marvelltee/src/main/teec_shd.c        |  257 ++++
 .../security/marvelltee/src/main/teec_time.c       |   69 +
 .../security/marvelltee/src/main/teec_time.h       |   28 +
 .../security/marvelltee/src/memm/tee_memm.c        |  345 +++++
 .../marvelltee/src/memm/tee_memm_internal.h        |   26 +
 .../marvelltee/src/msgm/ntw/tee_msgm_can_op.c      |   63 +
 .../marvelltee/src/msgm/ntw/tee_msgm_close_ss.c    |   58 +
 .../src/msgm/ntw/tee_msgm_handle_params.c          |  169 +++
 .../marvelltee/src/msgm/ntw/tee_msgm_inv_op.c      |   88 ++
 .../marvelltee/src/msgm/ntw/tee_msgm_map_shm.c     |  111 ++
 .../marvelltee/src/msgm/ntw/tee_msgm_ntw.c         |  364 +++++
 .../marvelltee/src/msgm/ntw/tee_msgm_op_internal.h |  186 +++
 .../marvelltee/src/msgm/ntw/tee_msgm_open_ss.c     |  101 ++
 .../marvelltee/src/msgm/ntw/tee_msgm_unmap_shm.c   |   63 +
 .../marvelltee/src/osa/include/linux/osa_os_inc.h  |   78 ++
 .../security/marvelltee/src/osa/include/osa.h      |   94 ++
 .../marvelltee/src/osa/include/osa_atomic.h        |   31 +
 .../security/marvelltee/src/osa/include/osa_dbg.h  |   62 +
 .../marvelltee/src/osa/include/osa_delay.h         |   31 +
 .../security/marvelltee/src/osa/include/osa_drv.h  |   45 +
 .../security/marvelltee/src/osa/include/osa_err.h  |   47 +
 .../security/marvelltee/src/osa/include/osa_irq.h  |   49 +
 .../security/marvelltee/src/osa/include/osa_list.h |   53 +
 .../security/marvelltee/src/osa/include/osa_mem.h  |  222 +++
 .../security/marvelltee/src/osa/include/osa_misc.h |   45 +
 .../marvelltee/src/osa/include/osa_sched.h         |   36 +
 .../security/marvelltee/src/osa/include/osa_sync.h |   50 +
 .../marvelltee/src/osa/include/osa_thread.h        |   77 ++
 .../security/marvelltee/src/osa/include/osa_time.h |   31 +
 .../marvelltee/src/osa/include/osa_timer.h         |   46 +
 drivers/marvell/security/marvelltee/src/osa/osa.c  |   70 +
 .../security/marvelltee/src/osa/osa_atomic.c       |   55 +
 .../marvell/security/marvelltee/src/osa/osa_dbg.c  |   54 +
 .../security/marvelltee/src/osa/osa_delay.c        |   53 +
 .../marvell/security/marvelltee/src/osa/osa_irq.c  |  306 ++++
 .../marvell/security/marvelltee/src/osa/osa_list.c |   80 ++
 .../marvell/security/marvelltee/src/osa/osa_mem.c  | 1121 +++++++++++++++
 .../security/marvelltee/src/osa/osa_sched.c        |   24 +
 .../marvell/security/marvelltee/src/osa/osa_sync.c |  535 +++++++
 .../security/marvelltee/src/osa/osa_thread.c       |  464 +++++++
 .../marvelltee/src/perf/ntw/tee_perf_priv.h        |   21 +
 .../marvelltee/src/perf/parser/perf_parser.c       |   96 ++
 .../security/marvelltee/src/perf/tee_perf.c        |  178 +++
 87 files changed, 12985 insertions(+)
 create mode 100644 drivers/marvell/security/marvelltee/inc/marvelltee_ioctl.h
 create mode 100644 drivers/marvell/security/marvelltee/inc/marvelltee_types.h
 create mode 100644 drivers/marvell/security/marvelltee/inc/tee-addr-map.h
 create mode 100644 drivers/marvell/security/marvelltee/inc/tee_cb_common.h
 create mode 100644 drivers/marvell/security/marvelltee/inc/tee_cb_common_local.h
 create mode 100644 drivers/marvell/security/marvelltee/inc/tee_client_api.h
 create mode 100644 drivers/marvell/security/marvelltee/inc/tee_shd_common.h
 create mode 100644 drivers/marvell/security/marvelltee/inc/teec_cb.h
 create mode 100644 drivers/marvell/security/marvelltee/inc/teec_shd.h
 create mode 100644 drivers/marvell/security/marvelltee/inc/teec_types.h
 create mode 100644 drivers/marvell/security/marvelltee/src/Kconfig
 create mode 100644 drivers/marvell/security/marvelltee/src/Makefile
 create mode 100644 drivers/marvell/security/marvelltee/src/comm/ntw/tee_cm_init_ntw.c
 create mode 100644 drivers/marvell/security/marvelltee/src/comm/ntw/tee_cm_internal.h
 create mode 100644 drivers/marvell/security/marvelltee/src/comm/ntw/tee_cm_misc_ntw.c
 create mode 100644 drivers/marvell/security/marvelltee/src/comm/ntw/tee_cm_ntw.c
 create mode 100644 drivers/marvell/security/marvelltee/src/comm/tee_cm_smi.32b.S
 create mode 100644 drivers/marvell/security/marvelltee/src/comm/tee_cm_smi.64b.S
 create mode 100644 drivers/marvell/security/marvelltee/src/dbg/ntw/tee_dbg_log.c
 create mode 100755 drivers/marvell/security/marvelltee/src/dbg/tee_dump.sh
 create mode 100755 drivers/marvell/security/marvelltee/src/dbg/tee_enable_dbg.sh
 create mode 100644 drivers/marvell/security/marvelltee/src/inc/tee_cm.h
 create mode 100644 drivers/marvell/security/marvelltee/src/inc/tee_memm.h
 create mode 100644 drivers/marvell/security/marvelltee/src/inc/tee_mrvl_imp.h
 create mode 100644 drivers/marvell/security/marvelltee/src/inc/tee_msgm_ntw.h
 create mode 100644 drivers/marvell/security/marvelltee/src/inc/tee_perf.h
 create mode 100644 drivers/marvell/security/marvelltee/src/main/marvelltee_application.h
 create mode 100644 drivers/marvell/security/marvelltee/src/main/marvelltee_call_tw.c
 create mode 100644 drivers/marvell/security/marvelltee/src/main/marvelltee_compat.c
 create mode 100644 drivers/marvell/security/marvelltee/src/main/marvelltee_internal.h
 create mode 100644 drivers/marvell/security/marvelltee/src/main/marvelltee_list.h
 create mode 100644 drivers/marvell/security/marvelltee/src/main/marvelltee_main.c
 create mode 100644 drivers/marvell/security/marvelltee/src/main/marvelltee_main_core.c
 create mode 100644 drivers/marvell/security/marvelltee/src/main/marvelltee_pt.c
 create mode 100644 drivers/marvell/security/marvelltee/src/main/marvelltee_pt_core.c
 create mode 100644 drivers/marvell/security/marvelltee/src/main/marvelltee_pt_core.h
 create mode 100644 drivers/marvell/security/marvelltee/src/main/marvelltee_sstd.h
 create mode 100644 drivers/marvell/security/marvelltee/src/main/teec_cb.c
 create mode 100644 drivers/marvell/security/marvelltee/src/main/teec_cb_local.h
 create mode 100644 drivers/marvell/security/marvelltee/src/main/teec_client_api.c
 create mode 100644 drivers/marvell/security/marvelltee/src/main/teec_seed_src.c
 create mode 100644 drivers/marvell/security/marvelltee/src/main/teec_shd.c
 create mode 100644 drivers/marvell/security/marvelltee/src/main/teec_time.c
 create mode 100644 drivers/marvell/security/marvelltee/src/main/teec_time.h
 create mode 100644 drivers/marvell/security/marvelltee/src/memm/tee_memm.c
 create mode 100644 drivers/marvell/security/marvelltee/src/memm/tee_memm_internal.h
 create mode 100644 drivers/marvell/security/marvelltee/src/msgm/ntw/tee_msgm_can_op.c
 create mode 100644 drivers/marvell/security/marvelltee/src/msgm/ntw/tee_msgm_close_ss.c
 create mode 100644 drivers/marvell/security/marvelltee/src/msgm/ntw/tee_msgm_handle_params.c
 create mode 100644 drivers/marvell/security/marvelltee/src/msgm/ntw/tee_msgm_inv_op.c
 create mode 100644 drivers/marvell/security/marvelltee/src/msgm/ntw/tee_msgm_map_shm.c
 create mode 100644 drivers/marvell/security/marvelltee/src/msgm/ntw/tee_msgm_ntw.c
 create mode 100644 drivers/marvell/security/marvelltee/src/msgm/ntw/tee_msgm_op_internal.h
 create mode 100644 drivers/marvell/security/marvelltee/src/msgm/ntw/tee_msgm_open_ss.c
 create mode 100644 drivers/marvell/security/marvelltee/src/msgm/ntw/tee_msgm_unmap_shm.c
 create mode 100644 drivers/marvell/security/marvelltee/src/osa/include/linux/osa_os_inc.h
 create mode 100644 drivers/marvell/security/marvelltee/src/osa/include/osa.h
 create mode 100644 drivers/marvell/security/marvelltee/src/osa/include/osa_atomic.h
 create mode 100644 drivers/marvell/security/marvelltee/src/osa/include/osa_dbg.h
 create mode 100644 drivers/marvell/security/marvelltee/src/osa/include/osa_delay.h
 create mode 100644 drivers/marvell/security/marvelltee/src/osa/include/osa_drv.h
 create mode 100644 drivers/marvell/security/marvelltee/src/osa/include/osa_err.h
 create mode 100644 drivers/marvell/security/marvelltee/src/osa/include/osa_irq.h
 create mode 100644 drivers/marvell/security/marvelltee/src/osa/include/osa_list.h
 create mode 100644 drivers/marvell/security/marvelltee/src/osa/include/osa_mem.h
 create mode 100644 drivers/marvell/security/marvelltee/src/osa/include/osa_misc.h
 create mode 100644 drivers/marvell/security/marvelltee/src/osa/include/osa_sched.h
 create mode 100644 drivers/marvell/security/marvelltee/src/osa/include/osa_sync.h
 create mode 100644 drivers/marvell/security/marvelltee/src/osa/include/osa_thread.h
 create mode 100644 drivers/marvell/security/marvelltee/src/osa/include/osa_time.h
 create mode 100644 drivers/marvell/security/marvelltee/src/osa/include/osa_timer.h
 create mode 100644 drivers/marvell/security/marvelltee/src/osa/osa.c
 create mode 100644 drivers/marvell/security/marvelltee/src/osa/osa_atomic.c
 create mode 100644 drivers/marvell/security/marvelltee/src/osa/osa_dbg.c
 create mode 100644 drivers/marvell/security/marvelltee/src/osa/osa_delay.c
 create mode 100644 drivers/marvell/security/marvelltee/src/osa/osa_irq.c
 create mode 100644 drivers/marvell/security/marvelltee/src/osa/osa_list.c
 create mode 100644 drivers/marvell/security/marvelltee/src/osa/osa_mem.c
 create mode 100644 drivers/marvell/security/marvelltee/src/osa/osa_sched.c
 create mode 100644 drivers/marvell/security/marvelltee/src/osa/osa_sync.c
 create mode 100644 drivers/marvell/security/marvelltee/src/osa/osa_thread.c
 create mode 100644 drivers/marvell/security/marvelltee/src/perf/ntw/tee_perf_priv.h
 create mode 100644 drivers/marvell/security/marvelltee/src/perf/parser/perf_parser.c
 create mode 100644 drivers/marvell/security/marvelltee/src/perf/tee_perf.c

diff --git a/arch/arm64/configs/mvebu_v8_lsp_defconfig b/arch/arm64/configs/mvebu_v8_lsp_defconfig
index 372ba0c..e8c3339 100644
--- a/arch/arm64/configs/mvebu_v8_lsp_defconfig
+++ b/arch/arm64/configs/mvebu_v8_lsp_defconfig
@@ -289,3 +289,4 @@ CONFIG_CRYPTO_AES_ARM64_CE_BLK=y
 CONFIG_CRYPTO_AES_ARM64_NEON_BLK=y
 CONFIG_CRYPTO_CRC32_ARM64=y
 CONFIG_CRC_CCITT=y
+CONFIG_MARVELL_TEE=m
diff --git a/drivers/Kconfig b/drivers/Kconfig
index 1f36821..d605c48 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -200,4 +200,6 @@ source "drivers/hwtracing/intel_th/Kconfig"
 
 source "drivers/fpga/Kconfig"
 
+source "drivers/marvell/security/marvelltee/src/Kconfig"
+
 endmenu
diff --git a/drivers/Makefile b/drivers/Makefile
index 28935f1..345ee0e 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -173,3 +173,4 @@ obj-$(CONFIG_STM)		+= hwtracing/stm/
 obj-$(CONFIG_ANDROID)		+= android/
 obj-$(CONFIG_NVMEM)		+= nvmem/
 obj-$(CONFIG_FPGA)		+= fpga/
+obj-$(CONFIG_MARVELL_TEE)		+= marvell/security/marvelltee/src/
diff --git a/drivers/marvell/security/marvelltee/inc/marvelltee_ioctl.h b/drivers/marvell/security/marvelltee/inc/marvelltee_ioctl.h
new file mode 100644
index 0000000..3204046
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/inc/marvelltee_ioctl.h
@@ -0,0 +1,119 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+
+#ifndef _MARVELLTEE_IOCTL_H_
+#define _MARVELLTEE_IOCTL_H_
+
+#include "tee_client_api.h"
+
+#define OPERATION_EXIST        (1)
+#define OPERATION_NON_EXIST    (0)
+
+typedef struct {
+	const char *name;
+	tee_impl tee_ctx_ntw;
+	uint32_t ret;
+} teec_init_context_args;
+
+typedef struct {
+	tee_impl tee_ctx_ntw;
+	uint32_t ret;
+} teec_final_context_args;
+
+/* allocate and register use the same structure */
+typedef struct {
+	tee_impl tee_ctx_ntw;
+	void *buffer;
+	size_t size;
+	uint32_t flags;
+	tee_impl tee_shm_ntw;
+	uint32_t ret;
+} teec_map_shared_mem_args;
+
+typedef struct {
+	void *buffer;
+	size_t size;
+	uint32_t flags;
+	tee_impl tee_shm_ntw;
+	uint32_t ret;
+} teec_unmap_shared_mem_args;
+
+typedef struct {
+	tee_impl tee_ctx_ntw;
+	tee_impl tee_ss_ntw;
+	const TEEC_UUID *destination;
+	uint32_t connectionMethod;
+	const void *connectionData;
+	/* if the openSS includes the TEE_Operation,
+	 * the flag should be set to 1.
+	*  if flag=1, that means driver need to allomate tee_op_ntw
+	*/
+	uint32_t flags;
+	uint32_t paramTypes;
+	TEEC_Parameter params[4];
+	tee_impl tee_op_ntw;
+	tee_impl *tee_op_ntw_for_cancel;
+	uint32_t returnOrigin;
+	uint32_t ret;
+} teec_open_ss_args;
+
+typedef struct {
+	tee_impl tee_ss_ntw;
+	uint32_t ret;
+} teec_close_ss_args;
+
+typedef struct {
+	tee_impl tee_ss_ntw;
+	uint32_t cmd_ID;
+	uint32_t started;
+	/* if flag=1, that means driver need to allomate tee_op_ntw */
+	uint32_t flags;
+	uint32_t paramTypes;
+	TEEC_Parameter params[4];
+	tee_impl tee_op_ntw;
+	tee_impl *tee_op_ntw_for_cancel;
+	uint32_t returnOrigin;
+	uint32_t ret;
+} teec_invoke_cmd_args;
+
+typedef struct {
+	tee_impl tee_op_ntw;
+	uint32_t ret;
+} teec_request_cancel_args;
+
+#define TEEC_IOCTL_MAGIC        't'
+
+#define TEEC_INIT_CONTEXT       _IOW(TEEC_IOCTL_MAGIC, 0, unsigned int)
+
+#define TEEC_FINAL_CONTEXT      _IOW(TEEC_IOCTL_MAGIC, 1, unsigned int)
+
+#define TEEC_REGIST_SHARED_MEM  _IOW(TEEC_IOCTL_MAGIC, 2, unsigned int)
+
+#define TEEC_ALLOC_SHARED_MEM   _IOW(TEEC_IOCTL_MAGIC, 3, unsigned int)
+
+#define TEEC_RELEASE_SHARED_MEM _IOW(TEEC_IOCTL_MAGIC, 4, unsigned int)
+
+#define TEEC_OPEN_SS            _IOW(TEEC_IOCTL_MAGIC, 5, unsigned int)
+
+#define TEEC_CLOSE_SS           _IOW(TEEC_IOCTL_MAGIC, 6, unsigned int)
+
+#define TEEC_INVOKE_CMD         _IOW(TEEC_IOCTL_MAGIC, 7, unsigned int)
+
+#define TEEC_REQUEST_CANCEL     _IOW(TEEC_IOCTL_MAGIC, 8, unsigned int)
+
+#endif /* _MARVELLTEE_IOCTL_H_ */
diff --git a/drivers/marvell/security/marvelltee/inc/marvelltee_types.h b/drivers/marvell/security/marvelltee/inc/marvelltee_types.h
new file mode 100644
index 0000000..4b05e11
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/inc/marvelltee_types.h
@@ -0,0 +1,27 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+
+#ifndef _MARVELLTEE_TYPES_H_
+#define _MARVELLTEE_TYPES_H_
+
+#include <linux/types.h>
+
+typedef uint32_t tee_stat_t;
+typedef void *tee_impl;
+
+#endif /* _MARVELLTEE_TYPES_H_ */
diff --git a/drivers/marvell/security/marvelltee/inc/tee-addr-map.h b/drivers/marvell/security/marvelltee/inc/tee-addr-map.h
new file mode 100644
index 0000000..ca32fe1
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/inc/tee-addr-map.h
@@ -0,0 +1,59 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+#ifndef __TZ_ADDR_MAP_H__
+#define __TZ_ADDR_MAP_H__
+
+#define RA_PHYS_ADDR    (TW_ADDR_BASE + 0x00000000)
+#define RA_SIZE         (0x00600000)
+
+#ifdef TEE_RES_CFG_8M
+
+#define RB_PHYS_ADDR    (TW_ADDR_BASE + 0x00600000)
+#define RB_SIZE         (0x00100000)
+
+#define RC_PHYS_ADDR    (TW_ADDR_BASE + 0x00700000)
+#define RC_SIZE         (0x00100000)
+
+#elif defined(TEE_RES_CFG_16M)
+
+#define RB_PHYS_ADDR    (0x00E00000)
+#define RB_SIZE         (0x00100000)
+
+#define RC_PHYS_ADDR    (0x00F00000)
+#define RC_SIZE         (0x00100000)
+
+#elif defined(TEE_RES_CFG_24M)
+
+#define RB_PHYS_ADDR    (0x01600000)
+#define RB_SIZE         (0x00100000)
+
+#define RC_PHYS_ADDR    (0x01700000)
+#define RC_SIZE         (0x00100000)
+
+#else
+
+#error "ERROR - Invalid TEE_RES_CFG Setting."
+
+#endif
+
+#ifdef TEE_PERF_MEASURE
+#define PERF_BUF_ADDR   (0x00800000)
+#define PERF_BUF_SIZE   (0x00800000)
+#endif
+
+#endif /* __TZ_ADDR_MAP__ */
diff --git a/drivers/marvell/security/marvelltee/inc/tee_cb_common.h b/drivers/marvell/security/marvelltee/inc/tee_cb_common.h
new file mode 100644
index 0000000..187f956
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/inc/tee_cb_common.h
@@ -0,0 +1,27 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+#ifndef __TEE_CB_COMMON_H__
+#define __TEE_CB_COMMON_H__
+
+/* this data structure is the callback's arguments */
+typedef struct _tee_cb_arg_t {
+	int32_t  nbytes;    /* sizeof(args), max = 4K - sizeof(uint32_t) */
+	uint8_t  args[0];   /* the arguments, sizeof(args) == nbytes */
+} tee_cb_arg_t;
+
+#endif /* __TEE_CB_COMMON_H__ */
diff --git a/drivers/marvell/security/marvelltee/inc/tee_cb_common_local.h b/drivers/marvell/security/marvelltee/inc/tee_cb_common_local.h
new file mode 100644
index 0000000..9d4e945
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/inc/tee_cb_common_local.h
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+#ifndef __TEE_CB_COMMON_LOCAL_H__
+#define __TEE_CB_COMMON_LOCAL_H__
+
+#include "tee_cb_common.h"
+
+#define TEE_CB_SHM_MAX_SZ       (0x1000)
+
+#define TEE_CB_SRV_UUID \
+	{ \
+		0x00000004, 0x0000, 0x0000, \
+		{                           \
+			0x00, 0x00, 0x00, 0x00, \
+			0x00, 0x00, 0x00, 0x00, \
+		},                          \
+	}
+
+#define TEE_CB_FETCH_REQ        (0x12345678)
+#define TEE_CB_TRIGGER_STOP     (0x87654321)
+
+/*
+ * this ctrl-bit indicates unreg-cb happens in ntw.
+ * set by ntw and read by tw.
+ */
+#define TEE_CB_CTRL_BIT_DYING   (0x00000001)
+/*
+ * this ctrl-bit means a fake call from tw to ntw.
+ * no need to call ntw callback actually.
+ * set by tw and read by ntw.
+ */
+#define TEE_CB_CTRL_BIT_FAKE    (0x00010000)
+
+/* indicator for NULL arg when calling ntw */
+#define TEE_CB_ARG_NULL         (-1)
+#define TEE_CB_IS_ARG_NULL(_n)  (TEE_CB_ARG_NULL == (_n))
+
+#endif /* __TEE_CB_COMMON_LOCAL_H__ */
diff --git a/drivers/marvell/security/marvelltee/inc/tee_client_api.h b/drivers/marvell/security/marvelltee/inc/tee_client_api.h
new file mode 100644
index 0000000..8a92b8a
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/inc/tee_client_api.h
@@ -0,0 +1,180 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+
+#ifndef _TEE_CLIENT_API_H_
+#define _TEE_CLIENT_API_H_
+
+#include "teec_types.h"
+
+/*
+ * Constants
+ */
+#define TEEC_CONFIG_SHAREDMEM_MAX_SIZE  (0x8000000)     /* 128MB */
+
+/*
+ * API Error Codes
+ */
+#define TEEC_SUCCESS                  (0x00000000)
+#define TEEC_ERROR_GENERIC            (0xFFFF0000)
+#define TEEC_ERROR_ACCESS_DENIED      (0xFFFF0001)
+#define TEEC_ERROR_CANCEL             (0xFFFF0002)
+#define TEEC_ERROR_ACCESS_CONFLICT    (0xFFFF0003)
+#define TEEC_ERROR_EXCESS_DATA        (0xFFFF0004)
+#define TEEC_ERROR_BAD_FORMAT         (0xFFFF0005)
+#define TEEC_ERROR_BAD_PARAMETERS     (0xFFFF0006)
+#define TEEC_ERROR_BAD_STATE          (0xFFFF0007)
+#define TEEC_ERROR_ITEM_NOT_FOUND     (0xFFFF0008)
+#define TEEC_ERROR_NOT_IMPLEMENTED    (0xFFFF0009)
+#define TEEC_ERROR_NOT_SUPPORTED      (0xFFFF000A)
+#define TEEC_ERROR_NO_DATA            (0xFFFF000B)
+#define TEEC_ERROR_OUT_OF_MEMORY      (0xFFFF000C)
+#define TEEC_ERROR_BUSY               (0xFFFF000D)
+#define TEEC_ERROR_COMMUNICATION      (0xFFFF000E)
+#define TEEC_ERROR_SECURITY           (0xFFFF000F)
+#define TEEC_ERROR_SHORT_BUFFER       (0xFFFF0010)
+#define TEEC_ERROR_TARGET_DEAD        (0xFFFF3024)
+
+/*
+ * Login Type Constants
+ */
+#define TEEC_LOGIN_PUBLIC               (0x00000000)
+#define TEEC_LOGIN_USER                 (0x00000001)
+#define TEEC_LOGIN_GROUP                (0x00000002)
+#define TEEC_LOGIN_APPLICATION          (0x00000004)
+
+/*
+ * Return Code for returnOrigins
+ */
+#define TEEC_ORIGIN_API         (0x00000001)
+#define TEEC_ORIGIN_COMMS       (0x00000002)
+#define TEEC_ORIGIN_TEE         (0x00000003)
+#define TEEC_ORIGIN_TRUSTED_APP (0x00000004)
+
+/*
+ * Parameter Types for paramTypes arg
+ */
+#define TEEC_NONE                   (0x00000000)
+#define TEEC_VALUE_INPUT            (0x00000001)
+#define TEEC_VALUE_OUTPUT           (0x00000002)
+#define TEEC_VALUE_INOUT            (0x00000003)
+#define TEEC_MEMREF_TEMP_INPUT      (0x00000005)
+#define TEEC_MEMREF_TEMP_OUTPUT     (0x00000006)
+#define TEEC_MEMREF_TEMP_INOUT      (0x00000007)
+#define TEEC_MEMREF_WHOLE           (0x0000000C)
+#define TEEC_MEMREF_PARTIAL_INPUT   (0x0000000D)
+#define TEEC_MEMREF_PARTIAL_OUTPUT  (0x0000000E)
+#define TEEC_MEMREF_PARTIAL_INOUT   (0x0000000F)
+
+/*
+ * Session Login Methods
+ */
+#define TEEC_LOGIN_PUBLIC               (0x00000000)
+#define TEEC_LOGIN_USER                 (0x00000001)
+#define TEEC_LOGIN_GROUP                (0x00000002)
+#define TEEC_LOGIN_APPLICATION          (0x00000004)
+#define TEEC_LOGIN_USER_APPLICATION     (0x00000005)
+#define TEEC_LOGIN_GROUP_APPLICATION    (0x00000006)
+
+#define TEEC_PARAM_TYPES(t0, t1, t2, t3) \
+	((t0) | ((t1) << 4) | ((t2) << 8) | ((t3) << 12))
+#define TEEC_PARAM_TYPE_GET(t, i) (((t) >> (i*4)) & 0xF)
+
+/*
+ * Shared Memory Control Flags
+ */
+#define TEEC_MEM_INPUT      (0x00000001)
+#define TEEC_MEM_OUTPUT     (0x00000002)
+
+typedef uint32_t TEEC_Result;
+typedef void *TEEC_MRVL_Context;
+typedef void *TEEC_MRVL_Session;
+typedef void *TEEC_MRVL_SharedMemory;
+typedef void *TEEC_MRVL_Operation;
+
+typedef struct {
+	uint32_t timeLow;
+	uint16_t timeMid;
+	uint16_t timeHiAndVersion;
+	uint8_t  clockSeqAndNode[8];
+} TEEC_UUID;
+
+typedef struct {
+	TEEC_MRVL_Context imp;
+} TEEC_Context;
+
+typedef struct {
+	TEEC_MRVL_Session imp;
+} TEEC_Session;
+
+typedef struct {
+	void *buffer;
+	size_t size;
+	uint32_t flags;
+	TEEC_MRVL_SharedMemory imp;
+} TEEC_SharedMemory;
+
+typedef struct {
+	void *buffer;
+	size_t size;
+} TEEC_TempMemoryReference;
+
+typedef struct {
+	TEEC_SharedMemory *parent;
+	size_t size;
+	size_t offset;
+} TEEC_RegisteredMemoryReference;
+
+typedef struct {
+	uint32_t a;
+	uint32_t b;
+} TEEC_Value;
+
+typedef union {
+	TEEC_TempMemoryReference tmpref;
+	TEEC_RegisteredMemoryReference memref;
+	TEEC_Value value;
+} TEEC_Parameter;
+
+typedef struct {
+	uint32_t started;
+	uint32_t paramTypes;
+	TEEC_Parameter params[4];
+	TEEC_MRVL_Operation imp;
+} TEEC_Operation;
+
+
+TEEC_Result TEEC_InitializeContext(const char *name, TEEC_Context *context);
+void TEEC_FinalizeContext(TEEC_Context *context);
+TEEC_Result TEEC_RegisterSharedMemory(TEEC_Context *context,
+						TEEC_SharedMemory *sharedMem);
+TEEC_Result TEEC_AllocateSharedMemory(TEEC_Context *context,
+						TEEC_SharedMemory *sharedMem);
+void TEEC_ReleaseSharedMemory(TEEC_SharedMemory *sharedMem);
+TEEC_Result TEEC_OpenSession(TEEC_Context *context, TEEC_Session *session,
+						 const TEEC_UUID *destination,
+						 uint32_t connectionMethod,
+						 const void *connectionData,
+						 TEEC_Operation *operation,
+						 uint32_t *returnOrigin);
+void TEEC_CloseSession(TEEC_Session *session);
+TEEC_Result TEEC_InvokeCommand(TEEC_Session *session, uint32_t commandID,
+						TEEC_Operation *operation,
+						uint32_t *returnOrigin);
+void TEEC_RequestCancellation(TEEC_Operation *operation);
+
+#endif /* _TEE_CLIENT_API_H_ */
diff --git a/drivers/marvell/security/marvelltee/inc/tee_shd_common.h b/drivers/marvell/security/marvelltee/inc/tee_shd_common.h
new file mode 100644
index 0000000..4da109d
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/inc/tee_shd_common.h
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+#ifndef __TEE_SHD_COMMON_H__
+#define __TEE_SHD_COMMON_H__
+
+#define TEE_SHD_UUID_PREFIX (0xFF000001)
+
+typedef struct _tee_shd_cb_uuid_t {
+	uint32_t prefix;
+	uint8_t  name[10];
+	uint8_t  type;
+	uint8_t  id;
+} tee_shd_cb_uuid_t;
+
+typedef enum _tee_shd_cb_cmd_t {
+	TEEC_SHD_CMD_INV = 0,
+	TEEC_SHD_CMD_SHARING,
+	TEEC_SHD_CMD_REVERT,
+} tee_shd_cb_cmd_t;
+
+typedef struct _tee_shd_cb_cmd_desc_t {
+	tee_shd_cb_cmd_t  cmd;
+	uint32_t	ret;
+	void	*data;
+} tee_shd_cb_cmd_desc_t;
+
+static inline void tee_shd_get_uuid(
+	int8_t *name, uint8_t type, uint8_t id, void *uuid)
+{
+	tee_shd_cb_uuid_t *adaptor = (tee_shd_cb_uuid_t *)uuid;
+
+	OSA_ASSERT(strlen(name) <= 10);
+
+	memset(uuid, 0, sizeof(tee_shd_cb_uuid_t));
+	adaptor->prefix = TEE_SHD_UUID_PREFIX;
+	memcpy(adaptor->name, name, strlen(name));
+	adaptor->id = id;
+}
+
+#endif /* __TEE_SHD_COMMON_H__ */
diff --git a/drivers/marvell/security/marvelltee/inc/teec_cb.h b/drivers/marvell/security/marvelltee/inc/teec_cb.h
new file mode 100644
index 0000000..d449e51
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/inc/teec_cb.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+
+#ifndef __TEEC_CB_H__
+#define __TEEC_CB_H__
+
+#include "teec_types.h"
+#include "tee_client_api.h"
+#include "tee_cb_common.h"
+
+/* alias */
+typedef TEEC_UUID   teec_cb_uuid_t;
+typedef TEEC_Result teec_cb_stat_t;
+
+/* context in non-trust world */
+typedef void        *teec_cb_cntx_t;
+/* callback handle */
+typedef void        *teec_cb_handle_t;
+
+/* callback function type */
+typedef teec_cb_stat_t (*teec_cb_fn_t)(tee_cb_arg_t *, teec_cb_cntx_t);
+
+/* the function should be called before tee_cb_call_ntw is invoked.
+ * UUIDs with timeLow 0xFFxxxxxx are reserved for TEE internal usage.
+ */
+teec_cb_handle_t teec_reg_cb(const teec_cb_uuid_t *uuid,
+		teec_cb_fn_t func, teec_cb_cntx_t cntx);
+/* once unregistering, the uuid call will be invalid. */
+void teec_unreg_cb(teec_cb_handle_t handle);
+
+#endif /* __TEEC_CB_H__ */
diff --git a/drivers/marvell/security/marvelltee/inc/teec_shd.h b/drivers/marvell/security/marvelltee/inc/teec_shd.h
new file mode 100644
index 0000000..9acc99b
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/inc/teec_shd.h
@@ -0,0 +1,52 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+
+#ifndef __TEEC_SHD_H__
+#define __TEEC_SHD_H__
+
+#define TEEC_SHD_MAGIC                (0x4E734864) /* NsHd */
+
+#define TEEC_SHD_TYPE_INV             (0x00000000)
+#define TEEC_SHD_TYPE_INPUT           (0x00000001)
+#define TEEC_SHD_TYPE_DISPLAY         (0x00000002)
+#define TEEC_SHD_TYPE_GPIO            (0x00000004)
+#define TEEC_SHD_TYPE_MISC            (0x00000008)
+
+#define TEEC_SHD_MAX_NAME_LENGTH      (10)
+
+typedef struct _teec_shd_t teec_shd_t;
+typedef struct _teec_shd_t {
+	uint32_t            magic;
+	uint32_t            ver;
+	int8_t              *name;    /* should same as driver in TW and less than TEEC_SHD_MAX_NAME_LENGTH*/
+	uint32_t            type;
+	uint32_t            id;
+
+	int32_t             (*init)(teec_shd_t *, void **, uint32_t *); /* called when register */
+	void                (*cleanup)(teec_shd_t *); /* called when unregister */
+
+	int32_t             (*sharing)(teec_shd_t *, void *); /* called when TW attach */
+	int32_t             (*revert)(teec_shd_t *, void *);  /* called when TW detach */
+
+	void                *priv;
+} teec_shd_t;
+
+int32_t teec_register_shd(teec_shd_t *shd);
+int32_t teec_unregister_shd(teec_shd_t *shd);
+
+#endif /* __TEEC_SHD_H__ */
diff --git a/drivers/marvell/security/marvelltee/inc/teec_types.h b/drivers/marvell/security/marvelltee/inc/teec_types.h
new file mode 100644
index 0000000..cf8909a
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/inc/teec_types.h
@@ -0,0 +1,23 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+#ifndef _TEEC_TYPES_H_
+#define _TEEC_TYPES_H_
+
+#include "marvelltee_types.h"
+
+#endif /* _TEEC_TYPES_H_ */
diff --git a/drivers/marvell/security/marvelltee/src/Kconfig b/drivers/marvell/security/marvelltee/src/Kconfig
new file mode 100644
index 0000000..0b27200
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/Kconfig
@@ -0,0 +1,6 @@
+
+menuconfig MARVELL_TEE
+	tristate "Enable Marvell TEE Driver"
+	default n
+help
+	Marvell Trust Execution Environment (TEE) Solution in non-trusted world
diff --git a/drivers/marvell/security/marvelltee/src/Makefile b/drivers/marvell/security/marvelltee/src/Makefile
new file mode 100644
index 0000000..8907175
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/Makefile
@@ -0,0 +1,117 @@
+
+# debug for MARVELLTEE
+MARVELLTEE_DBG := N
+
+# debug proc fs
+MARVELLTEE_DBG_PROC_FS := Y
+
+# debug for OSA
+OSA_DEBUG := Y
+
+# measure performance
+MARVELLTEE_PERF_REC := N
+
+# sharedMem context checking
+MARVELLTEE_SHAREDMEM_CONTEXT_CHECKING := N
+
+# SW SEED
+MARVELLTEE_SW_SEED := N
+
+# LPM
+MARVELLTEE_LPM := N
+
+obj-$(CONFIG_MARVELL_TEE) := marvelltee.o
+marvelltee-objs := \
+	osa/osa.o \
+	osa/osa_atomic.o \
+	osa/osa_dbg.o \
+	osa/osa_delay.o \
+	osa/osa_irq.o \
+	osa/osa_list.o \
+	osa/osa_mem.o \
+	osa/osa_sync.o \
+	osa/osa_thread.o \
+	osa/osa_sched.o \
+	\
+	main/marvelltee_main_core.o \
+	main/marvelltee_main.o \
+	main/marvelltee_pt.o \
+	main/marvelltee_pt_core.o \
+	main/marvelltee_call_tw.o \
+	main/teec_client_api.o \
+	main/teec_cb.o \
+	main/teec_shd.o \
+	main/teec_time.o \
+	\
+	msgm/ntw/tee_msgm_handle_params.o \
+	msgm/ntw/tee_msgm_close_ss.o \
+	msgm/ntw/tee_msgm_open_ss.o \
+	msgm/ntw/tee_msgm_map_shm.o \
+	msgm/ntw/tee_msgm_unmap_shm.o \
+	msgm/ntw/tee_msgm_inv_op.o \
+	msgm/ntw/tee_msgm_can_op.o \
+	msgm/ntw/tee_msgm_ntw.o \
+	\
+	comm/ntw/tee_cm_ntw.o \
+	comm/ntw/tee_cm_init_ntw.o \
+	comm/ntw/tee_cm_misc_ntw.o \
+	\
+	memm/tee_memm.o
+
+ccflags-y += -DTW_ADDR_BASE=0x4400000
+
+ifeq ($(MARVELLTEE_SW_SEED), Y)
+marvelltee-objs += main/teec_seed_src.o
+ccflags-y += -DSW_SEED
+endif
+
+ifeq ($(MARVELLTEE_LPM), Y)
+ccflags-y += -DMARVELLTEE_LPM
+endif
+
+ifeq ($(MARVELLTEE_DBG), Y)
+ccflags-y += -DMARVELLTEE_DEBUG
+endif
+
+ifeq ($(OSA_DEBUG), Y)
+ccflags-y += -DOSA_DEBUG
+endif
+
+ifeq ($(MARVELLTEE_PERF_REC), Y)
+ccflags-y += -DTEE_PERF_MEASURE -I$(CWD)/perf/ntw
+marvelltee-objs += perf/tee_perf.o
+endif
+
+ifeq ($(MARVELLTEE_DBG_PROC_FS), Y)
+ccflags-y += -DTEE_DEBUG_ENALBE_PROC_FS_LOG
+marvelltee-objs += dbg/ntw/tee_dbg_log.o
+endif
+
+ifeq ($(MARVELLTEE_SHAREDMEM_CONTEXT_CHECKING), Y)
+ccflags-y += -DSHAREDMEM_CONTEXT_CHECKING
+endif
+
+ifeq ($(CONFIG_64BIT), y)
+ccflags-y += -fno-pic
+marvelltee-objs += comm/tee_cm_smi.64b.o \
+             main/marvelltee_compat.o
+else
+marvelltee-objs += comm/tee_cm_smi.32b.o
+endif
+
+ifeq ($(CONFIG_TEE_RES_CFG_16M), y)
+ccflags-y += -DTEE_RES_CFG_16M
+else ifeq ($(CONFIG_TEE_RES_CFG_24M), y)
+ccflags-y += -DTEE_RES_CFG_24M
+else
+ccflags-y += -DTEE_RES_CFG_8M
+endif
+
+ccflags-y += -Wall -O2 \
+				-I$(src)/osa/ \
+				-I$(src)/osa/include \
+				-I$(src)/../inc \
+				-I$(src)/inc \
+				-I$(src)/comm/ntw \
+				-I$(src)/main \
+				-I$(src)/memm
diff --git a/drivers/marvell/security/marvelltee/src/comm/ntw/tee_cm_init_ntw.c b/drivers/marvell/security/marvelltee/src/comm/ntw/tee_cm_init_ntw.c
new file mode 100644
index 0000000..be4d0fd
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/comm/ntw/tee_cm_init_ntw.c
@@ -0,0 +1,119 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+
+#include "tee_client_api.h"
+#include "tee_cm_internal.h"
+#include "tee_cm.h"
+#include "tee_perf.h"
+
+/* variables */
+extern void *in_header;
+extern void *in_buf;		/* rb data buffer */
+extern uint32_t in_buf_size;
+extern void *out_header;
+extern void *out_buf;		/* rc data buffer */
+extern uint32_t out_buf_size;
+extern int32_t _g_idx_in_read;
+
+/* rb mapping info */
+static ulong_t _g_phys_rb;
+static ulong_t _g_size_rb;
+static ulong_t _g_virt_rb;
+/* rc mapping info */
+static ulong_t _g_phys_rc;
+static ulong_t _g_size_rc;
+static ulong_t _g_virt_rc;
+
+#ifdef TEE_DEBUG_ENALBE_PROC_FS_LOG
+extern void tee_dbg_log_init(ulong_t buffer, ulong_t ctl);
+#endif
+
+extern int32_t *_cm_in_write_idx(void);
+
+tee_cm_stat tee_cm_init(void)
+{
+	tee_cm_stat ret = TEEC_SUCCESS;
+#ifdef TEE_PERF_MEASURE
+	uint32_t *perf_buffer;
+#endif
+	/* map RB */
+	_g_phys_rb = _read_rb_phys_addr();
+	_g_size_rb = _read_rb_size();
+	_g_virt_rb =
+		(ulong_t)ioremap_wc(_g_phys_rb, (uint32_t)(_g_size_rb));
+	pr_err("remap rb to 0x%lx\n", _g_virt_rb);
+
+	/* map RC */
+	_g_phys_rc = _read_rc_phys_addr();
+	_g_size_rc = _read_rc_size();
+	_g_virt_rc =
+		(ulong_t)ioremap_wc(_g_phys_rc, (uint32_t)(_g_size_rc));
+	pr_err("remap rc to 0x%lx\n", _g_virt_rc);
+
+#ifdef TEE_PERF_MEASURE
+	/* map permance log buffer */
+	perf_buffer =
+	    (uint32_t *) ioremap_wc(PERF_BUF_ADDR, PERF_BUF_SIZE);
+	tee_perf_init((uint32_t *) perf_buffer);
+	pr_err("remap perf log buffer to 0x%x\n", (uint32_t) perf_buffer);
+#endif
+
+	in_header = (void *)_g_virt_rb;
+	in_buf = (void *)((ulong_t) in_header + sizeof(cm_index_header_t));
+	in_buf_size = _g_size_rb / 2 - sizeof(cm_index_header_t);
+
+	OSA_ASSERT(_g_virt_rc);
+	memset((void *)_g_virt_rc, 0, _g_size_rc);
+	out_header = (void *)_g_virt_rc;
+	out_buf = (void *)((ulong_t) out_header + sizeof(cm_index_header_t));
+	out_buf_size = _g_size_rc / 2 - sizeof(cm_index_header_t);
+
+#ifdef TEE_DEBUG_ENALBE_PROC_FS_LOG
+	tee_dbg_log_init((ulong_t) in_buf + in_buf_size,
+			 (ulong_t) out_buf + out_buf_size);
+#endif
+
+	_g_idx_in_read = *_cm_in_write_idx();
+	return ret;
+}
+
+void tee_cm_cleanup(void)
+{
+	/* resetting */
+	in_header = NULL;
+	in_buf = NULL;
+	in_buf_size = 0;
+	out_header = NULL;
+	out_buf = NULL;
+	out_buf_size = 0;
+
+	/* unmap RB */
+	if (_g_virt_rb)
+		osa_iounmap_cached((void *)_g_virt_rb, _g_size_rb);
+
+	/* free RC */
+	if (_g_virt_rc)
+		osa_iounmap_cached((void *)_g_virt_rc, _g_size_rc);
+
+	_g_phys_rb = 0;
+	_g_virt_rb = 0;
+	_g_size_rb = 0;
+	_g_phys_rc = 0;
+	_g_virt_rc = 0;
+	_g_size_rc = 0;
+}
diff --git a/drivers/marvell/security/marvelltee/src/comm/ntw/tee_cm_internal.h b/drivers/marvell/security/marvelltee/src/comm/ntw/tee_cm_internal.h
new file mode 100644
index 0000000..57d17a4
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/comm/ntw/tee_cm_internal.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+
+#ifndef _TEE_CM_INTERNAL_H_
+#define _TEE_CM_INTERNAL_H_
+
+#include "tee_client_api.h"
+#include "osa.h"
+#include "tee_msgm_ntw.h"
+
+#define CM_BLK_MAGIC    (0xC1C2C3C4)
+#define CM_PAD_CHAR     (0)
+
+/* read/write index header */
+typedef struct {
+	int32_t idx_read;	/* res pool read index */
+	int32_t idx_write;	/* req pool write index */
+	uint32_t req_tw;
+	uint32_t rsp_tw;
+} cm_index_header_t;
+
+/* smi trap arguments */
+typedef struct {
+	uint32_t arg0;
+	uint32_t arg1;
+	uint32_t arg2;
+} tee_cm_smi_input_t;
+
+#endif /* _TEE_CM_INTERNAL_H_ */
diff --git a/drivers/marvell/security/marvelltee/src/comm/ntw/tee_cm_misc_ntw.c b/drivers/marvell/security/marvelltee/src/comm/ntw/tee_cm_misc_ntw.c
new file mode 100644
index 0000000..3f4d02b
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/comm/ntw/tee_cm_misc_ntw.c
@@ -0,0 +1,88 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+
+#include "tee_client_api.h"
+#include "tee_cm_internal.h"
+#include "tee_cm.h"
+
+extern void *in_header;
+extern void *out_header;
+
+static int32_t _g_idx_out_write;
+/* _g_idx_in_read is initialized in tee_cm_init */
+int32_t _g_idx_in_read;
+
+/* get in read idx's pointer */
+inline int32_t *_cm_in_read_idx(void)
+{
+	return &_g_idx_in_read;
+}
+
+/* get in write idx's pointer(the other end modify) */
+inline int32_t *_cm_in_write_idx(void)
+{
+	cm_index_header_t *in_head = (cm_index_header_t *) in_header;
+
+	return &(in_head->idx_write);
+}
+
+/* get out read idx's pointer(the other and modify */
+/* _cm_out_read_idx and _cm_out_write_idx are replaced
+ * by _cm_get_out_write_idx and _cm_update_out_write_idx
+ */
+inline int32_t *_cm_out_read_idx(void)
+{
+	cm_index_header_t *out_head = (cm_index_header_t *) out_header;
+
+	return &(out_head->idx_read);
+}
+
+/* get out write idx's pointer */
+inline int32_t *_cm_out_write_idx(void)
+{
+	static int32_t idx_out_write;
+
+	return &idx_out_write;
+}
+
+inline int32_t _cm_get_out_write_idx(void)
+{
+	return _g_idx_out_write;
+}
+
+inline void _cm_update_out_write_idx(int32_t idx)
+{
+	cm_index_header_t *out_head = (cm_index_header_t *) out_header;
+
+	_g_idx_out_write = idx;
+	out_head->idx_write = idx;
+}
+
+inline uint32_t _cm_get_cb_req_num(void)
+{
+	cm_index_header_t *in_head = (cm_index_header_t *)in_header;
+
+	return in_head->req_tw;
+}
+
+inline uint32_t _cm_get_cb_rsp_num(void)
+{
+	cm_index_header_t *in_head = (cm_index_header_t *)in_header;
+
+	return in_head->rsp_tw;
+}
diff --git a/drivers/marvell/security/marvelltee/src/comm/ntw/tee_cm_ntw.c b/drivers/marvell/security/marvelltee/src/comm/ntw/tee_cm_ntw.c
new file mode 100644
index 0000000..dc863a2
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/comm/ntw/tee_cm_ntw.c
@@ -0,0 +1,230 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+
+#include "tee_cm_internal.h"
+#include "tee_cm.h"
+
+/* variables */
+void *in_header;
+void *in_buf;		/* rb data buffer */
+uint32_t in_buf_size;
+void *out_header;
+void *out_buf;		/* rc data buffer */
+uint32_t out_buf_size;
+/* if wr idx wrap around and behind rd idx, this is min space to reserved */
+#define BAR_SIZE	(4)
+
+/*** facility functions/macros ***/
+extern int32_t *_cm_in_read_idx(void);
+extern int32_t *_cm_in_write_idx(void);
+extern int32_t *_cm_out_read_idx(void);
+extern int32_t *_cm_out_write_idx(void);
+#define IN_RD_IDX (*_cm_in_read_idx())		/* RB, read_index */
+#define IN_WR_IDX (*_cm_in_write_idx())		/* RB, write_index */
+#define OUT_RD_IDX (*_cm_out_read_idx())	/* RC, read_index */
+#define OUT_WR_IDX (*_cm_out_write_idx())	/* RC, write_index */
+
+extern void cm_call_smi(void *arg);
+
+extern int32_t _cm_get_out_write_idx(void);
+extern void _cm_update_out_write_idx(int32_t idx);
+
+extern uint32_t _cm_get_cb_req_num(void);
+extern uint32_t _cm_get_cb_rsp_num(void);
+
+/* get out empty size */
+uint32_t _out_empty_size(void)
+{
+	uint32_t ret = 0;
+	int32_t delta = OUT_WR_IDX - OUT_RD_IDX;
+
+	if (delta >= 0)	/* data size */
+		ret = out_buf_size - (delta) - BAR_SIZE;
+	else		/* data size */
+		ret = out_buf_size - (delta + out_buf_size) - BAR_SIZE;
+
+	return ret;
+}
+
+/* get in data size */
+uint32_t _in_data_size(void)
+{
+	uint32_t ret = 0;
+	int32_t delta = IN_WR_IDX - IN_RD_IDX;
+
+	if (delta >= 0)
+		ret = delta;
+	else
+		ret = in_buf_size - delta - BAR_SIZE;
+
+	return ret;
+}
+
+/* out writing */
+void _out_write(int8_t *buf, uint32_t len, int32_t *idx)
+{
+	uint32_t end;
+
+	OSA_ASSERT(len < out_buf_size);
+
+	end = (uint32_t)(*idx) + len;
+	if (end > out_buf_size) {
+		uint32_t remained_sz;
+		uint32_t current_sz;
+
+		remained_sz = end - out_buf_size;
+		current_sz = out_buf_size - (uint32_t)(*idx);
+		memcpy(out_buf + *idx, buf, current_sz);
+		memcpy(out_buf, buf + current_sz, remained_sz);
+		*idx = remained_sz;
+	} else {
+		memcpy(out_buf + *idx, buf, len);
+		*idx = end;
+	}
+}
+
+/* in reading */
+void _in_read(int8_t *buf, uint32_t len, int32_t *idx)
+{
+	uint32_t end;
+
+	OSA_ASSERT(len < in_buf_size);
+
+	end = (uint32_t)(*idx) + len;
+	if (end > in_buf_size) {
+		uint32_t remained_sz;
+		uint32_t current_sz;
+
+		remained_sz = end - in_buf_size;
+		current_sz = in_buf_size - (uint32_t)(*idx);
+		memcpy(buf, in_buf + *idx, current_sz);
+		memcpy(buf + current_sz, in_buf, remained_sz);
+		*idx = remained_sz;
+	} else {
+		memcpy(buf, in_buf + *idx, len);
+		*idx = end;
+	}
+}
+
+bool tee_cm_send_data(uint8_t *buf)
+{
+	bool ret = true;
+	uint32_t size;
+	/* int32_t idx = OUT_WR_IDX; */
+	int32_t idx;
+	tee_msg_head_t *tee_msg_head;
+
+	tee_msg_head = (tee_msg_head_t *)buf;
+
+	size = sizeof(tee_msg_head_t) + tee_msg_head->msg_sz;
+
+#if 0	/* zyq 20130207, find the bugs with RB and RC */
+	/* check if there is enough space */
+	if (_out_empty_size() < size)
+		return false;
+#endif
+
+	idx = _cm_get_out_write_idx();
+
+	/* write caller's data */
+	_out_write((int8_t *)buf, size, &idx);
+
+	/* set out write index */
+	_cm_update_out_write_idx(idx);
+	/* OUT_WR_IDX = idx; */
+
+	return ret;
+}
+
+extern uint32_t pr(int8_t *fmt, ...);
+uint32_t tee_cm_get_data_size(void)
+{
+	uint32_t size_in_data = _in_data_size();
+	tee_msg_head_t tee_msg_head;
+	int8_t magic[4];
+	uint32_t size;
+	int32_t idx = IN_RD_IDX;
+
+	if (size_in_data < 4)
+		return 0;
+
+	_in_read(magic, 4, &idx);
+	idx = IN_RD_IDX;
+
+	if (size_in_data < sizeof(tee_msg_head_t))
+		return 0;
+
+	_in_read((int8_t *)(&tee_msg_head), sizeof(tee_msg_head_t), &idx);
+	size = sizeof(tee_msg_head_t) + tee_msg_head.msg_sz;
+
+	return size;
+}
+
+void tee_cm_recv_data(uint8_t *buf)
+{
+	tee_msg_head_t *tee_msg_head = (tee_msg_head_t *)buf;
+	int32_t idx = IN_RD_IDX;
+
+	_in_read((int8_t *)buf, sizeof(tee_msg_head_t), &idx);
+
+	/* output data */
+	_in_read((int8_t *)buf + sizeof(tee_msg_head_t), tee_msg_head->msg_sz, &idx);
+
+	/* update rb read index */
+	IN_RD_IDX = idx;
+}
+
+void tee_cm_get_recv_buf(void **head)
+{
+	tee_msg_head_t tee_msg_head;
+	int32_t idx = IN_RD_IDX;
+
+	_in_read((int8_t *)(&tee_msg_head), sizeof(tee_msg_head_t), &idx);
+
+	*head = tee_msg_head.tee_msg;
+}
+
+void tee_cm_smi(uint32_t flag)
+{
+	tee_cm_smi_input_t tee_cm_smi_input;
+
+	tee_cm_smi_input.arg0 = flag;
+	tee_cm_smi_input.arg1 = 0;
+	tee_cm_smi_input.arg2 = 0;
+
+	cm_call_smi(&tee_cm_smi_input);
+}
+
+void tee_cm_get_msgm_head(void *msg_head)
+{
+	int32_t idx = IN_RD_IDX;
+
+	OSA_ASSERT(msg_head);
+
+	_in_read((int8_t *)msg_head, sizeof(tee_msg_head_t), &idx);
+}
+
+uint32_t tee_cm_get_cb_req_num(void)
+{
+	return _cm_get_cb_req_num();
+}
+
+uint32_t tee_cm_get_cb_rsp_num(void)
+{
+	return _cm_get_cb_rsp_num();
+}
diff --git a/drivers/marvell/security/marvelltee/src/comm/tee_cm_smi.32b.S b/drivers/marvell/security/marvelltee/src/comm/tee_cm_smi.32b.S
new file mode 100644
index 0000000..12a2570
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/comm/tee_cm_smi.32b.S
@@ -0,0 +1,15 @@
+
+.globl cm_call_smi
+
+cm_call_smi:
+	stmdb   sp!, {r1-r12,lr}
+
+	ldr   r1,  [r0, #4]
+	ldr   r2,  [r0, #8]
+	ldr   r0,  [r0, #0]
+
+#if (__GNUC__ >= 4 && __GNUC_MINOR__ >= 6)
+    .arch_extension sec
+#endif
+	smc #0
+	ldmia   sp!, {r1-r12,pc}
diff --git a/drivers/marvell/security/marvelltee/src/comm/tee_cm_smi.64b.S b/drivers/marvell/security/marvelltee/src/comm/tee_cm_smi.64b.S
new file mode 100644
index 0000000..2c9b2b8
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/comm/tee_cm_smi.64b.S
@@ -0,0 +1,28 @@
+	.globl cm_call_smi
+cm_call_smi:
+
+	sub sp, sp, #96
+
+	stp x19, x20, [sp, #0]
+	stp x21, x22, [sp, #16]
+	stp x23, x24, [sp, #32]
+	stp x25, x26, [sp, #48]
+	stp x27, x28, [sp, #64]
+	stp x29, x30, [sp, #80]
+
+	/* flag: ipi or smc */
+	ldr w0, [x0]
+	/* w1/w2/3/4/5/6 - reserved */
+
+	smc #0
+
+	ldp x29, x30, [sp, #80]
+	ldp x27, x28, [sp, #64]
+	ldp x25, x26, [sp, #48]
+	ldp x23, x24, [sp, #32]
+	ldp x21, x22, [sp, #16]
+	ldp x19, x20, [sp, #0]
+
+	add sp, sp, #96
+
+	ret
diff --git a/drivers/marvell/security/marvelltee/src/dbg/ntw/tee_dbg_log.c b/drivers/marvell/security/marvelltee/src/dbg/ntw/tee_dbg_log.c
new file mode 100644
index 0000000..3e87ec1
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/dbg/ntw/tee_dbg_log.c
@@ -0,0 +1,273 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+#include "marvelltee_internal.h"
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+
+#define _TEE_DBG_PROC_LEVEL0	(0x00000000)
+#define _TEE_DBG_PROC_LEVEL1	(0x55aa55aa)
+#define _TEE_DBG_PROC_LEVEL2	(0x66bb66bb)
+#define _TEE_DBG_PROC_LEVEL3	(0x77cc77cc)
+
+#define IS_DBG_PROC_MAGIC_VALID(_m) \
+	(('P' == _m[0]) &&  \
+	 ('r' == _m[1]) &&   \
+	 ('O' == _m[2]) &&   \
+	 ('c' == _m[3]))
+
+#define INIT_DBG_PROC_CTRL_MAGIC(_m)	do {	\
+		_m[0] = 'C';	\
+		_m[1] = 't';	\
+		_m[2] = 'R';	\
+		_m[3] = 'l';	\
+	} while (0)
+
+typedef struct _tee_dbg_log_t {
+	uint8_t magic[4];
+	uint32_t write_offset;
+	uint64_t round;
+	uint32_t log_buf_sz;
+} tee_dbg_log_t;
+
+typedef struct _tee_dbg_log_ctl_t {
+	uint8_t magic[4];
+	uint32_t level;
+} tee_dbg_log_ctl_t;
+
+static tee_dbg_log_t *_g_tee_dbg_log_header;
+static tee_dbg_log_ctl_t *_g_tee_dbg_log_ctl_header;
+static uint8_t *_g_tee_dbg_log_buf;
+static uint32_t _g_tee_dbg_log_buf_sz;
+
+void tee_dbg_log_init(ulong_t buffer, ulong_t ctl)
+{
+	_g_tee_dbg_log_header = (tee_dbg_log_t *) buffer;
+	_g_tee_dbg_log_ctl_header = (tee_dbg_log_ctl_t *) ctl;
+	_g_tee_dbg_log_buf = (uint8_t *) (_g_tee_dbg_log_header + 1);
+
+	if (!IS_DBG_PROC_MAGIC_VALID(_g_tee_dbg_log_header->magic)) {
+		pr_err("proc log invalid magic\n");
+		return;
+	}
+	_g_tee_dbg_log_buf_sz = _g_tee_dbg_log_header->log_buf_sz;
+
+	INIT_DBG_PROC_CTRL_MAGIC(_g_tee_dbg_log_ctl_header->magic);
+
+	pr_err("proc log buf: 0x%lx, size: 0x%x, ctl: 0x%lx\n",
+		buffer, _g_tee_dbg_log_buf_sz, ctl);
+}
+
+static uint32_t g_snapshot_write_offset;
+static uint64_t g_snapshot_round;
+static uint64_t g_read_round;
+static uint32_t g_read_offset;
+static uint32_t g_read_count;
+static uint32_t g_proc_log_level;
+
+static void *log_seq_start(struct seq_file *s, loff_t *pos)
+{
+	g_snapshot_write_offset = _g_tee_dbg_log_header->write_offset;
+	g_snapshot_round = _g_tee_dbg_log_header->round;
+
+	if ((!IS_DBG_PROC_MAGIC_VALID(_g_tee_dbg_log_header->magic)) ||
+		(!_g_tee_dbg_log_buf_sz))
+		return NULL;
+
+	if (g_read_round == g_snapshot_round
+		&& g_read_offset == g_snapshot_write_offset)
+		/* nothing to read */
+		return NULL;
+
+	if ((g_snapshot_round > g_read_round + 1) ||
+		(g_snapshot_round == g_read_round + 1
+		&& g_snapshot_write_offset > g_read_offset)) {
+		g_read_offset = g_snapshot_write_offset;
+		g_read_round = g_snapshot_round - 1;
+		seq_printf(s,
+				"--------------------------rollback--------------------------\n");
+	}
+
+	g_read_count = s->count;
+
+	return _g_tee_dbg_log_buf + g_read_offset;
+}
+
+static void *log_seq_next(struct seq_file *s, void *v, loff_t *pos)
+{
+	g_read_count = s->count;
+
+	if (g_read_round == g_snapshot_round
+		&& g_read_offset == g_snapshot_write_offset)
+		/* nothing to read */
+		return NULL;
+
+	return _g_tee_dbg_log_buf + g_read_offset;
+}
+
+static void log_seq_stop(struct seq_file *s, void *v)
+{
+}
+
+static int log_seq_show(struct seq_file *s, void *v)
+{
+	int ret = 0;
+#if 0
+	ret = seq_printf(s, "%s", (int8_t *) v);
+	if (ret)
+		/* over flow */
+	else
+		g_read_offset += s->count - g_read_count + 1;
+#else
+	/* in kernel 4.4.8, the return type of function seq_printf is void. */
+	seq_printf(s, "%s", (int8_t *) v);
+	g_read_offset += s->count - g_read_count + 1;
+#endif
+
+	if (g_read_offset > _g_tee_dbg_log_buf_sz) {
+		g_read_offset -= _g_tee_dbg_log_buf_sz;
+		g_read_round++;
+	}
+
+	return ret;
+}
+
+static const struct seq_operations log_seq_ops = {
+	.start = log_seq_start,
+	.next = log_seq_next,
+	.stop = log_seq_stop,
+	.show = log_seq_show
+};
+
+static int log_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &log_seq_ops);
+}
+
+static const struct file_operations log_file_ops = {
+	.owner = THIS_MODULE,
+	.open = log_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = seq_release
+};
+
+static int ctl_seq_show(struct seq_file *m, void *v)
+{
+	seq_printf(m, "tee proc log level %d\n", g_proc_log_level);
+	return 0;
+}
+
+static int ctl_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, ctl_seq_show, NULL);
+}
+
+static ssize_t ctl_write(struct file *file, const char *buf,
+			 size_t count, loff_t *pos)
+{
+	char val;
+
+	get_user(val, buf);
+	switch (val) {
+	case '0':
+		_g_tee_dbg_log_ctl_header->level = _TEE_DBG_PROC_LEVEL0;
+		g_proc_log_level = 0;
+		break;
+	case '1':
+		_g_tee_dbg_log_ctl_header->level = _TEE_DBG_PROC_LEVEL1;
+		g_proc_log_level = 1;
+		break;
+	case '2':
+		_g_tee_dbg_log_ctl_header->level = _TEE_DBG_PROC_LEVEL2;
+		g_proc_log_level = 2;
+		break;
+	case '3':
+		_g_tee_dbg_log_ctl_header->level = _TEE_DBG_PROC_LEVEL3;
+		g_proc_log_level = 3;
+		break;
+	default:
+		pr_err("value should be 0/1/2/3\n");
+		return count;
+	}
+
+	return count;
+}
+
+static const struct file_operations ctl_file_ops = {
+	.owner = THIS_MODULE,
+	.open = ctl_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+	.write = ctl_write,
+};
+
+extern uint32_t g_msg_sent;
+extern uint32_t g_msg_recv;
+extern uint32_t g_msg_fake;
+extern uint32_t g_msg_ignd;
+extern uint32_t g_pre_ipi_num;
+extern uint32_t g_pst_ipi_num;
+extern uint32_t g_pre_dmy_num;
+extern uint32_t g_pst_dmy_num;
+
+extern uint32_t marvelltee_get_req_num_in_list(void);
+
+static int stat_seq_show(struct seq_file *m, void *v)
+{
+	seq_printf(m, "lst: %d\n"
+		   "msg: sent %d, recv %d, fake %d, ignd %d\n"
+		   "smc: pre-ipi %d, pst-ipi %d, pre-dmy %d, pst-dmy %d\n",
+		   marvelltee_get_req_num_in_list(),
+		   g_msg_sent, g_msg_recv, g_msg_fake, g_msg_ignd,
+		   g_pre_ipi_num, g_pst_ipi_num, g_pre_dmy_num, g_pst_dmy_num);
+	return 0;
+}
+
+static int stat_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, stat_seq_show, NULL);
+}
+
+static const struct file_operations stat_file_ops = {
+	.owner = THIS_MODULE,
+	.open = stat_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+};
+
+struct proc_dir_entry *_g_marvelltee_entry;
+void tee_dbg_proc_fs_init(void)
+{
+	_g_marvelltee_entry = proc_mkdir("tee", NULL);
+
+	proc_create("log", S_IRUGO, _g_marvelltee_entry, &log_file_ops);
+	proc_create("enable", S_IRUGO | S_IWUGO, _g_marvelltee_entry, &ctl_file_ops);
+	proc_create("stat", S_IRUGO, _g_marvelltee_entry, &stat_file_ops);
+}
+
+void tee_dbg_proc_fs_cleanup(void)
+{
+	if (_g_marvelltee_entry) {
+		remove_proc_entry("log", _g_marvelltee_entry);
+		remove_proc_entry("enable", _g_marvelltee_entry);
+		remove_proc_entry("stat", _g_marvelltee_entry);
+		remove_proc_entry("tee", NULL);
+	}
+}
diff --git a/drivers/marvell/security/marvelltee/src/dbg/tee_dump.sh b/drivers/marvell/security/marvelltee/src/dbg/tee_dump.sh
new file mode 100755
index 0000000..05c7261
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/dbg/tee_dump.sh
@@ -0,0 +1,4 @@
+#!/bin/sh
+
+#the script runs on device
+while ( true ) do cat /proc/tee/log; done
diff --git a/drivers/marvell/security/marvelltee/src/dbg/tee_enable_dbg.sh b/drivers/marvell/security/marvelltee/src/dbg/tee_enable_dbg.sh
new file mode 100755
index 0000000..a97d884
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/dbg/tee_enable_dbg.sh
@@ -0,0 +1,4 @@
+#!/bin/sh
+
+#the script runs on device
+echo 1 > /proc/tee/enable; cat /proc/tee/enable
diff --git a/drivers/marvell/security/marvelltee/src/inc/tee_cm.h b/drivers/marvell/security/marvelltee/src/inc/tee_cm.h
new file mode 100644
index 0000000..3a38ed7
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/inc/tee_cm.h
@@ -0,0 +1,69 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+
+#ifndef _TEE_CM_H_
+#define _TEE_CM_H_
+
+#include "tee-addr-map.h"
+
+typedef uint32_t tee_cm_stat;
+/* initialization function, return err code */
+extern tee_cm_stat tee_cm_init(void);
+/* deinitialization function, return err code */
+extern void tee_cm_cleanup(void);
+/* write data to the other end */
+extern bool tee_cm_send_data(uint8_t *buf);
+/* get the size of current available data */
+extern uint32_t tee_cm_get_data_size(void);
+/* get the destination buffer for receiver*/
+extern void tee_cm_get_recv_buf(void **head);
+/* receive data */
+extern void tee_cm_recv_data(uint8_t *buf);
+extern void tee_cm_smi(uint32_t flag);
+extern void tee_cm_get_msgm_head(void *msg_head);
+
+extern uint32_t tee_cm_get_cb_req_num(void);
+extern uint32_t tee_cm_get_cb_rsp_num(void);
+extern void tee_cm_update_cb_req_num(uint32_t req_tw);
+extern void tee_cm_update_cb_rsq_num(uint32_t rsp_tw);
+
+/* read RB phys address */
+static inline uint32_t _read_rb_phys_addr(void)
+{
+	return (ulong_t)RB_PHYS_ADDR;
+}
+
+/* read RB size */
+static inline uint32_t _read_rb_size(void)
+{
+	return (ulong_t)RB_SIZE;
+}
+
+/* read RC phys address */
+static inline uint32_t _read_rc_phys_addr(void)
+{
+	return (ulong_t)RC_PHYS_ADDR;
+}
+
+/* read RC size */
+static inline uint32_t _read_rc_size(void)
+{
+	return (ulong_t)RC_SIZE;
+}
+
+#endif /* _TEE_CM_H_ */
diff --git a/drivers/marvell/security/marvelltee/src/inc/tee_memm.h b/drivers/marvell/security/marvelltee/src/inc/tee_memm.h
new file mode 100644
index 0000000..e2c4f22
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/inc/tee_memm.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+
+#ifndef _TEE_MEMM_H_
+#define _TEE_MEMM_H_
+typedef void *tee_memm_ss_t;
+typedef struct _tee_mem_page_t {
+	void *phy_addr;
+	size_t len;
+	uint32_t cacheable;
+	uint32_t rsvd;
+} tee_mem_page_t;
+tee_memm_ss_t tee_memm_create_ss(void);
+void tee_memm_destroy_ss(tee_memm_ss_t tee_memm_ss);
+tee_stat_t tee_memm_set_phys_pages(tee_memm_ss_t tee_memm_ss,
+				   void *virt, uint32_t size,
+				   tee_mem_page_t *pages, uint32_t *pages_num);
+tee_stat_t tee_memm_get_user_mem(tee_memm_ss_t tee_memm_ss, void __user *virt,
+					uint32_t size, void __kernel **kvirt);
+void tee_memm_put_user_mem(tee_memm_ss_t tee_memm_ss, void *vm);
+
+#endif /* _TEE_MEMM_H_ */
diff --git a/drivers/marvell/security/marvelltee/src/inc/tee_mrvl_imp.h b/drivers/marvell/security/marvelltee/src/inc/tee_mrvl_imp.h
new file mode 100644
index 0000000..27024a6
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/inc/tee_mrvl_imp.h
@@ -0,0 +1,70 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+#ifndef _TEE_MRVL_IMP_H_
+#define _TEE_MRVL_IMP_H_
+
+#include "marvelltee_types.h"
+#include "osa.h"
+#include "marvelltee_list.h"
+
+typedef void *tee_ss_ntw;
+typedef void *tee_msg_handle_t;
+
+#define   MGC_NUM   (4)
+
+typedef struct __tee_ctx_ntw {
+	uint8_t magic[MGC_NUM];
+	/* add the count if there is a session or sharedmemory */
+	osa_atomic_t count;
+	tee_impl tee_ctx_ntw;
+	tee_impl private_data;
+} _TEEC_MRVL_Context;
+
+typedef struct __tee_ss_ntw {
+	uint8_t magic[MGC_NUM];
+	/* add the count if there is an operation */
+	osa_atomic_t count;
+	tee_impl tee_ctx_ntw;
+	tee_impl tee_ss_tw;
+	tee_impl tee_ss_ntw;
+	tee_impl private_data;
+} _TEEC_MRVL_Session;
+
+typedef struct __tee_op_ntw {
+	uint8_t magic[MGC_NUM];
+	tee_ss_ntw tee_ss_ntw;
+	tee_msg_handle_t tee_msg_ntw;
+	tee_impl tee_op_ntw;
+} _TEEC_MRVL_Operation;
+
+typedef struct __tee_shm_ntw {
+	uint8_t magic[MGC_NUM];
+	/* add the count if there is a memref in the operation */
+	osa_atomic_t count;
+	tee_impl tee_ctx_ntw;
+	void *vaddr_tw;
+	uint32_t size;
+	/* who allocates the mem, if flag=1,
+	* it means driver allocate the buffer
+	*/
+	uint32_t flag;
+	tee_impl tee_shm_ntw;
+	tee_impl private_data;
+} _TEEC_MRVL_SharedMemory;
+
+#endif /* _TEE_MRVL_IMP_H_ */
diff --git a/drivers/marvell/security/marvelltee/src/inc/tee_msgm_ntw.h b/drivers/marvell/security/marvelltee/src/inc/tee_msgm_ntw.h
new file mode 100644
index 0000000..62ec029
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/inc/tee_msgm_ntw.h
@@ -0,0 +1,240 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+#ifndef _TEE_MSGM_NTW_H_
+#define _TEE_MSGM_NTW_H_
+
+#include "tee_mrvl_imp.h"
+#include "tee_client_api.h"
+#include "tee_memm.h"
+
+typedef void *tee_msgm_t;
+
+typedef enum _tee_msg_business_stat_t {
+	TEE_MSG_STAT_INVALID,
+	TEE_MSG_STAT_REQ,
+	TEE_MSG_STAT_RSP,
+	TEE_MSG_STAT_CAN,
+} tee_msg_business_stat_t;
+
+typedef enum _tee_msg_control_cmd_t {
+	TEE_MSG_CTL_INVALID,
+	TEE_MSG_CTL_RETURN_TO_NTW,
+	TEE_MSG_CTL_TRAPPED,
+} tee_msg_control_cmd_t;
+
+typedef enum _tee_msg_type_t {
+	TEE_MSG_TYPE_BUSINESS,
+	TEE_MSG_TYPE_CONTROL,
+} tee_msg_type_t;
+
+/*
+ * this struct is like this
+ * ,----------------------------------------------------------,
+ * | type   | tw | tp |      reserve      |       stat        | bp
+ * | 31~28  | 27 | 26 |      25~16        |       15~0        |
+ * |        |-----------------------------+-------------------|
+ * |        |            reserve          |       cmd         | ctl
+ * |        |             27~16           |       15~0        |
+ * |----------------------------------------------------------|
+ * |                            value                         |
+ * |                            32~0                          |
+ * '----------------------------------------------------------'
+ */
+typedef union _tee_msg_prop_t {
+	struct {
+		tee_msg_business_stat_t stat:16;
+		uint32_t:10;
+		bool has_trapped:1;
+		bool is_from_tw:1;
+	} bp;
+	struct {
+		tee_msg_control_cmd_t cmd:16;
+		uint32_t:12;
+	} ctl;
+	struct {
+		uint32_t:28;
+		tee_msg_type_t type:4;
+	};
+	uint32_t value;
+} tee_msg_prop_t;
+
+#ifdef CONFIG_64BIT
+/* open msg-head for updating msg-ntw according to msg-in-rb by pt-ntw */
+typedef struct _tee_msg_head_t {
+	uint8_t magic[4];
+	uint32_t msg_sz;
+	osa_list_t node;
+	tee_msg_prop_t msg_prop;
+	uint32_t caller_uuid; /* used by TA to TA */
+	tee_msg_handle_t tee_msg;
+	osa_sem_t comp;
+	void *reserved;
+} tee_msg_head_t;
+#else
+typedef struct _tee_msg_head_t {
+	uint8_t magic[4];
+	uint32_t msg_sz;
+	osa_list_t node;
+	uint32_t pad[2];
+	tee_msg_prop_t msg_prop;
+	uint32_t caller_uuid; /* used by TA to TA */
+	tee_msg_handle_t tee_msg;
+	uint32_t pad1;
+	osa_sem_t comp;
+	uint32_t pad2;
+	void *reserved;
+	uint32_t pad3;
+} tee_msg_head_t;
+#endif
+
+typedef TEEC_SharedMemory tee_msg_map_shm_info_t;
+typedef TEEC_Operation tee_msg_op_info_t;
+
+typedef enum _tee_cmd_t {
+	TEE_CMD_INVALID,
+	TEE_CMD_MAP_SHM,
+	TEE_CMD_UNMAP_SHM,
+	TEE_CMD_OPEN_SS,
+	TEE_CMD_CLOSE_SS,
+	TEE_CMD_INV_OP,
+	TEE_CMD_CAN_OP,
+} tee_cmd_t;
+
+typedef struct _tee_msgm_msg_info_t {
+	tee_cmd_t cmd;
+	/* valid when map_shm */
+	tee_msg_map_shm_info_t *msg_map_shm_info;
+	/* valid when op available */
+	tee_msg_op_info_t *msg_op_info;
+} tee_msgm_msg_info_t;
+
+/* vvv set_cmd_arg vvv */
+typedef struct _tee_set_cmd_map_shm_arg_t {
+	ulong_t cntx;
+	TEEC_SharedMemory *shm;
+} tee_set_cmd_map_shm_arg_t;
+typedef TEEC_SharedMemory tee_set_cmd_unmap_shm_arg_t;
+typedef struct _tee_set_cmd_open_ss_arg_t {
+	TEEC_UUID *uuid;
+	uint32_t meth;
+	uint32_t rsvd; /* keep 64b-aligned */
+	TEEC_UUID data;
+	ulong_t cntx;
+} tee_set_cmd_open_ss_arg_t;
+typedef void *tee_set_cmd_close_ss_arg_t;
+typedef struct _tee_set_cmd_inv_op_arg_t {
+	void *ss;
+	uint32_t srv_cmd;
+} tee_set_cmd_inv_op_arg_t;
+
+/* typedef TEEC_Operation tee_set_cmd_can_op_arg_t; */
+typedef struct tee_set_cmd_can_op_arg_t {
+	void *ss;
+	TEEC_Operation *operation;
+} tee_set_cmd_can_op_arg_t;
+/* ^^^ set_cmd_arg ^^^ */
+
+/* vvv get_cmd_arg vvv */
+/*
+ * please make sure tee_msgm_phys_memblock_t
+ * in tw should be aligned to this struct.
+ */
+typedef tee_mem_page_t tee_msgm_phys_memblock_t;
+typedef struct _tee_get_cmd_map_shm_arg_t {
+	tee_msgm_phys_memblock_t(*arr)[];
+	uint32_t arr_sz;
+} tee_get_cmd_map_shm_arg_t;
+typedef struct _tee_get_cmd_unmap_shm_arg_t {
+	void *vaddr_tw;
+} tee_get_cmd_unmap_shm_arg_t;
+typedef struct _tee_get_cmd_open_ss_arg_t {
+	TEEC_UUID *uuid;
+	uint32_t meth;
+	TEEC_UUID data;
+	uint32_t data_sz;
+} tee_get_cmd_open_ss_arg_t;
+typedef struct _tee_get_cmd_close_ss_arg_t {
+	void *ss;
+} tee_get_cmd_close_ss_arg_t;
+typedef struct _tee_get_cmd_inv_op_arg_t {
+	void *ss;
+	uint32_t srv_cmd;
+} tee_get_cmd_inv_op_arg_t;
+typedef struct _tee_get_cmd_can_op_arg_t {
+	void *ss;		/* NULL for tee-ss */
+	void *msg;
+} tee_get_cmd_can_op_arg_t;
+/* ^^^ get_cmd_arg ^^^ */
+
+/* vvv get_ret_arg vvv */
+typedef struct _tee_get_ret_map_shm_arg_t {
+	void *vaddr_tw;
+	tee_stat_t ret;
+} tee_get_ret_map_shm_arg_t;
+typedef struct _tee_get_ret_open_ss_arg_t {
+	void *ss_tw;
+	uint32_t ret_orig;
+	tee_stat_t ret;
+} tee_get_ret_open_ss_arg_t;
+typedef struct _tee_get_ret_inv_op_arg_t {
+	uint32_t ret_orig;
+	tee_stat_t ret;
+} tee_get_ret_inv_op_arg_t;
+/* ^^^ get_ret_arg ^^^ */
+
+/* vvv set_ret_arg vvv */
+typedef struct _tee_set_ret_map_shm_arg_t {
+	void *vaddr_tw;
+	tee_stat_t ret;
+} tee_set_ret_map_shm_arg_t;
+typedef struct _tee_set_ret_open_ss_arg_t {
+	void *ss_tw;
+	uint32_t ret_orig;
+	tee_stat_t ret;
+} tee_set_ret_open_ss_arg_t;
+typedef struct _tee_set_ret_inv_op_arg_t {
+	uint32_t ret_orig;
+	tee_stat_t ret;
+} tee_set_ret_inv_op_arg_t;
+/* ^^^ set_ret_arg ^^^ */
+
+tee_msgm_t tee_msgm_create_inst(void);
+/* will not destroy the msg buf */
+void tee_msgm_destroy_inst(tee_msgm_t msgm);
+
+/* "buf = NULL" to get the buf size first */
+/*
+ * the buffer does NOT include the command header.
+ * the header is maintained by callers.
+ * the typical behavior of callers is to alloc
+ * sizeof(tee_msg_head_t) + buf-size.
+ * then set "mem + sizeof(tee_msg_head_t)" as the arg, buf.
+ */
+tee_stat_t tee_msgm_set_msg_buf(tee_msgm_t msgm,
+				tee_msgm_msg_info_t *mi, uint8_t *buf,
+				uint32_t *size);
+
+tee_stat_t tee_msgm_get_cmd(tee_msgm_t msgm, tee_cmd_t *cmd, void *arg);
+tee_stat_t tee_msgm_set_cmd(tee_msgm_t msgm, tee_cmd_t cmd, void *arg);
+
+tee_stat_t tee_msgm_set_params(tee_msgm_t msgm, tee_msg_op_info_t *params);
+tee_stat_t tee_msgm_update_params(tee_msgm_t msgm, tee_msg_op_info_t *params);
+
+tee_stat_t tee_msgm_get_ret(tee_msgm_t msgm, void *arg);
+tee_stat_t tee_msgm_set_ret(tee_msgm_t msgm, void *arg);
+#endif /* _TEE_MSGM_NTW_H_ */
diff --git a/drivers/marvell/security/marvelltee/src/inc/tee_perf.h b/drivers/marvell/security/marvelltee/src/inc/tee_perf.h
new file mode 100644
index 0000000..1505732
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/inc/tee_perf.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+#ifndef _TEE_PERF_COUNTER
+#define _TEE_PERF_COUNTER
+
+#ifdef TEE_PERF_MEASURE
+typedef struct _tee_perf_record {
+	char name[4];
+	unsigned int value;
+} tee_perf_record;
+
+typedef struct _tee_perf_desc {
+	unsigned int offset;
+	unsigned int total;
+} tee_perf_desc;
+
+extern void tee_perf_init(unsigned int *base);
+extern void tee_prepare_record_time(void);
+extern void tee_add_time_record_point(char name[4]);
+extern void tee_finish_record_time(void);
+#else
+#define tee_perf_init(x) do { } while (0)
+#define tee_prepare_record_time() do { } while (0)
+#define tee_add_time_record_point(x) do { } while (0)
+#define tee_finish_record_time() do {} while (0)
+#endif
+
+#endif /* _TEE_PERF_COUNTER */
diff --git a/drivers/marvell/security/marvelltee/src/main/marvelltee_application.h b/drivers/marvell/security/marvelltee/src/main/marvelltee_application.h
new file mode 100644
index 0000000..db1eeb0
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/main/marvelltee_application.h
@@ -0,0 +1,24 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+#ifndef _MARVELLTEE_APPLICATION_H_
+#define _MARVELLTEE_APPLICATION_H_
+
+#define MRVL_LOGIN_APPLICATION_DAEMON    (0x80000000)
+#define MRVL_LOGIN_APPLICATION_SS        (0x80000001)
+
+#endif /* _MARVELLTEE_APPLICATION_H_ */
diff --git a/drivers/marvell/security/marvelltee/src/main/marvelltee_call_tw.c b/drivers/marvell/security/marvelltee/src/main/marvelltee_call_tw.c
new file mode 100644
index 0000000..ff6e70b
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/main/marvelltee_call_tw.c
@@ -0,0 +1,32 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+
+#include "marvelltee_internal.h"
+void marvelltee_call_tw(tee_msg_head_t *tee_msg_head)
+{
+	marvelltee_add_node_to_req_list(&(tee_msg_head->node));
+
+	/* Wake up PT */
+	osa_release_sem(marvelltee_dev->pt_sem);
+	/* osa_wakeup_process(marvelltee_dev->proxy_thd); */
+
+	/* Wait for the mutex, PT will wake it up */
+	osa_wait_for_sem(tee_msg_head->comp, INFINITE);
+
+	osa_destroy_sem(tee_msg_head->comp);
+}
diff --git a/drivers/marvell/security/marvelltee/src/main/marvelltee_compat.c b/drivers/marvell/security/marvelltee/src/main/marvelltee_compat.c
new file mode 100644
index 0000000..786ddb9
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/main/marvelltee_compat.c
@@ -0,0 +1,679 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+
+#include "marvelltee_internal.h"
+
+#define IS_TYPE_NONE(_m)    (0x0 == (_m))
+#define IS_TYPE_VALUE(_m)   ((_m) >= 0x1 && (_m) <= 0x3)
+#define IS_TYPE_TMPREF(_m)  ((_m) >= 0x5 && (_m) <= 0x7)
+#define IS_TYPE_MEMREF(_m)  ((_m) >= 0xc && (_m) <= 0xf)
+
+#define CLEAN_HIGH_32BIT    (0xFFFFFFFF)
+#define _HIGH_MEM_TRSLATION(_a) ((((_a) >> 8) & 0x000000ff) | 0xffffff00)
+
+struct compat_teec_init_context_args {
+	compat_int_t name;
+	compat_u64 tee_ctx_ntw;
+	compat_uint_t ret;
+};
+
+struct compat_teec_final_context_args {
+	compat_u64 tee_ctx_ntw;
+	compat_uint_t ret;
+};
+
+struct compat_teec_map_shared_mem_args {
+	compat_u64 tee_ctx_ntw;
+	compat_int_t buffer;
+	compat_size_t size;
+	compat_uint_t flags;
+	compat_u64 tee_shm_ntw;
+	compat_uint_t ret;
+};
+
+struct compat_teec_unmap_shared_mem_args {
+	compat_int_t buffer;
+	compat_size_t size;
+	compat_uint_t flags;
+	compat_u64 tee_shm_ntw;
+	compat_uint_t ret;
+};
+
+struct compat_teec_temp_ref {
+	compat_int_t buffer;
+	compat_size_t size;
+};
+
+struct compat_teec_mem_ref {
+	compat_int_t parent;
+	compat_size_t size;
+	compat_size_t offset;
+};
+
+struct compat_teec_value {
+	compat_uint_t a;
+	compat_uint_t b;
+};
+
+union compat_teec_parameter {
+	struct compat_teec_temp_ref tmpref;
+	struct compat_teec_mem_ref memref;
+	struct compat_teec_value value;
+};
+
+struct compat_teec_open_ss_args {
+	compat_u64 tee_ctx_ntw;
+	compat_u64 tee_ss_ntw;
+	compat_int_t destination;
+	compat_uint_t connectionMethod;
+	compat_int_t connectionData;
+	compat_uint_t flags;
+	compat_uint_t paramTypes;
+	union compat_teec_parameter params[4];
+	compat_u64 tee_op_ntw;
+	compat_uint_t tee_op_ntw_for_cancel;
+	compat_uint_t returnOrigin;
+	compat_uint_t ret;
+};
+
+struct compat_teec_close_ss_args {
+	compat_u64 tee_ss_ntw;
+	compat_uint_t ret;
+};
+
+struct compat_teec_request_cancel_args {
+	compat_u64 tee_op_ntw;
+	compat_uint_t ret;
+};
+
+struct compat_teec_invoke_cmd_args {
+	compat_u64 tee_ss_ntw;
+	compat_uint_t cmd_ID;
+	compat_uint_t started;
+	compat_uint_t flags;
+	compat_uint_t paramTypes;
+	union compat_teec_parameter params[4];
+	compat_u64 tee_op_ntw;
+	compat_uint_t tee_op_ntw_for_cancel;
+	compat_uint_t returnOrigin;
+	compat_uint_t ret;
+};
+
+static int _marvelltee_compat_get_init_context_data(
+			struct compat_teec_init_context_args __user *data32,
+			teec_init_context_args __user *data)
+{
+	data->name = compat_ptr(data32->name);
+
+	return 0;
+}
+
+static int _marvelltee_compat_put_init_context_data(
+			struct compat_teec_init_context_args __user *data32,
+			teec_init_context_args __user *data)
+{
+	compat_uint_t u;
+	int err = 0;
+
+	data32->tee_ctx_ntw = (compat_u64)data->tee_ctx_ntw;
+
+	err |= get_user(u, &data->ret);
+	err |= put_user(u, &data32->ret);
+
+	return err;
+}
+
+static int _marvelltee_compat_get_final_context_data(
+			struct compat_teec_final_context_args __user *data32,
+			teec_final_context_args __user *data)
+{
+
+	data->tee_ctx_ntw = (tee_impl)data32->tee_ctx_ntw;
+
+	return 0;
+}
+
+static int _marvelltee_compat_put_final_context_data(
+			struct compat_teec_final_context_args __user *data32,
+			teec_final_context_args __user *data)
+{
+	compat_uint_t u;
+	int err = 0;
+
+	err |= get_user(u, &data->ret);
+	err |= put_user(u, &data32->ret);
+
+	return err;
+}
+
+static int _marvelltee_compat_get_map_shared_mem_data(
+	struct compat_teec_map_shared_mem_args __user *data32,
+	teec_map_shared_mem_args __user *data)
+{
+	compat_size_t s;
+	compat_uint_t u;
+	int err = 0;
+
+	data->tee_ctx_ntw = (tee_impl)data32->tee_ctx_ntw;
+	data->buffer = compat_ptr(data32->buffer);
+	err |= get_user(s, &data32->size);
+	err |= put_user(s, &data->size);
+	err |= get_user(u, &data32->flags);
+	err |= put_user(u, &data->flags);
+
+	if ((data->flags >> 16) == _HIGH_MEM_MAGIC) {
+		data->buffer = (void *) ((_HIGH_MEM_TRSLATION((unsigned long long)data->flags) << 32) |
+			(unsigned long long) data->buffer);
+	}
+
+	/* clean the flag */
+	data->flags = data->flags & 0x000000ff;
+
+	return err;
+}
+
+static int _marvelltee_compat_put_map_shared_mem_data(
+		struct compat_teec_map_shared_mem_args __user *data32,
+		teec_map_shared_mem_args __user *data)
+{
+	compat_uint_t u;
+	int err = 0;
+
+	data32->tee_shm_ntw = (compat_u64)data->tee_shm_ntw;
+	err |= get_user(u, &data->ret);
+	err |= put_user(u, &data32->ret);
+
+	return err;
+}
+
+static int _marvelltee_compat_get_unmap_shared_mem_data(
+	struct compat_teec_unmap_shared_mem_args __user *data32,
+	teec_unmap_shared_mem_args __user *data)
+{
+	compat_size_t s;
+	compat_uint_t u;
+	int err = 0;
+
+	data->buffer = compat_ptr(data32->buffer);
+	err |= get_user(s, &data32->size);
+	err |= put_user(s, &data->size);
+	err |= get_user(u, &data32->flags);
+	err |= put_user(u, &data->flags);
+	data->tee_shm_ntw = (tee_impl)data32->tee_shm_ntw;
+
+	return err;
+}
+
+static int _marvelltee_compat_put_unmap_shared_mem_data(
+	struct compat_teec_unmap_shared_mem_args __user *data32,
+	teec_unmap_shared_mem_args __user *data)
+{
+	compat_uint_t u;
+	int err = 0;
+
+	err |= get_user(u, &data->ret);
+	err |= put_user(u, &data32->ret);
+
+	return err;
+}
+static int _marvelltee_compat_get_open_ss_data(
+			struct compat_teec_open_ss_args __user *data32,
+			teec_open_ss_args __user *data)
+{
+	compat_uint_t u;
+	compat_size_t s;
+	int err = 0;
+	int j;
+	uint32_t value;
+
+	data->tee_ctx_ntw = (tee_impl)data32->tee_ctx_ntw;
+	data->destination = (TEEC_UUID *)compat_ptr(data32->destination);
+	err |= get_user(u, &data32->connectionMethod);
+	err |= put_user(u, &data->connectionMethod);
+	data->connectionData = compat_ptr(data32->connectionData);
+	err |= get_user(u, &data32->flags);
+	err |= put_user(u, &data->flags);
+	err |= get_user(u, &data32->paramTypes);
+	err |= put_user(u, &data->paramTypes);
+
+	for (j = 0; j < 4; j++) {
+		value = TEEC_PARAM_TYPE_GET(data->paramTypes, j);
+		if (IS_TYPE_NONE(value))
+			osa_memset(&(data->params[j]), 0, sizeof(TEEC_Parameter));
+		if (IS_TYPE_VALUE(value)) {
+			err |= get_user(u, &data32->params[j].value.a);
+			err |= put_user(u, &data->params[j].value.a);
+			err |= get_user(u, &data32->params[j].value.b);
+			err |= put_user(u, &data->params[j].value.b);
+		}
+		if (IS_TYPE_TMPREF(value)) {
+			data->params[j].tmpref.buffer =
+				compat_ptr(data32->params[j].tmpref.buffer);
+			err |= get_user(s, &(data32->params[j].tmpref.size));
+			err |= put_user(s, &(data->params[j].tmpref.size));
+		}
+		if (IS_TYPE_MEMREF(value)) {
+			data->params[j].memref.parent =
+				compat_ptr(data32->params[j].memref.parent);
+			err |= get_user(s, &(data32->params[j].memref.size));
+			err |= put_user(s, &(data->params[j].memref.size));
+			err |= get_user(s, &(data32->params[j].memref.offset));
+			err |= put_user(s, &(data->params[j].memref.offset));
+		}
+	}
+
+	data->tee_op_ntw_for_cancel = compat_ptr(data32->tee_op_ntw_for_cancel);
+
+	return err;
+}
+
+static int _marvelltee_compat_put_open_ss_data(
+			struct compat_teec_open_ss_args __user *data32,
+			teec_open_ss_args __user *data)
+{
+	compat_uint_t u;
+	compat_size_t s;
+	int err = 0;
+	int j;
+	uint32_t value;
+
+	data32->tee_ss_ntw = (compat_u64)data->tee_ss_ntw;
+
+	for (j = 0; j < 4; j++) {
+		value = TEEC_PARAM_TYPE_GET(data->paramTypes, j);
+
+		if (IS_TYPE_VALUE(value)) {
+			err |= get_user(u, &data->params[j].value.a);
+			err |= put_user(u, &data32->params[j].value.a);
+			err |= get_user(u, &data->params[j].value.b);
+			err |= put_user(u, &data32->params[j].value.b);
+		}
+		if (IS_TYPE_TMPREF(value)) {
+			/* buffer address should not be changed */
+			err |= get_user(s, &(data->params[j].tmpref.size));
+			err |= put_user(s, &(data32->params[j].tmpref.size));
+		}
+		if (IS_TYPE_MEMREF(value)) {
+			/* buffer address should not be changed */
+			err |= get_user(s, &(data->params[j].memref.size));
+			err |= put_user(s, &(data32->params[j].memref.size));
+			err |= get_user(s, &(data->params[j].memref.offset));
+			err |= put_user(s, &(data32->params[j].memref.offset));
+		}
+	}
+
+	data32->tee_op_ntw = (compat_u64)data->tee_op_ntw;
+
+	err |= get_user(u, &data->returnOrigin);
+	err |= put_user(u, &data32->returnOrigin);
+	err |= get_user(u, &data->ret);
+	err |= put_user(u, &data32->ret);
+
+	return err;
+}
+
+static int _marvelltee_compat_get_close_ss_data(
+			struct compat_teec_close_ss_args __user *data32,
+			teec_close_ss_args __user *data)
+{
+	data->tee_ss_ntw = (tee_impl)(data32->tee_ss_ntw);
+
+	return 0;
+}
+
+static int _marvelltee_compat_put_close_ss_data(
+			struct compat_teec_close_ss_args __user *data32,
+			teec_close_ss_args __user *data)
+{
+	compat_uint_t u;
+	int err = 0;
+
+	err |= get_user(u, &data->ret);
+	err |= put_user(u, &data32->ret);
+
+	return err;
+}
+
+static int _marvelltee_compat_get_request_cancel_data(
+			struct compat_teec_request_cancel_args __user *data32,
+			teec_request_cancel_args __user *data)
+{
+	data->tee_op_ntw = (tee_impl)(data32->tee_op_ntw);
+
+	return 0;
+}
+
+static int _marvelltee_compat_put_request_cancel_data(
+			struct compat_teec_request_cancel_args __user *data32,
+			teec_request_cancel_args __user *data)
+{
+	compat_uint_t u;
+	int err = 0;
+
+	err |= get_user(u, &data->ret);
+	err |= put_user(u, &data32->ret);
+
+	return err;
+}
+
+static int _marvelltee_compat_get_invoke_cmd_data(
+			struct compat_teec_invoke_cmd_args __user *data32,
+			teec_invoke_cmd_args __user *data)
+{
+	compat_uint_t u;
+	compat_size_t s;
+	int err = 0;
+	int j;
+	uint32_t value;
+
+	data->tee_ss_ntw = (tee_impl)(data32->tee_ss_ntw);
+	err |= get_user(u, &data32->cmd_ID);
+	err |= put_user(u, &data->cmd_ID);
+	err |= get_user(u, &data32->started);
+	err |= put_user(u, &data->started);
+	err |= get_user(u, &data32->flags);
+	err |= put_user(u, &data->flags);
+	err |= get_user(u, &data32->paramTypes);
+	err |= put_user(u, &data->paramTypes);
+
+	for (j = 0; j < 4; j++) {
+		value = TEEC_PARAM_TYPE_GET(data->paramTypes, j);
+		if (IS_TYPE_NONE(value))
+			osa_memset(&(data->params[j]), 0, sizeof(TEEC_Parameter));
+		if (IS_TYPE_VALUE(value)) {
+			err |= get_user(u, &data32->params[j].value.a);
+			err |= put_user(u, &data->params[j].value.a);
+			err |= get_user(u, &data32->params[j].value.b);
+			err |= put_user(u, &data->params[j].value.b);
+		}
+		if (IS_TYPE_TMPREF(value)) {
+			data->params[j].tmpref.buffer =
+				compat_ptr(data32->params[j].tmpref.buffer);
+			err |= get_user(s, &(data32->params[j].tmpref.size));
+			err |= put_user(s, &(data->params[j].tmpref.size));
+		}
+		if (IS_TYPE_MEMREF(value)) {
+			data->params[j].memref.parent =
+				compat_ptr(data32->params[j].memref.parent);
+			err |= get_user(s, &(data32->params[j].memref.size));
+			err |= put_user(s, &(data->params[j].memref.size));
+			err |= get_user(s, &(data32->params[j].memref.offset));
+			err |= put_user(s, &(data->params[j].memref.offset));
+		}
+	}
+
+	data->tee_op_ntw_for_cancel = compat_ptr(data32->tee_op_ntw_for_cancel);
+
+	return err;
+}
+
+static int _marvelltee_compat_put_invoke_cmd_data(
+			struct compat_teec_invoke_cmd_args __user *data32,
+			teec_invoke_cmd_args __user *data)
+{
+	compat_uint_t u;
+	compat_size_t s;
+	int err = 0;
+	int j;
+	uint32_t value;
+
+	for (j = 0; j < 4; j++) {
+		value = TEEC_PARAM_TYPE_GET(data->paramTypes, j);
+
+		if (IS_TYPE_VALUE(value)) {
+			err |= get_user(u, &data->params[j].value.a);
+			err |= put_user(u, &data32->params[j].value.a);
+			err |= get_user(u, &data->params[j].value.b);
+			err |= put_user(u, &data32->params[j].value.b);
+		}
+		if (IS_TYPE_TMPREF(value)) {
+			/* buffer address should not be changed */
+			err |= get_user(s, &(data->params[j].tmpref.size));
+			err |= put_user(s, &(data32->params[j].tmpref.size));
+		}
+		if (IS_TYPE_MEMREF(value)) {
+			/* buffer address should not be changed */
+			err |= get_user(s, &(data->params[j].memref.size));
+			err |= put_user(s, &(data32->params[j].memref.size));
+			err |= get_user(s, &(data->params[j].memref.offset));
+			err |= put_user(s, &(data32->params[j].memref.offset));
+		}
+	}
+
+	data32->tee_op_ntw = (compat_u64)data->tee_op_ntw;
+
+	err |= get_user(u, &data->returnOrigin);
+	err |= put_user(u, &data32->returnOrigin);
+	err |= get_user(u, &data->ret);
+	err |= put_user(u, &data32->ret);
+
+	return err;
+}
+
+long marvelltee_compat_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	int ret = 0;
+
+	if (!filp->f_op || !filp->f_op->unlocked_ioctl)
+		return -ENOTTY;
+
+	OSA_ASSERT(arg);
+
+	switch (cmd) {
+	case TEEC_INIT_CONTEXT:
+	{
+		struct compat_teec_init_context_args __user *data32;
+		teec_init_context_args __user *data;
+
+		data32 = compat_ptr(arg);
+		data = compat_alloc_user_space(sizeof(*data));
+		if (data == NULL)
+			return -EFAULT;
+
+		ret = _marvelltee_compat_get_init_context_data(data32, data);
+		if (ret)
+			return ret;
+
+		ret = filp->f_op->unlocked_ioctl(filp, cmd,
+					(unsigned long)data);
+		if (ret)
+			return ret;
+
+		ret = _marvelltee_compat_put_init_context_data(data32, data);
+		if (ret)
+			return ret;
+	}
+	break;
+	case TEEC_FINAL_CONTEXT:
+	{
+		struct compat_teec_final_context_args __user *data32;
+		teec_final_context_args __user *data;
+
+		data32 = compat_ptr(arg);
+		data = compat_alloc_user_space(sizeof(*data));
+		if (data == NULL)
+			return -EFAULT;
+
+		ret = _marvelltee_compat_get_final_context_data(data32, data);
+		if (ret)
+			return ret;
+
+		ret = filp->f_op->unlocked_ioctl(filp, cmd,
+					(unsigned long)data);
+		if (ret)
+			return ret;
+
+		ret = _marvelltee_compat_put_final_context_data(data32, data);
+		if (ret)
+			return ret;
+	}
+	break;
+	case TEEC_REGIST_SHARED_MEM:
+	/* fall through */;
+	case TEEC_ALLOC_SHARED_MEM:
+	{
+		struct compat_teec_map_shared_mem_args __user *data32;
+		teec_map_shared_mem_args __user *data;
+
+		data32 = compat_ptr(arg);
+		data = compat_alloc_user_space(sizeof(*data));
+		if (data == NULL)
+			return -EFAULT;
+
+		ret = _marvelltee_compat_get_map_shared_mem_data(data32, data);
+		if (ret)
+			return ret;
+
+		ret = filp->f_op->unlocked_ioctl(filp, cmd,
+					(unsigned long)data);
+		if (ret)
+			return ret;
+
+		ret = _marvelltee_compat_put_map_shared_mem_data(data32, data);
+		if (ret)
+			return ret;
+	}
+	break;
+	case TEEC_RELEASE_SHARED_MEM:
+	{
+		struct compat_teec_unmap_shared_mem_args __user *data32;
+		teec_unmap_shared_mem_args __user *data;
+
+		data32 = compat_ptr(arg);
+		data = compat_alloc_user_space(sizeof(*data));
+		if (data == NULL)
+			return -EFAULT;
+
+		ret = _marvelltee_compat_get_unmap_shared_mem_data(data32, data);
+		if (ret)
+			return ret;
+
+		ret = filp->f_op->unlocked_ioctl(filp, cmd,
+					(unsigned long)data);
+		if (ret)
+			return ret;
+
+		ret = _marvelltee_compat_put_unmap_shared_mem_data(data32, data);
+		if (ret)
+			return ret;
+	}
+	break;
+	case TEEC_OPEN_SS:
+	{
+		struct compat_teec_open_ss_args __user *data32;
+		teec_open_ss_args __user *data;
+
+		data32 = compat_ptr(arg);
+		data = compat_alloc_user_space(sizeof(*data));
+		if (data == NULL)
+			return -EFAULT;
+
+		ret = _marvelltee_compat_get_open_ss_data(data32, data);
+		if (ret)
+			return ret;
+
+		ret = filp->f_op->unlocked_ioctl(filp, cmd,
+					(unsigned long)data);
+		if (ret)
+			return ret;
+
+		ret = _marvelltee_compat_put_open_ss_data(data32, data);
+		if (ret)
+			return ret;
+	}
+	break;
+	case TEEC_CLOSE_SS:
+	{
+		struct compat_teec_close_ss_args __user *data32;
+		teec_close_ss_args __user *data;
+
+		data32 = compat_ptr(arg);
+		data = compat_alloc_user_space(sizeof(*data));
+		if (data == NULL)
+			return -EFAULT;
+
+		ret = _marvelltee_compat_get_close_ss_data(data32, data);
+		if (ret)
+			return ret;
+
+		ret = filp->f_op->unlocked_ioctl(filp, cmd,
+					(unsigned long)data);
+		if (ret)
+			return ret;
+
+		ret = _marvelltee_compat_put_close_ss_data(data32, data);
+		if (ret)
+			return ret;
+	}
+	break;
+	case TEEC_INVOKE_CMD:
+	{
+		struct compat_teec_invoke_cmd_args __user *data32;
+		teec_invoke_cmd_args __user *data;
+
+		data32 = compat_ptr(arg);
+		data = compat_alloc_user_space(sizeof(*data));
+		if (data == NULL)
+			return -EFAULT;
+
+		ret = _marvelltee_compat_get_invoke_cmd_data(data32, data);
+		if (ret)
+			return ret;
+
+		ret = filp->f_op->unlocked_ioctl(filp, cmd,
+					(unsigned long)data);
+		if (ret)
+			return ret;
+
+		ret = _marvelltee_compat_put_invoke_cmd_data(data32, data);
+		if (ret)
+			return ret;
+	}
+	break;
+	case TEEC_REQUEST_CANCEL:
+	{
+		struct compat_teec_request_cancel_args __user *data32;
+		teec_request_cancel_args __user *data;
+
+		data32 = compat_ptr(arg);
+		data = compat_alloc_user_space(sizeof(*data));
+		if (data == NULL)
+			return -EFAULT;
+
+		ret = _marvelltee_compat_get_request_cancel_data(data32, data);
+		if (ret)
+			return ret;
+
+		ret = filp->f_op->unlocked_ioctl(filp, cmd,
+					(unsigned long)data);
+		if (ret)
+			return ret;
+
+		ret = _marvelltee_compat_put_request_cancel_data(data32, data);
+		if (ret)
+			return ret;
+	}
+	break;
+	default:
+		MARVELLTEE_DBG("MARVELLTEE COMPAT IOCTL invald command %x\n", cmd);
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
diff --git a/drivers/marvell/security/marvelltee/src/main/marvelltee_internal.h b/drivers/marvell/security/marvelltee/src/main/marvelltee_internal.h
new file mode 100644
index 0000000..3d60ccd
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/main/marvelltee_internal.h
@@ -0,0 +1,183 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+
+#ifndef _MARVELLTEE_INTERNAL_H_
+#define _MARVELLTEE_INTERNAL_H_
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/ioctl.h>
+#include <linux/cdev.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+#include <linux/pagemap.h>
+#include <linux/mman.h>
+#include <linux/mm.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/kthread.h>
+#include <linux/pm_qos.h>
+#include <linux/irqflags.h>
+#include <linux/cred.h>
+#include <linux/delay.h>
+#include <linux/irq.h>
+#include <linux/uaccess.h>
+#include <linux/io.h>
+#include <linux/atomic.h>
+#include <linux/compat.h>
+#include <linux/uidgid.h>
+#include <linux/sched.h>
+
+#include "tee_mrvl_imp.h"
+#include "tee_client_api.h"
+#include "marvelltee_ioctl.h"
+#include "osa.h"
+#include "tee_msgm_ntw.h"
+#include "tee_cm.h"
+#include "tee_memm.h"
+#include "marvelltee_application.h"
+#include "tee_perf.h"
+
+#include "teec_cb_local.h"
+#include "teec_cb.h"
+#include "marvelltee_list.h"
+
+/*
+ * Trustzone driver struct
+ */
+#define DEVICE_NAME         "marvelltee"
+#define DEVICE_NAME_SIZE    4
+#define _HIGH_MEM_MAGIC     0x4558
+
+typedef struct {
+	struct cdev cdev;
+	struct task_struct *proxy_thd;
+	struct class *_marvelltee_class;
+
+	osa_list_t req_list;
+	osa_mutex_t req_mutex;
+
+	osa_sem_t pt_sem;
+
+	osa_list_t pid_list;
+	osa_mutex_t pid_mutex;
+
+	struct pm_qos_request marvelltee_lpm_cons;
+	osa_sem_t pm_lock;
+	int marvelltee_lpm;
+
+	teec_cb_handle_t time_cb_h;
+} marvelltee_dev_t;
+
+extern marvelltee_dev_t *marvelltee_dev;
+
+typedef struct _marvelltee_ctx_node_t {
+	uint8_t magic[4];
+	tee_impl tee_ctx_ntw;
+	osa_list_t node;
+	osa_list_t shm_list;
+	osa_list_t ss_list;
+} marvelltee_ctx_node_t;
+
+typedef struct _marvelltee_shm_node_t {
+	uint8_t magic[4];
+	tee_impl tee_ctx_ntw;
+	tee_impl tee_shm_ntw;
+	osa_list_t node;
+} marvelltee_shm_node_t;
+
+typedef struct _marvelltee_ss_node_t {
+	uint8_t magic[4];
+	tee_impl tee_ctx_ntw;
+	tee_impl tee_ss_ntw;
+	osa_list_t node;
+} marvelltee_ss_node_t;
+
+extern TEEC_Result _teec_initialize_context(const char *name,
+					    tee_impl *tee_ctx_ntw);
+extern TEEC_Result _teec_final_context(tee_impl tee_ctx_ntw);
+extern TEEC_Result _teec_map_shared_mem(teec_map_shared_mem_args
+					teec_map_shared_mem,
+					tee_impl *tee_shm_ntw);
+extern TEEC_Result _teec_unmap_shared_mem(teec_unmap_shared_mem_args
+					  teec_unmap_shared_mem,
+					  tee_impl tee_shm_ntw);
+extern TEEC_Result _teec_open_session(tee_impl tee_ctx_ntw,
+				      tee_impl *tee_ss_ntw,
+				      const TEEC_UUID *destination,
+				      uint32_t connectionMethod,
+				      const void *connectionData,
+				      uint32_t flags, uint32_t paramTypes,
+				      TEEC_Parameter(*params)[4],
+				      tee_impl *tee_op_ntw,
+				      tee_impl tee_op_ntw_for_cancel,
+				      uint32_t *returnOrigin,
+				      unsigned long arg,
+				      teec_open_ss_args open_ss_args);
+extern TEEC_Result _teec_close_session(tee_impl tee_ss_ntw);
+extern TEEC_Result _teec_invoke_command(tee_impl tee_ss_ntw,
+					uint32_t cmd_ID,
+					uint32_t started,
+					uint32_t flags,
+					uint32_t paramTypes,
+					TEEC_Parameter(*params)[4],
+					tee_impl *tee_op_ntw,
+					tee_impl tee_op_ntw_for_cancel,
+					uint32_t *returnOrigin,
+					unsigned long arg,
+					teec_invoke_cmd_args invoke_cmd_args);
+extern TEEC_Result _teec_request_cancellation(tee_impl tee_op_ntw);
+
+extern void marvelltee_add_node_to_req_list(osa_list_t *list);
+extern bool marvelltee_chk_node_on_req_list(osa_list_t *list);
+extern bool marvelltee_del_node_from_req_list(osa_list_t *list);
+
+/* get request node from request list */
+extern bool marvelltee_get_first_req(tee_msg_head_t **tee_msg_head);
+
+/* check request list and run list are empty or not */
+extern bool marvelltee_have_req(void);
+extern uint32_t marvelltee_get_req_num_in_list(void);
+
+extern int marvelltee_proxy_thread_init(marvelltee_dev_t *dev);
+extern void marvelltee_proxy_thread_cleanup(marvelltee_dev_t *dev);
+
+extern int32_t marvelltee_init_core(marvelltee_dev_t *dev);
+extern void marvelltee_cleanup_core(marvelltee_dev_t *dev);
+
+extern void marvelltee_call_tw(tee_msg_head_t *tee_msg_head);
+extern long marvelltee_compat_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);
+
+#ifdef CONFIG_64BIT
+typedef unsigned long long marvelltee_size_t;
+#else
+typedef unsigned long marvelltee_size_t;
+#endif
+
+#ifdef MARVELLTEE_DEBUG
+#define MARVELLTEE_DBG(fmt, args...) \
+			osa_dbg_print(DBG_INFO, DEVICE_NAME ": " fmt, ##args)
+#else
+#define MARVELLTEE_DBG(fmt, args...)
+#endif
+
+#define osa_memset      memset
+#define osa_memcmp      memcmp
+#define osa_memcpy      memcpy
+
+#endif /* _MARVELLTEE_INTERNAL_H_ */
diff --git a/drivers/marvell/security/marvelltee/src/main/marvelltee_list.h b/drivers/marvell/security/marvelltee/src/main/marvelltee_list.h
new file mode 100644
index 0000000..1b3825c
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/main/marvelltee_list.h
@@ -0,0 +1,31 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+#ifndef _MARVELLTEE_LIST_H_
+#define _MARVELLTEE_LIST_H_
+
+#define FIND_PID_IN_PID_LIST	(0xAA)
+
+typedef struct _marvelltee_pid_list_t {
+	osa_list_t node;
+	osa_list_t ctx_list;
+	uint32_t pid;
+	uint32_t count; /* number of context in the node*/
+	struct rlimit mlock_rlim_orig;
+} marvelltee_pid_list_t;
+
+#endif /* _MARVELLTEE_LIST_H_ */
diff --git a/drivers/marvell/security/marvelltee/src/main/marvelltee_main.c b/drivers/marvell/security/marvelltee/src/main/marvelltee_main.c
new file mode 100644
index 0000000..753d130
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/main/marvelltee_main.c
@@ -0,0 +1,871 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+
+#include <uapi/linux/resource.h>
+#include <asm/pgtable.h>
+#include "marvelltee_internal.h"
+
+MODULE_LICENSE("GPL");
+
+/*
+ * Parameters which can be set at load time.
+ */
+
+#ifdef TEE_RES_CFG_16M
+#define MARVELLTEE_VERSION    "Marvell TEE Drvier Version 1.1.14 16MB"
+#elif defined(TEE_RES_CFG_24M)
+#define MARVELLTEE_VERSION    "Marvell TEE Drvier Version 1.1.14 24MB"
+#else
+#define MARVELLTEE_VERSION    "Marvell TEE Drvier 1.1.14"
+#endif
+#define MARVELLTEE_DRV_NAME   "marvelltee"
+
+int marvelltee_major;
+int marvelltee_minor;
+
+module_param(marvelltee_major, int, S_IRUGO);
+module_param(marvelltee_minor, int, S_IRUGO);
+
+/* driver data struct */
+marvelltee_dev_t *marvelltee_dev;
+
+#define OP_PARAM_NUM	4
+
+#define IS_MAGIC_VALID(_n) \
+	(('T' == ((uint8_t *)_n)[0]) && \
+	('Z' == ((uint8_t *)_n)[1]) && \
+	('D' == ((uint8_t *)_n)[2]) && \
+	('D' == ((uint8_t *)_n)[3]))
+#define CLEANUP_MAGIC(_n) \
+	do {	\
+		((uint8_t *)_n)[0] = '\0';	\
+		((uint8_t *)_n)[1] = '\0';	\
+		((uint8_t *)_n)[2] = '\0';	\
+		((uint8_t *)_n)[3] = '\0';	\
+	} while (0)
+
+static void _marvelltee_free_session(marvelltee_ctx_node_t *marvelltee_ctx_node)
+{
+	TEEC_Session *teec_session;
+	marvelltee_ss_node_t *marvelltee_ss_node;
+	osa_list_t *entry, *next;
+
+	osa_list_iterate_safe(&(marvelltee_ctx_node->ss_list), entry, next) {
+		OSA_LIST_ENTRY(entry, marvelltee_ss_node_t, node, marvelltee_ss_node);
+		if (!(IS_MAGIC_VALID(marvelltee_ss_node->magic)))
+			OSA_ASSERT(0);
+		CLEANUP_MAGIC(marvelltee_ss_node->magic);
+
+		osa_list_del(&(marvelltee_ss_node->node));
+
+		teec_session = (TEEC_Session *)(marvelltee_ss_node->tee_ss_ntw);
+		TEEC_CloseSession(teec_session);
+
+		osa_kmem_free(marvelltee_ss_node);
+		osa_kmem_free(teec_session);
+	}
+}
+
+static void _marvelltee_free_shared_mem(marvelltee_ctx_node_t *marvelltee_ctx_node)
+{
+	TEEC_SharedMemory *teec_shared_mem;
+	marvelltee_shm_node_t *marvelltee_shm_node;
+	osa_list_t *entry, *next;
+
+	osa_list_iterate_safe(&(marvelltee_ctx_node->shm_list), entry, next) {
+		OSA_LIST_ENTRY(entry, marvelltee_shm_node_t, node, marvelltee_shm_node);
+		if (!(IS_MAGIC_VALID(marvelltee_shm_node->magic)))
+			OSA_ASSERT(0);
+		CLEANUP_MAGIC(marvelltee_shm_node->magic);
+
+		osa_list_del(&(marvelltee_shm_node->node));
+
+		teec_shared_mem = (TEEC_SharedMemory *)(marvelltee_shm_node->tee_shm_ntw);
+		TEEC_ReleaseSharedMemory(teec_shared_mem);
+
+		osa_kmem_free(marvelltee_shm_node);
+		osa_kmem_free(teec_shared_mem);
+	}
+}
+
+static void _marvelltee_free_context(marvelltee_ctx_node_t *marvelltee_ctx_node)
+{
+	TEEC_Context *teec_context;
+
+	CLEANUP_MAGIC(marvelltee_ctx_node->magic);
+
+	osa_list_del(&(marvelltee_ctx_node->node));
+
+	teec_context = (TEEC_Context *)(marvelltee_ctx_node->tee_ctx_ntw);
+	TEEC_FinalizeContext(teec_context);
+
+	osa_kmem_free(marvelltee_ctx_node);
+	osa_kmem_free(teec_context);
+}
+
+static int marvelltee_open(struct inode *inode, struct file *filp)
+{
+	marvelltee_pid_list_t *marvelltee_pid;
+	marvelltee_pid_list_t *tmp_pid;
+	osa_list_t *entry;
+	uint32_t flag = 0;
+	pid_t pid;
+
+	pid = current->tgid;
+
+	osa_wait_for_sem(marvelltee_dev->pid_mutex, INFINITE);
+	osa_list_iterate(&(marvelltee_dev->pid_list), entry) {
+		OSA_LIST_ENTRY(entry, marvelltee_pid_list_t, node, tmp_pid);
+		if (pid == tmp_pid->pid) {
+			flag = FIND_PID_IN_PID_LIST;
+			tmp_pid->count++;
+			break;
+		}
+	}
+
+	if (flag != FIND_PID_IN_PID_LIST) {
+		struct rlimit rlim_inf = { RLIM_INFINITY, RLIM_INFINITY };
+		ulong_t flags;
+		/* marvelltee_pid will be released in marvelltee_close */
+		marvelltee_pid = osa_kmem_alloc(sizeof(marvelltee_pid_list_t));
+		OSA_ASSERT(marvelltee_pid != NULL);
+
+		osa_list_init_head(&(marvelltee_pid->ctx_list));
+		marvelltee_pid->pid = pid;
+		marvelltee_pid->count = 1;
+		/*
+		 * to make sure current->signal is valid,
+		 * tasklist_lock should be held.
+		 * since tasklist_lock is NOT exported to kernel modules,
+		 * we have to save/restore irq to make sure current->signal is valid.
+		 */
+		/* no tasklist_lock exported: read_lock(&tasklist_lock); */
+		task_lock(current->group_leader);
+		local_irq_save(flags);
+		if (current->signal) {
+			/* save the previous rlim[RLIMIT_MEMLOCK] */
+			marvelltee_pid->mlock_rlim_orig = current->signal->rlim[RLIMIT_MEMLOCK];
+			/* make the current task's rlim[RLIMIT_MEMLOCK] infinite */
+			current->signal->rlim[RLIMIT_MEMLOCK] = rlim_inf;
+		}
+		local_irq_restore(flags);
+		task_unlock(current->group_leader);
+		/* no tasklist_lock exported: read_unlock(&tasklist_lock); */
+		osa_list_add(&(marvelltee_pid->node), &(marvelltee_dev->pid_list));
+	}
+
+	osa_release_sem(marvelltee_dev->pid_mutex);
+
+	return 0;
+}
+
+static int marvelltee_close(struct inode *inode, struct file *filp)
+{
+	marvelltee_pid_list_t *marvelltee_pid = NULL;
+	osa_list_t *entry, *next;
+	uint32_t flag;
+	pid_t pid;
+
+	pid = current->tgid;
+
+	osa_wait_for_sem(marvelltee_dev->pid_mutex, INFINITE);
+	osa_list_iterate(&(marvelltee_dev->pid_list), entry) {
+		OSA_LIST_ENTRY(entry, marvelltee_pid_list_t, node, marvelltee_pid);
+		if (pid == marvelltee_pid->pid) {
+			flag = FIND_PID_IN_PID_LIST;
+			if (marvelltee_pid->count > 0)
+				marvelltee_pid->count--;
+			break;
+		}
+	}
+
+	if ((flag == FIND_PID_IN_PID_LIST) &&
+		(marvelltee_pid->count == 0)) {
+		marvelltee_ctx_node_t *marvelltee_ctx_node;
+		ulong_t flags;
+
+		osa_list_iterate_safe(&(marvelltee_pid->ctx_list), entry, next) {
+			OSA_LIST_ENTRY(entry, marvelltee_ctx_node_t, node, marvelltee_ctx_node);
+			if (!(IS_MAGIC_VALID(marvelltee_ctx_node->magic)))
+				OSA_ASSERT(0);
+			_marvelltee_free_session(marvelltee_ctx_node);
+			_marvelltee_free_shared_mem(marvelltee_ctx_node);
+			_marvelltee_free_context(marvelltee_ctx_node);
+		}
+		/* no tasklist_lock exported: read_lock(&tasklist_lock); */
+		task_lock(current->group_leader);
+		local_irq_save(flags);
+		if (current->signal) {
+			/* restore the current task's rlim[RLIMIT_MEMLOCK] */
+			current->signal->rlim[RLIMIT_MEMLOCK] = marvelltee_pid->mlock_rlim_orig;
+		}
+		local_irq_restore(flags);
+		task_unlock(current->group_leader);
+		/* no tasklist_lock exported: read_unlock(&tasklist_lock); */
+		osa_list_del(&(marvelltee_pid->node));
+		osa_kmem_free(marvelltee_pid);
+	}
+
+	osa_release_sem(marvelltee_dev->pid_mutex);
+
+	return 0;
+}
+
+static long marvelltee_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	int ret = 0;
+	TEEC_Result result;
+
+	OSA_ASSERT(arg);
+
+	switch (cmd) {
+	case TEEC_INIT_CONTEXT:
+	{
+		teec_init_context_args teec_init_context;
+
+		if (copy_from_user
+			(&teec_init_context, (void __user *)arg,
+			sizeof(teec_init_context_args))) {
+			return -EFAULT;
+		}
+
+		result =
+			_teec_initialize_context(teec_init_context.name,
+						&(teec_init_context.
+						tee_ctx_ntw));
+		teec_init_context.ret = result;
+
+		if (copy_to_user
+			((void __user *)arg, &teec_init_context,
+			sizeof(teec_init_context_args))) {
+			return -EFAULT;
+		}
+	}
+	break;
+	case TEEC_FINAL_CONTEXT:
+	{
+		teec_final_context_args teec_final_context;
+
+		if (copy_from_user
+			(&teec_final_context, (void __user *)arg,
+			sizeof(teec_final_context_args))) {
+			return -EFAULT;
+		}
+
+		OSA_ASSERT(teec_final_context.tee_ctx_ntw);
+
+		result =
+			_teec_final_context(teec_final_context.tee_ctx_ntw);
+		teec_final_context.ret = result;
+
+		if (copy_to_user
+			((void __user *)arg, &teec_final_context,
+			sizeof(teec_final_context_args))) {
+			return -EFAULT;
+		}
+	}
+	break;
+	case TEEC_REGIST_SHARED_MEM:
+	case TEEC_ALLOC_SHARED_MEM:
+	{
+		teec_map_shared_mem_args teec_map_shared_mem;
+		void *buf_local_virt;
+		tee_memm_ss_t memm_handle;
+
+		if (copy_from_user
+			(&teec_map_shared_mem, (void __user *)arg,
+			sizeof(teec_map_shared_mem_args))) {
+			return -EFAULT;
+		}
+
+		if ((((marvelltee_size_t) teec_map_shared_mem.buffer) < VMALLOC_START) &&
+			(((marvelltee_size_t) teec_map_shared_mem.buffer) < MODULES_VADDR) &&
+			(((marvelltee_size_t) teec_map_shared_mem.buffer != 0) &&
+			 (teec_map_shared_mem.size != 0))) {
+			memm_handle = tee_memm_create_ss();
+			tee_memm_get_user_mem(memm_handle,
+				teec_map_shared_mem.buffer,
+				teec_map_shared_mem.size,
+				&buf_local_virt);
+			if (!buf_local_virt) {
+				teec_map_shared_mem.ret = TEEC_ERROR_GENERIC;
+				if (copy_to_user((void __user *)arg, &teec_map_shared_mem,
+					sizeof(teec_map_shared_mem_args))) {
+					return -EFAULT;
+				}
+				MARVELLTEE_DBG("Error in tee_memm_get_user_mem\n");
+				return -EFAULT;
+			}
+			tee_memm_destroy_ss(memm_handle);
+			teec_map_shared_mem.buffer = buf_local_virt;
+		}
+
+		OSA_ASSERT(teec_map_shared_mem.tee_ctx_ntw);
+		result =
+			_teec_map_shared_mem(teec_map_shared_mem,
+					&(teec_map_shared_mem.
+					tee_shm_ntw));
+		teec_map_shared_mem.ret = result;
+
+		if (copy_to_user
+			((void __user *)arg, &teec_map_shared_mem,
+			sizeof(teec_map_shared_mem_args))) {
+			return -EFAULT;
+		}
+	}
+	break;
+	case TEEC_RELEASE_SHARED_MEM:
+	{
+		teec_unmap_shared_mem_args teec_unmap_shared_mem;
+
+		if (copy_from_user
+			(&teec_unmap_shared_mem, (void __user *)arg,
+			sizeof(teec_unmap_shared_mem_args))) {
+			return -EFAULT;
+		}
+
+		OSA_ASSERT(teec_unmap_shared_mem.tee_shm_ntw);
+		result =
+			_teec_unmap_shared_mem(teec_unmap_shared_mem,
+					teec_unmap_shared_mem.
+					tee_shm_ntw);
+		teec_unmap_shared_mem.ret = result;
+
+		if (copy_to_user
+			((void __user *)arg, &teec_unmap_shared_mem,
+			sizeof(teec_unmap_shared_mem_args))) {
+			return -EFAULT;
+		}
+	}
+	break;
+	case TEEC_OPEN_SS:
+	{
+		uint32_t param_types, tmp_types;
+		uint32_t i;
+		uint8_t *tmpref_buf[OP_PARAM_NUM];
+		void *save_buf_addr[OP_PARAM_NUM];
+
+		teec_open_ss_args teec_open_ss;
+		TEEC_UUID destination;
+		uint32_t _connectionData;
+		void *connectionData;
+
+		for (i = 0; i < OP_PARAM_NUM; i++) {
+			tmpref_buf[i] = NULL;
+			save_buf_addr[i] = NULL;
+		}
+
+		if (copy_from_user
+			(&teec_open_ss, (void __user *)arg,
+			sizeof(teec_open_ss_args))) {
+			return -EFAULT;
+		}
+
+		if (teec_open_ss.destination) {
+			if (copy_from_user
+				(&destination,
+				(void __user *)teec_open_ss.destination,
+				sizeof(TEEC_UUID))) {
+				return -EFAULT;
+			}
+		}
+
+		if (teec_open_ss.connectionData) {
+			if (copy_from_user
+				(&_connectionData,
+				(void __user *)teec_open_ss.connectionData,
+				sizeof(uint32_t))) {
+				return -EFAULT;
+			}
+			connectionData = (void *)&_connectionData;
+		} else {
+			connectionData = NULL;
+		}
+
+		if (teec_open_ss.flags == OPERATION_EXIST) {
+			param_types = teec_open_ss.paramTypes;
+			for (i = 0; i < OP_PARAM_NUM; i++) {
+				tmp_types =
+					TEEC_PARAM_TYPE_GET(param_types, i);
+				switch (tmp_types) {
+				case TEEC_MEMREF_TEMP_INPUT:
+				case TEEC_MEMREF_TEMP_OUTPUT:
+				case TEEC_MEMREF_TEMP_INOUT:
+				{
+					if (teec_open_ss.params[i]
+						.tmpref.buffer != NULL) {
+						tmpref_buf[i] = memdup_user((void __user *)
+							(teec_open_ss.params[i].tmpref.buffer),
+							teec_open_ss.params[i].tmpref.size);
+						if (tmpref_buf[i] == NULL) {
+							MARVELLTEE_DBG
+							("%s(%d): Failed to allocate buffer\n",
+							__func__,
+							__LINE__);
+							return -ENOMEM;
+						}
+						save_buf_addr[i] =
+							teec_open_ss.params[i].tmpref.buffer;
+						teec_open_ss.params[i].tmpref.buffer =
+							tmpref_buf[i];
+					}
+				}
+				break;
+				case TEEC_MEMREF_WHOLE:
+				case TEEC_MEMREF_PARTIAL_INPUT:
+				case TEEC_MEMREF_PARTIAL_OUTPUT:
+				case TEEC_MEMREF_PARTIAL_INOUT:
+				{
+					TEEC_MRVL_SharedMemory *teec_mrvl_shared_mem;
+					tee_impl impl;
+
+					if (copy_from_user(&impl,
+						(void __user *)teec_open_ss.params[i].memref.parent,
+						sizeof(tee_impl))) {
+						return -EFAULT;
+					}
+					save_buf_addr[i] = impl;
+					teec_mrvl_shared_mem =
+						(TEEC_MRVL_SharedMemory *)(save_buf_addr[i]);
+					teec_open_ss.params[i].memref.parent =
+						container_of(teec_mrvl_shared_mem,
+						TEEC_SharedMemory,
+						imp);
+				}
+				break;
+				default:
+					break;
+				}
+			}
+		}
+
+		OSA_ASSERT(teec_open_ss.tee_ctx_ntw);
+
+		result = _teec_open_session(
+						teec_open_ss.tee_ctx_ntw,
+						&(teec_open_ss.tee_ss_ntw),
+						(const TEEC_UUID
+						*)(&destination),
+						teec_open_ss.connectionMethod,
+						connectionData,
+						teec_open_ss.flags,
+						teec_open_ss.paramTypes,
+						&(teec_open_ss.params),
+						&(teec_open_ss.tee_op_ntw),
+						teec_open_ss.tee_op_ntw_for_cancel,
+						&(teec_open_ss.returnOrigin), arg,
+						teec_open_ss);
+		teec_open_ss.ret = result;
+
+		if (teec_open_ss.flags == OPERATION_EXIST) {
+			if (teec_open_ss.ret == TEEC_SUCCESS) {
+				param_types = teec_open_ss.paramTypes;
+				for (i = 0; i < OP_PARAM_NUM; i++) {
+					tmp_types =
+						TEEC_PARAM_TYPE_GET
+						(param_types, i);
+					switch (tmp_types) {
+					case TEEC_MEMREF_TEMP_INPUT:
+					case TEEC_MEMREF_TEMP_OUTPUT:
+					case TEEC_MEMREF_TEMP_INOUT:
+					{
+						if (NULL !=
+							teec_open_ss.params[i].tmpref.buffer) {
+							teec_open_ss.params[i].tmpref.buffer =
+								save_buf_addr[i];
+							if (copy_to_user((void __user *)
+								(teec_open_ss.params[i].tmpref.buffer),
+								tmpref_buf[i],
+								teec_open_ss.params[i].tmpref.size)) {
+								for (i = 0; i < OP_PARAM_NUM; i++)
+									if (tmpref_buf[i] != NULL)
+										kfree(tmpref_buf[i]);
+								return -EFAULT;
+							}
+						}
+					}
+					break;
+					default:
+						break;
+					}
+				}
+			}
+		}
+		if (copy_to_user
+			((void __user *)arg, &teec_open_ss,
+			sizeof(teec_open_ss_args))) {
+			for (i = 0; i < OP_PARAM_NUM; i++)
+				if (tmpref_buf[i] != NULL)
+					kfree(tmpref_buf[i]);
+
+			return -EFAULT;
+		}
+		for (i = 0; i < OP_PARAM_NUM; i++)
+			if (tmpref_buf[i] != NULL)
+				kfree(tmpref_buf[i]);
+	}
+		break;
+	case TEEC_CLOSE_SS:
+	{
+		teec_close_ss_args teec_close_ss;
+
+		if (copy_from_user
+			(&teec_close_ss, (void __user *)arg,
+			sizeof(teec_close_ss_args)))
+			return -EFAULT;
+
+		OSA_ASSERT(teec_close_ss.tee_ss_ntw);
+
+		result = _teec_close_session(teec_close_ss.tee_ss_ntw);
+		teec_close_ss.ret = result;
+
+		if (copy_to_user
+			((void __user *)arg, &teec_close_ss,
+			sizeof(teec_close_ss_args)))
+			return -EFAULT;
+
+	}
+	break;
+	case TEEC_INVOKE_CMD:
+	{
+		uint32_t param_types, tmp_types;
+		uint32_t i;
+		uint8_t *tmpref_buf[OP_PARAM_NUM];
+		void *save_buf_addr[OP_PARAM_NUM];
+
+		teec_invoke_cmd_args teec_invoke_cmd;
+
+		if (copy_from_user(&teec_invoke_cmd,
+			(void __user *)arg,
+			sizeof(teec_invoke_cmd_args)))
+			return -EFAULT;
+
+		for (i = 0; i < OP_PARAM_NUM; i++) {
+			tmpref_buf[i] = NULL;
+			save_buf_addr[i] = NULL;
+		}
+
+		if (teec_invoke_cmd.flags == OPERATION_EXIST) {
+			param_types = teec_invoke_cmd.paramTypes;
+			for (i = 0; i < OP_PARAM_NUM; i++) {
+				tmp_types =
+					TEEC_PARAM_TYPE_GET(param_types, i);
+				switch (tmp_types) {
+				case TEEC_MEMREF_TEMP_INPUT:
+				case TEEC_MEMREF_TEMP_OUTPUT:
+				case TEEC_MEMREF_TEMP_INOUT:
+				{
+					if (NULL !=
+						teec_invoke_cmd.params[i].tmpref.buffer) {
+						tmpref_buf[i] = memdup_user((void __user *)
+							(teec_invoke_cmd.params[i].tmpref.buffer),
+							teec_invoke_cmd.params[i].tmpref.size);
+						if (tmpref_buf[i] == NULL) {
+							MARVELLTEE_DBG
+								("%s(%d): Failed to allocate buffer\n",
+								__func__,
+								__LINE__);
+							return -ENOMEM;
+						}
+						save_buf_addr[i] =
+							teec_invoke_cmd.params[i].tmpref.buffer;
+						teec_invoke_cmd.params[i].tmpref.buffer =
+							tmpref_buf[i];
+					}
+				}
+				break;
+				case TEEC_MEMREF_WHOLE:
+				case TEEC_MEMREF_PARTIAL_INPUT:
+				case TEEC_MEMREF_PARTIAL_OUTPUT:
+				case TEEC_MEMREF_PARTIAL_INOUT:
+				{
+					TEEC_MRVL_SharedMemory *teec_mrvl_shared_mem;
+					tee_impl impl;
+
+					if (copy_from_user(&impl,
+						(void __user *)teec_invoke_cmd.params[i].memref.parent,
+						sizeof(tee_impl))) {
+						return -EFAULT;
+					}
+					save_buf_addr[i] = impl;
+					teec_mrvl_shared_mem =
+						(TEEC_MRVL_SharedMemory *) (save_buf_addr[i]);
+					teec_invoke_cmd.params[i].memref.parent =
+						container_of(teec_mrvl_shared_mem,
+							TEEC_SharedMemory,
+							imp);
+				}
+				break;
+				default:
+					break;
+				}
+			}
+		}
+
+		OSA_ASSERT(teec_invoke_cmd.tee_ss_ntw);
+
+		result = _teec_invoke_command(teec_invoke_cmd.tee_ss_ntw,
+						teec_invoke_cmd.cmd_ID,
+						teec_invoke_cmd.started,
+						teec_invoke_cmd.flags,
+						teec_invoke_cmd.paramTypes,
+						&(teec_invoke_cmd.params),
+						&(teec_invoke_cmd.tee_op_ntw),
+						teec_invoke_cmd.tee_op_ntw_for_cancel,
+						&(teec_invoke_cmd.returnOrigin),
+						arg,
+						teec_invoke_cmd);
+		teec_invoke_cmd.ret = result;
+
+		if (teec_invoke_cmd.flags == OPERATION_EXIST) {
+			if (teec_invoke_cmd.ret == TEEC_SUCCESS) {
+				param_types =
+					teec_invoke_cmd.paramTypes;
+				for (i = 0; i < OP_PARAM_NUM; i++) {
+					tmp_types =
+						TEEC_PARAM_TYPE_GET(param_types, i);
+					switch (tmp_types) {
+					case TEEC_MEMREF_TEMP_INPUT:
+					case TEEC_MEMREF_TEMP_OUTPUT:
+					case TEEC_MEMREF_TEMP_INOUT:
+					{
+						if (NULL !=
+							teec_invoke_cmd.params[i].tmpref.buffer) {
+							teec_invoke_cmd.params[i].tmpref.buffer =
+								save_buf_addr[i];
+							if (copy_to_user(
+								(void __user *)
+								(teec_invoke_cmd.params[i].tmpref.buffer),
+								tmpref_buf[i],
+								teec_invoke_cmd.params[i].tmpref.size)) {
+								for (i = 0; i < OP_PARAM_NUM; i++)
+									if (tmpref_buf[i] != NULL)
+										kfree(tmpref_buf[i]);
+
+								return -EFAULT;
+							}
+						}
+					}
+					break;
+					default:
+						break;
+					}
+				}
+			}
+		}
+
+		if (copy_to_user
+			((void __user *)arg, &teec_invoke_cmd,
+			sizeof(teec_invoke_cmd_args))) {
+			for (i = 0; i < OP_PARAM_NUM; i++)
+				if (tmpref_buf[i] != NULL)
+					kfree(tmpref_buf[i]);
+
+			return -EFAULT;
+		}
+
+		for (i = 0; i < OP_PARAM_NUM; i++)
+			if (tmpref_buf[i] != NULL)
+				kfree(tmpref_buf[i]);
+	}
+	break;
+	case TEEC_REQUEST_CANCEL:
+	{
+		teec_request_cancel_args teec_request_cancel;
+
+		if (copy_from_user
+			(&teec_request_cancel, (void __user *)arg,
+			sizeof(teec_request_cancel_args)))
+			return -EFAULT;
+
+		OSA_ASSERT(teec_request_cancel.tee_op_ntw);
+
+		result =
+			_teec_request_cancellation(teec_request_cancel.tee_op_ntw);
+		teec_request_cancel.ret = result;
+
+		if (copy_to_user
+			((void __user *)arg, &teec_request_cancel,
+			sizeof(teec_request_cancel_args))) {
+			return -EFAULT;
+		}
+	}
+	break;
+	default:
+		MARVELLTEE_DBG("MARVELLTEE IOCTL invald command %x\n", cmd);
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+extern osa_sem_t _g_pm_lock;
+static int32_t marvelltee_suspend(struct platform_device *dev, pm_message_t state)
+{
+	int32_t ret;
+
+	ret = (osa_try_to_wait_for_sem(marvelltee_dev->pm_lock) ? -1 : 0);
+	return ret;
+}
+
+static int32_t marvelltee_resume(struct platform_device *dev)
+{
+	osa_release_sem(marvelltee_dev->pm_lock);
+	return 0;
+}
+
+/* driver file ops */
+static const struct file_operations _marvelltee_fops = {
+	.open = marvelltee_open,
+	.release = marvelltee_close,
+	.unlocked_ioctl = marvelltee_ioctl,
+#ifdef CONFIG_64BIT
+	.compat_ioctl = marvelltee_compat_ioctl,
+#endif
+	.owner = THIS_MODULE,
+};
+
+static int32_t marvelltee_cdev_init(marvelltee_dev_t *dev)
+{
+	int32_t err, dev_nr;
+
+	OSA_ASSERT(dev);
+
+	if (marvelltee_major) {
+		dev_nr = MKDEV(marvelltee_major, marvelltee_minor);
+		err = register_chrdev_region(dev_nr, 1, "marvelltee");
+	} else {
+		err = alloc_chrdev_region(&dev_nr, 0, 1, "marvelltee");
+		marvelltee_major = MAJOR(dev_nr);
+		marvelltee_minor = MINOR(dev_nr);
+	}
+
+	if (err < 0)
+		goto _err0;
+
+	cdev_init(&dev->cdev, &_marvelltee_fops);
+	dev->cdev.owner = THIS_MODULE;
+	dev->cdev.ops = &_marvelltee_fops;
+
+	err = cdev_add(&dev->cdev, dev_nr, 1);
+	/* Fail gracefully if need be */
+	if (err)
+		goto _err1;
+
+	dev->_marvelltee_class = class_create(THIS_MODULE, "marvelltee");
+	if (IS_ERR(dev->_marvelltee_class))
+		goto _err2;
+	device_create(dev->_marvelltee_class, NULL,
+			MKDEV(marvelltee_major, marvelltee_minor), NULL, "marvelltee");
+
+	return 0;
+
+_err2:
+	cdev_del(&dev->cdev);
+_err1:
+	unregister_chrdev_region(MKDEV(marvelltee_major, marvelltee_minor), 1);
+_err0:
+	return -1;
+}
+
+static void marvelltee_cdev_cleanup(marvelltee_dev_t *dev)
+{
+	OSA_ASSERT(dev);
+
+	device_destroy(dev->_marvelltee_class, MKDEV(marvelltee_major, marvelltee_minor));
+	class_destroy(dev->_marvelltee_class);
+	cdev_del(&dev->cdev);
+	unregister_chrdev_region(MKDEV(marvelltee_major, marvelltee_minor), 1);
+}
+
+static int marvelltee_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	unsigned int ret = 0;
+#ifdef MARVELLTEE_LPM
+	struct device_node *np = pdev->dev.of_node;
+	const void *qos;
+#endif
+
+	dev_info(dev, "%s\n", MARVELLTEE_VERSION);
+
+	/* allocate driver struct */
+	marvelltee_dev = devm_kzalloc(dev, sizeof(marvelltee_dev_t), GFP_KERNEL);
+
+	memset(marvelltee_dev, 0, sizeof(marvelltee_dev_t));
+
+	ret = marvelltee_cdev_init(marvelltee_dev);
+	if (ret < 0) {
+		dev_err(dev, "Failed to init cdev\n");
+		goto _fail_in_adding_cdev;
+	}
+
+	ret = marvelltee_init_core(marvelltee_dev);
+	if (ret) {
+		dev_err(dev, "failed to init core\n");
+		goto _fail_in_init_core;
+	}
+
+	osa_list_init_head(&(marvelltee_dev->pid_list));
+	marvelltee_dev->pid_mutex = osa_create_sem(1);
+#ifdef MARVELLTEE_LPM
+	qos = of_get_property(np, "lpm-qos", NULL);
+	if (!qos) {
+		dev_err(dev, "failed to get property qos\n");
+		goto _fail_in_init_core;
+	}
+	marvelltee_dev->marvelltee_lpm = be32_to_cpup(qos);
+#endif
+	return 0;
+
+_fail_in_init_core:
+	marvelltee_cdev_cleanup(marvelltee_dev);
+_fail_in_adding_cdev:
+
+	return -EBUSY;
+}
+
+static int marvelltee_remove(struct platform_device *pdev)
+{
+	MARVELLTEE_DBG("marvelltee cleanup\n");
+
+	osa_destroy_sem(marvelltee_dev->pid_mutex);
+	marvelltee_cleanup_core(marvelltee_dev);
+	marvelltee_cdev_cleanup(marvelltee_dev);
+
+	return 0;
+}
+
+static const struct of_device_id _marvelltee_dt_match[] = {
+	{ .compatible = "marvell,tee", .data = NULL },
+	{},
+};
+
+static struct platform_driver _marvelltee_drv = {
+	.driver = {
+		.name = MARVELLTEE_DRV_NAME,
+		.of_match_table = of_match_ptr(_marvelltee_dt_match),
+	},
+	.probe = marvelltee_probe,
+	.remove = marvelltee_remove,
+	.suspend = marvelltee_suspend,
+	.resume = marvelltee_resume,
+};
+
+module_platform_driver(_marvelltee_drv);
diff --git a/drivers/marvell/security/marvelltee/src/main/marvelltee_main_core.c b/drivers/marvell/security/marvelltee/src/main/marvelltee_main_core.c
new file mode 100644
index 0000000..8624c49
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/main/marvelltee_main_core.c
@@ -0,0 +1,800 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+
+#include <linux/time.h>
+#include "marvelltee_internal.h"
+#include "teec_time.h"
+
+#define INIT_MAGIC(_n)  \
+	do {	\
+		((uint8_t *)_n)[0] = 'T';   \
+		((uint8_t *)_n)[1] = 'Z';   \
+		((uint8_t *)_n)[2] = 'D';   \
+		((uint8_t *)_n)[3] = 'D';   \
+	} while (0)
+
+#define IS_MAGIC_VALID(_n) \
+	(('T' == ((uint8_t *)_n)[0]) && \
+	('Z' == ((uint8_t *)_n)[1]) && \
+	('D' == ((uint8_t *)_n)[2]) && \
+	('D' == ((uint8_t *)_n)[3]))
+
+#define CLEANUP_MAGIC(_n) \
+	do {	\
+		((uint8_t *)_n)[0] = '\0';  \
+		((uint8_t *)_n)[1] = '\0';  \
+		((uint8_t *)_n)[2] = '\0';  \
+		((uint8_t *)_n)[3] = '\0';  \
+	} while (0)
+
+static void _marvelltee_ctx_list_add(TEEC_Context *teec_context,
+				marvelltee_ctx_node_t *marvelltee_ctx_node)
+{
+	marvelltee_pid_list_t *marvelltee_pid = NULL;
+	osa_list_t *entry;
+	uint32_t flag = 0;
+	pid_t pid;
+
+	pid = current->tgid;
+
+	osa_list_iterate(&(marvelltee_dev->pid_list), entry) {
+		OSA_LIST_ENTRY(entry, marvelltee_pid_list_t, node, marvelltee_pid);
+		if (pid == marvelltee_pid->pid) {
+			flag = FIND_PID_IN_PID_LIST;
+			break;
+		}
+	}
+
+	if (flag == FIND_PID_IN_PID_LIST) {
+		osa_list_init_head(&(marvelltee_ctx_node->shm_list));
+		osa_list_init_head(&(marvelltee_ctx_node->ss_list));
+
+		osa_list_add(&(marvelltee_ctx_node->node),
+				&(marvelltee_pid->ctx_list));
+
+		INIT_MAGIC(marvelltee_ctx_node->magic);
+		marvelltee_ctx_node->tee_ctx_ntw = teec_context;
+	}
+}
+
+static void _marvelltee_ctx_list_del(marvelltee_ctx_node_t *marvelltee_ctx_node)
+{
+	marvelltee_pid_list_t *marvelltee_pid = NULL;
+	osa_list_t *entry;
+	uint32_t flag = 0;
+	pid_t pid;
+
+	pid = current->tgid;
+
+	osa_list_iterate(&(marvelltee_dev->pid_list), entry) {
+		OSA_LIST_ENTRY(entry, marvelltee_pid_list_t, node, marvelltee_pid);
+		if (pid == marvelltee_pid->pid) {
+			flag = FIND_PID_IN_PID_LIST;
+			break;
+		}
+	}
+
+	if (flag == FIND_PID_IN_PID_LIST) {
+		if (!(IS_MAGIC_VALID(marvelltee_ctx_node->magic)))
+			OSA_ASSERT(0);
+		CLEANUP_MAGIC(marvelltee_ctx_node->magic);
+
+		osa_list_del(&(marvelltee_ctx_node->node));
+	}
+}
+
+static void _marvelltee_shm_list_add(TEEC_Context *teec_context,
+				TEEC_SharedMemory *teec_shared_memory,
+				marvelltee_shm_node_t *marvelltee_shm_node)
+{
+	marvelltee_ctx_node_t *marvelltee_ctx_node;
+	_TEEC_MRVL_Context *_teec_mrvl_context;
+
+	_teec_mrvl_context = (_TEEC_MRVL_Context *)(teec_context->imp);
+	marvelltee_ctx_node = (marvelltee_ctx_node_t *)(_teec_mrvl_context->private_data);
+
+	osa_list_add(&(marvelltee_shm_node->node), &(marvelltee_ctx_node->shm_list));
+	INIT_MAGIC(marvelltee_shm_node->magic);
+	marvelltee_shm_node->tee_ctx_ntw = teec_context;
+	marvelltee_shm_node->tee_shm_ntw = teec_shared_memory;
+}
+
+static void _marvelltee_shm_list_del(marvelltee_shm_node_t *marvelltee_shm_node)
+{
+	TEEC_Context *teec_context;
+	_TEEC_MRVL_Context *_teec_mrvl_context;
+	marvelltee_ctx_node_t *marvelltee_ctx_node;
+
+	if (!(IS_MAGIC_VALID(marvelltee_shm_node->magic)))
+		OSA_ASSERT(0);
+
+	teec_context = marvelltee_shm_node->tee_ctx_ntw;
+	_teec_mrvl_context = (_TEEC_MRVL_Context *)(teec_context->imp);
+	marvelltee_ctx_node = (marvelltee_ctx_node_t *)(_teec_mrvl_context->private_data);
+
+	if (!(IS_MAGIC_VALID(marvelltee_ctx_node->magic)))
+		OSA_ASSERT(0);
+
+	CLEANUP_MAGIC(marvelltee_shm_node->magic);
+
+	osa_list_del(&(marvelltee_shm_node->node));
+}
+
+static void _marvelltee_ss_list_add(TEEC_Context *teec_context,
+				TEEC_Session *teec_session,
+				marvelltee_ss_node_t *marvelltee_ss_node)
+{
+	marvelltee_ctx_node_t *marvelltee_ctx_node;
+	_TEEC_MRVL_Context *_teec_mrvl_context;
+
+	_teec_mrvl_context = (_TEEC_MRVL_Context *)(teec_context->imp);
+	marvelltee_ctx_node = (marvelltee_ctx_node_t *)(_teec_mrvl_context->private_data);
+
+	osa_list_add(&(marvelltee_ss_node->node), &(marvelltee_ctx_node->ss_list));
+	INIT_MAGIC(marvelltee_ss_node->magic);
+	marvelltee_ss_node->tee_ctx_ntw = teec_context;
+	marvelltee_ss_node->tee_ss_ntw = teec_session;
+}
+
+static void _marvelltee_ss_list_del(marvelltee_ss_node_t *marvelltee_ss_node)
+{
+	TEEC_Context *teec_context;
+	_TEEC_MRVL_Context *_teec_mrvl_context;
+	marvelltee_ctx_node_t *marvelltee_ctx_node;
+
+	if (!(IS_MAGIC_VALID(marvelltee_ss_node->magic)))
+		OSA_ASSERT(0);
+
+	teec_context = marvelltee_ss_node->tee_ctx_ntw;
+	_teec_mrvl_context = (_TEEC_MRVL_Context *)(teec_context->imp);
+	marvelltee_ctx_node = (marvelltee_ctx_node_t *)(_teec_mrvl_context->private_data);
+
+	if (!(IS_MAGIC_VALID(marvelltee_ctx_node->magic)))
+		OSA_ASSERT(0);
+
+	CLEANUP_MAGIC(marvelltee_ss_node->magic);
+
+	osa_list_del(&(marvelltee_ss_node->node));
+}
+
+TEEC_Result _teec_initialize_context(const char *name, tee_impl *tee_ctx_ntw)
+{
+	TEEC_Context *teec_context;
+	TEEC_Result result;
+	marvelltee_ctx_node_t *marvelltee_ctx_node;
+	_TEEC_MRVL_Context *_teec_mrvl_context;
+
+	if (!name || (!osa_memcmp(name, DEVICE_NAME, DEVICE_NAME_SIZE))) {
+		teec_context =
+			(TEEC_Context *) osa_kmem_alloc(sizeof(TEEC_Context));
+		if (!teec_context) {
+			MARVELLTEE_DBG("Fail to malloc TEEC_Context\n");
+			return TEEC_ERROR_OUT_OF_MEMORY;
+		}
+
+		result = TEEC_InitializeContext(name, teec_context);
+		if (result != TEEC_SUCCESS) {
+			MARVELLTEE_DBG
+				("%s(%d), Error in TEEC_InitializeContext, result = 0x%x\n",
+				__func__, __LINE__, result);
+			*tee_ctx_ntw = NULL;
+			osa_kmem_free(teec_context);
+
+			return result;
+		}
+
+		*tee_ctx_ntw = (tee_impl) (&(teec_context->imp));
+
+		_teec_mrvl_context = (_TEEC_MRVL_Context *)(teec_context->imp);
+		marvelltee_ctx_node = osa_kmem_alloc(sizeof(marvelltee_ctx_node_t));
+		OSA_ASSERT(marvelltee_ctx_node != NULL);
+
+		osa_wait_for_sem(marvelltee_dev->pid_mutex, INFINITE);
+		_marvelltee_ctx_list_add(teec_context, marvelltee_ctx_node);
+		osa_release_sem(marvelltee_dev->pid_mutex);
+
+		_teec_mrvl_context->private_data = marvelltee_ctx_node;
+	} else {
+		return TEEC_ERROR_BAD_PARAMETERS;
+	}
+
+	return TEEC_SUCCESS;
+}
+
+TEEC_Result _teec_final_context(tee_impl tee_ctx_ntw)
+{
+	TEEC_Context *teec_context;
+	TEEC_MRVL_Context *teec_mrvl_context;
+	marvelltee_ctx_node_t *marvelltee_ctx_node;
+	_TEEC_MRVL_Context *_teec_mrvl_context;
+
+	/* Find the struct according to the member */
+	teec_mrvl_context = (TEEC_MRVL_Context *) tee_ctx_ntw;
+	teec_context = container_of(teec_mrvl_context, TEEC_Context, imp);
+
+	_teec_mrvl_context = (_TEEC_MRVL_Context *)(teec_context->imp);
+	marvelltee_ctx_node = (marvelltee_ctx_node_t *)(_teec_mrvl_context->private_data);
+
+	osa_wait_for_sem(marvelltee_dev->pid_mutex, INFINITE);
+	_marvelltee_ctx_list_del(marvelltee_ctx_node);
+	osa_release_sem(marvelltee_dev->pid_mutex);
+
+	osa_kmem_free(marvelltee_ctx_node);
+
+	TEEC_FinalizeContext(teec_context);
+
+	osa_kmem_free(teec_context);
+
+	return TEEC_SUCCESS;
+}
+
+TEEC_Result _teec_map_shared_mem(teec_map_shared_mem_args teec_map_shared_mem,
+				tee_impl *tee_shm_ntw)
+{
+	/* only call TEEC_RegisterSharedMemory */
+	TEEC_Context *teec_context;
+	TEEC_MRVL_Context *teec_mrvl_context;
+	TEEC_SharedMemory *teec_shared_memory;
+	TEEC_Result result;
+	marvelltee_shm_node_t *marvelltee_shm_node;
+	_TEEC_MRVL_SharedMemory *_teec_mrvl_sharedMem;
+
+	teec_mrvl_context =
+		(TEEC_MRVL_Context *) (teec_map_shared_mem.tee_ctx_ntw);
+	teec_context = container_of(teec_mrvl_context, TEEC_Context, imp);
+
+	teec_shared_memory =
+		(TEEC_SharedMemory *) osa_kmem_alloc(sizeof(TEEC_SharedMemory));
+	if (!teec_shared_memory) {
+		MARVELLTEE_DBG("Fail to malloc TEEC_SharedMemory\n");
+		return TEEC_ERROR_OUT_OF_MEMORY;
+	}
+
+	teec_shared_memory->buffer = teec_map_shared_mem.buffer;
+	teec_shared_memory->size = teec_map_shared_mem.size;
+	teec_shared_memory->flags = teec_map_shared_mem.flags;
+
+	result = TEEC_RegisterSharedMemory(teec_context, teec_shared_memory);
+	if (result != TEEC_SUCCESS) {
+		MARVELLTEE_DBG
+			("%s(%d), Error in TEEC_RegisterSharedMemory, result = 0x%x\n",
+			__func__, __LINE__, result);
+		*tee_shm_ntw = NULL;
+		osa_kmem_free(teec_shared_memory);
+
+		return result;
+	}
+
+	*tee_shm_ntw = (tee_impl) (&(teec_shared_memory->imp));
+
+	_teec_mrvl_sharedMem =
+		(_TEEC_MRVL_SharedMemory *)(teec_shared_memory->imp);
+	marvelltee_shm_node = osa_kmem_alloc(sizeof(marvelltee_shm_node_t));
+	OSA_ASSERT(marvelltee_shm_node != NULL);
+
+	osa_wait_for_sem(marvelltee_dev->pid_mutex, INFINITE);
+	_marvelltee_shm_list_add(teec_context, teec_shared_memory, marvelltee_shm_node);
+	osa_release_sem(marvelltee_dev->pid_mutex);
+
+	_teec_mrvl_sharedMem->private_data = marvelltee_shm_node;
+
+	return TEEC_SUCCESS;
+}
+
+TEEC_Result _teec_unmap_shared_mem(teec_unmap_shared_mem_args
+				teec_unmap_shared_mem, tee_impl tee_shm_ntw)
+{
+	TEEC_SharedMemory *teec_shared_memory;
+	TEEC_MRVL_SharedMemory *teec_mrvl_shared_mem;
+	_TEEC_MRVL_SharedMemory *_teec_mrvl_sharedMem;
+	marvelltee_shm_node_t *marvelltee_shm_node;
+
+	teec_mrvl_shared_mem = (TEEC_MRVL_SharedMemory *) tee_shm_ntw;
+	teec_shared_memory =
+		container_of(teec_mrvl_shared_mem, TEEC_SharedMemory, imp);
+
+	_teec_mrvl_sharedMem = (_TEEC_MRVL_SharedMemory *)(teec_shared_memory->imp);
+	marvelltee_shm_node = (marvelltee_shm_node_t *)(_teec_mrvl_sharedMem->private_data);
+
+	osa_wait_for_sem(marvelltee_dev->pid_mutex, INFINITE);
+	_marvelltee_shm_list_del(marvelltee_shm_node);
+	osa_release_sem(marvelltee_dev->pid_mutex);
+
+	osa_kmem_free(marvelltee_shm_node);
+
+	TEEC_ReleaseSharedMemory(teec_shared_memory);
+
+	osa_kmem_free(teec_shared_memory);
+
+	return TEEC_SUCCESS;
+}
+
+TEEC_Result _teec_open_session(tee_impl tee_ctx_ntw,
+				tee_impl *tee_ss_ntw,
+				const TEEC_UUID *destination,
+				uint32_t connectionMethod,
+				const void *connectionData,
+				uint32_t flags,
+				uint32_t paramTypes,
+				TEEC_Parameter(*params)[4],
+				tee_impl *tee_op_ntw,
+				tee_impl tee_op_ntw_for_cancel,
+				uint32_t *returnOrigin,
+				unsigned long arg,
+				teec_open_ss_args open_ss_args)
+{
+	TEEC_Context *teec_context;
+	TEEC_MRVL_Context *teec_mrvl_context;
+	TEEC_Session *teec_session;
+	TEEC_Operation *teec_operation = NULL;
+	TEEC_Result result;
+	uint32_t i;
+	ulong_t tmp_for_cancel;
+	marvelltee_ss_node_t *marvelltee_ss_node;
+	_TEEC_MRVL_Session *_teec_mrvl_session;
+
+	teec_mrvl_context = (TEEC_MRVL_Context *) (tee_ctx_ntw);
+	teec_context = container_of(teec_mrvl_context, TEEC_Context, imp);
+
+	teec_session = (TEEC_Session *) osa_kmem_alloc(sizeof(TEEC_Session));
+	if (!teec_session) {
+		MARVELLTEE_DBG("Fail to malloc TEEC_Session\n");
+		return TEEC_ERROR_OUT_OF_MEMORY;
+	}
+
+	*tee_ss_ntw = (tee_impl) (&(teec_session->imp));
+
+	if (flags == OPERATION_EXIST) {
+		if (copy_from_user
+			(&tmp_for_cancel, (void __user *)(tee_op_ntw_for_cancel),
+			4)) {
+			osa_kmem_free(teec_session);
+			return -EFAULT;
+		}
+
+		teec_operation =
+			(TEEC_Operation *) osa_kmem_alloc(sizeof(TEEC_Operation));
+		if (!teec_operation) {
+			MARVELLTEE_DBG("Fail to malloc TEEC_Operation\n");
+			osa_kmem_free(teec_session);
+			return TEEC_ERROR_OUT_OF_MEMORY;
+		}
+		teec_operation->started = 0;
+		teec_operation->paramTypes = paramTypes;
+		for (i = 0; i < 4; i++)
+			teec_operation->params[i] = (*params)[i];
+
+		*tee_op_ntw = (tee_impl) (&(teec_operation->imp));
+		tmp_for_cancel = (ulong_t)(&(teec_operation->imp));
+
+		/* Add copy_to_user here, for cancellation */
+		if (copy_to_user
+			((void __user *)(tee_op_ntw_for_cancel), &tmp_for_cancel,
+			sizeof(tmp_for_cancel))) {
+			osa_kmem_free(teec_operation);
+			osa_kmem_free(teec_session);
+			return -EFAULT;
+		}
+	} else {
+		*tee_op_ntw = NULL;
+	}
+
+	result = TEEC_OpenSession(teec_context,
+				teec_session,
+				destination,
+				connectionMethod,
+				connectionData, teec_operation, returnOrigin);
+
+	if (result != TEEC_SUCCESS) {
+		MARVELLTEE_DBG("%s(%d), Error in TEEC_OpenSession, result = 0x%x\n",
+			__func__, __LINE__, result);
+		*tee_ss_ntw = NULL;
+		osa_kmem_free(teec_session);
+
+		if (flags == OPERATION_EXIST) {
+			for (i = 0; i < 4; i++)
+				(*params)[i] = teec_operation->params[i];
+
+			*tee_op_ntw = NULL;
+			osa_kmem_free(teec_operation);
+		}
+		return result;
+	}
+
+	/* Copy param in order to return to CA */
+	if (flags == OPERATION_EXIST) {
+		for (i = 0; i < 4; i++)
+			(*params)[i] = teec_operation->params[i];
+
+		osa_kmem_free(teec_operation);
+	}
+
+	_teec_mrvl_session =
+		(_TEEC_MRVL_Session *)(teec_session->imp);
+	marvelltee_ss_node = osa_kmem_alloc(sizeof(marvelltee_ss_node_t));
+	OSA_ASSERT(marvelltee_ss_node != NULL);
+
+	osa_wait_for_sem(marvelltee_dev->pid_mutex, INFINITE);
+	_marvelltee_ss_list_add(teec_context, teec_session, marvelltee_ss_node);
+	osa_release_sem(marvelltee_dev->pid_mutex);
+
+	_teec_mrvl_session->private_data = marvelltee_ss_node;
+
+	return TEEC_SUCCESS;
+}
+
+TEEC_Result _teec_close_session(tee_impl tee_ss_ntw)
+{
+	TEEC_Session *teec_session;
+	TEEC_MRVL_Session *teec_mrvl_session;
+	marvelltee_ss_node_t *marvelltee_ss_node;
+	_TEEC_MRVL_Session *_teec_mrvl_session;
+
+	teec_mrvl_session = (TEEC_MRVL_Session *) (tee_ss_ntw);
+	teec_session = container_of(teec_mrvl_session, TEEC_Session, imp);
+
+	_teec_mrvl_session = (_TEEC_MRVL_Session *)(teec_session->imp);
+	marvelltee_ss_node = (marvelltee_ss_node_t *)(_teec_mrvl_session->private_data);
+
+	osa_wait_for_sem(marvelltee_dev->pid_mutex, INFINITE);
+	_marvelltee_ss_list_del(marvelltee_ss_node);
+	osa_release_sem(marvelltee_dev->pid_mutex);
+
+	osa_kmem_free(marvelltee_ss_node);
+
+	TEEC_CloseSession(teec_session);
+
+	osa_kmem_free(teec_session);
+
+	return TEEC_SUCCESS;
+}
+
+TEEC_Result _teec_invoke_command(tee_impl tee_ss_ntw,
+				uint32_t cmd_ID,
+				uint32_t started,
+				uint32_t flags,
+				uint32_t paramTypes,
+				TEEC_Parameter(*params)[4],
+				tee_impl *tee_op_ntw,
+				tee_impl tee_op_ntw_for_cancel,
+				uint32_t *returnOrigin,
+				unsigned long arg,
+				teec_invoke_cmd_args invoke_cmd_args)
+{
+	TEEC_Session *teec_session;
+	TEEC_MRVL_Session *teec_mrvl_session;
+	TEEC_Operation *teec_operation = NULL;
+	TEEC_Result result;
+	uint32_t i;
+	ulong_t tmp_for_cancel;
+
+	teec_mrvl_session = (TEEC_MRVL_Session *) (tee_ss_ntw);
+	teec_session = container_of(teec_mrvl_session, TEEC_Session, imp);
+
+	if (flags == OPERATION_EXIST) {
+		teec_operation =
+			(TEEC_Operation *) osa_kmem_alloc(sizeof(TEEC_Operation));
+		if (!teec_operation) {
+			MARVELLTEE_DBG("Fail to malloc TEEC_Operation\n");
+			return TEEC_ERROR_OUT_OF_MEMORY;
+		}
+		teec_operation->started = 0;
+		teec_operation->paramTypes = paramTypes;
+		for (i = 0; i < 4; i++)
+			teec_operation->params[i] = (*params)[i];
+
+		*tee_op_ntw = (tee_impl) (&(teec_operation->imp));
+		tmp_for_cancel = (ulong_t) (&(teec_operation->imp));
+
+		/* Add copy_to_user here, for cancellation */
+		if (copy_to_user
+			((void __user *)(tee_op_ntw_for_cancel), &tmp_for_cancel,
+			sizeof(tmp_for_cancel))) {
+			osa_kmem_free(teec_operation);
+			return -EFAULT;
+		}
+	} else {
+		*tee_op_ntw = NULL;
+	}
+
+	result = TEEC_InvokeCommand(teec_session,
+					cmd_ID, teec_operation, returnOrigin);
+
+	if (result != TEEC_SUCCESS) {
+		MARVELLTEE_DBG("%s(%d), Error in TEEC_InvokeCommand, result = 0x%x\n",
+			__func__, __LINE__, result);
+		if (flags == OPERATION_EXIST) {
+			for (i = 0; i < 4; i++)
+				(*params)[i] = teec_operation->params[i];
+
+			*tee_op_ntw = NULL;
+			osa_kmem_free(teec_operation);
+		}
+		return result;
+	}
+
+	/* Copy param in order to return to CA */
+	if (flags == OPERATION_EXIST) {
+		for (i = 0; i < 4; i++)
+			(*params)[i] = teec_operation->params[i];
+
+		osa_kmem_free(teec_operation);
+	}
+
+	return TEEC_SUCCESS;
+}
+
+TEEC_Result _teec_request_cancellation(tee_impl tee_op_ntw)
+{
+	TEEC_Operation *teec_operation;
+	TEEC_MRVL_Operation *teec_mrvl_operation;
+
+	teec_mrvl_operation = (TEEC_MRVL_Operation *) tee_op_ntw;
+	teec_operation = container_of(teec_mrvl_operation, TEEC_Operation, imp);
+
+	TEEC_RequestCancellation(teec_operation);
+
+	return TEEC_SUCCESS;
+}
+
+/*
+ * Name:        marvelltee_get_first_req
+ *
+ * Description: get first node from request list
+ *
+ * Params:
+ *   node       - node pointer
+ *
+ * Returns:
+ *   true       - have request
+ *   false      - have no request
+ *
+ * Notes:       none
+ *
+ */
+bool marvelltee_get_first_req(tee_msg_head_t **tee_msg_head)
+{
+	struct osa_list *first;
+
+	*tee_msg_head = NULL;
+
+	osa_wait_for_mutex(marvelltee_dev->req_mutex, INFINITE);
+	if (osa_list_empty(&marvelltee_dev->req_list)) {
+		osa_release_mutex(marvelltee_dev->req_mutex);
+		return false;
+	}
+
+	first = (marvelltee_dev->req_list).next;
+	OSA_LIST_ENTRY(first, tee_msg_head_t, node, *tee_msg_head);
+	osa_release_mutex(marvelltee_dev->req_mutex);
+
+	return true;
+}
+
+/*
+ * Name:        marvelltee_add_node_to_req_list
+ *
+ * Description: add node to request list
+ *
+ * Params:
+ *   list       - list pointer
+ *
+ * Returns:     none
+ *
+ * Notes:       none
+ *
+ */
+void marvelltee_add_node_to_req_list(osa_list_t *list)
+{
+	osa_wait_for_mutex(marvelltee_dev->req_mutex, INFINITE);
+	osa_list_add_tail(list, &marvelltee_dev->req_list);
+	osa_release_mutex(marvelltee_dev->req_mutex);
+}
+
+/*
+ * Name:        marvelltee_chk_node_on_req_list
+ *
+ * Description: check node to request list
+ *
+ * Params:
+ *   list       - list pointer
+ *
+ * Returns:
+ *   true       - node is on the list
+ *   false      - node is not exist
+ *
+ * Notes:       none
+ *
+ */
+bool marvelltee_chk_node_on_req_list(osa_list_t *list)
+{
+	struct osa_list *entry;
+
+	osa_wait_for_mutex(marvelltee_dev->req_mutex, INFINITE);
+	osa_list_iterate(&marvelltee_dev->req_list, entry) {
+		if (entry == list) {
+			osa_release_mutex(marvelltee_dev->req_mutex);
+			return true;
+		}
+	}
+	osa_release_mutex(marvelltee_dev->req_mutex);
+
+	return false;
+}
+
+/*
+ * Name:        marvelltee_del_node_from_req_list
+ *
+ * Description: delete node from request list
+ *
+ * Params:
+ *   list       - list pointer
+ *
+ * Returns:
+ *   true       - node has deleted from the list
+ *   false      - node is not exist
+ *
+ * Notes:       none
+ *
+ */
+bool marvelltee_del_node_from_req_list(osa_list_t *list)
+{
+	struct osa_list *entry, *next;
+
+	osa_wait_for_mutex(marvelltee_dev->req_mutex, INFINITE);
+	osa_list_iterate_safe(&marvelltee_dev->req_list, entry, next) {
+		if (entry == list) {
+			osa_list_del(entry);
+			osa_release_mutex(marvelltee_dev->req_mutex);
+			return true;
+		}
+	}
+	osa_release_mutex(marvelltee_dev->req_mutex);
+
+	return false;
+}
+
+/*
+ * Name:        marvelltee_have_req
+ *
+ * Description: check there have some request in the run list
+ *              and the request list or not
+ *
+ * Params:      none
+ *
+ * Returns:
+ *   true       - have request
+ *   false      - have no request
+ *
+ * Notes:       none
+ *
+ */
+bool marvelltee_have_req(void)
+{
+	osa_wait_for_mutex(marvelltee_dev->req_mutex, INFINITE);
+	if (!osa_list_empty(&marvelltee_dev->req_list)) {
+		osa_release_mutex(marvelltee_dev->req_mutex);
+		return true;
+	}
+	osa_release_mutex(marvelltee_dev->req_mutex);
+
+	return false;
+}
+
+uint32_t marvelltee_get_req_num_in_list(void)
+{
+	struct osa_list *entry;
+	uint32_t n = 0;
+
+	osa_wait_for_mutex(marvelltee_dev->req_mutex, INFINITE);
+	osa_list_iterate(&marvelltee_dev->req_list, entry) {
+		n++;
+	}
+	osa_release_mutex(marvelltee_dev->req_mutex);
+
+	return n;
+}
+
+extern int32_t teec_shd_init(void);
+extern void teec_shd_cleanup(void);
+#ifdef TEE_DEBUG_ENALBE_PROC_FS_LOG
+extern void tee_dbg_proc_fs_init(void);
+extern void tee_dbg_proc_fs_cleanup(void);
+#endif
+extern int32_t teec_get_seed(void);
+
+int32_t marvelltee_init_core(marvelltee_dev_t *dev)
+{
+	int32_t ret;
+
+	osa_list_init_head(&dev->req_list);
+	dev->req_mutex = osa_create_mutex();
+
+	ret = tee_cm_init();
+	if (ret) {
+		MARVELLTEE_DBG("%s: failed to init cm\n", __func__);
+
+		goto _failure_in_cm_init;
+	}
+#ifdef TEE_DEBUG_ENALBE_PROC_FS_LOG
+	tee_dbg_proc_fs_init();
+#endif
+
+	ret = marvelltee_proxy_thread_init(dev);
+	if (ret) {
+		MARVELLTEE_DBG("%s: failed to init proxy threads\n", __func__);
+		goto _failure_in_proxy_thread_init;
+	}
+
+	ret = (int32_t)teec_cb_module_init();
+	if (ret) {
+		MARVELLTEE_DBG("%s: failed to init callback module\n", __func__);
+		goto _failure_in_cb_init;
+	}
+	ret = (int32_t)teec_reg_time_cb(dev);
+	if (ret) {
+		MARVELLTEE_DBG("%s: failed to reg time cb\n", __func__);
+		goto _failure_in_reg_time_cb;
+	}
+
+	ret = teec_shd_init();
+	if (ret) {
+		MARVELLTEE_DBG("%s: failed to init shared device\n", __func__);
+		goto _failure_in_shd_init;
+	}
+
+#ifdef SW_SEED
+	/* provide the SEED resource */
+	ret = teec_get_seed();
+	if (ret) {
+		MARVELLTEE_DBG("%s: failed to get the SEED resource.\n", __func__);
+		goto _failure_in_get_seed;
+	}
+#endif
+
+	return 0;
+
+#ifdef SW_SEED
+_failure_in_get_seed:
+#endif
+_failure_in_shd_init:
+	teec_unreg_time_cb(dev);
+_failure_in_reg_time_cb:
+	teec_cb_module_cleanup();
+_failure_in_cb_init:
+	marvelltee_proxy_thread_cleanup(dev);
+_failure_in_proxy_thread_init:
+_failure_in_cm_init:
+
+	tee_cm_cleanup();
+	return ret;
+}
+
+void marvelltee_cleanup_core(marvelltee_dev_t *dev)
+{
+	teec_shd_cleanup();
+	teec_unreg_time_cb(dev);
+	teec_cb_module_cleanup();
+	marvelltee_proxy_thread_cleanup(dev);
+#ifdef TEE_DEBUG_ENALBE_PROC_FS_LOG
+	tee_dbg_proc_fs_cleanup();
+#endif
+	tee_cm_cleanup();
+
+	osa_destroy_mutex(dev->req_mutex);
+}
diff --git a/drivers/marvell/security/marvelltee/src/main/marvelltee_pt.c b/drivers/marvell/security/marvelltee/src/main/marvelltee_pt.c
new file mode 100644
index 0000000..c949821
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/main/marvelltee_pt.c
@@ -0,0 +1,199 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+
+#include "marvelltee_internal.h"
+#include "marvelltee_pt_core.h"
+
+extern uint32_t tee_cm_get_cb_req_num(void);
+extern uint32_t tee_cm_get_cb_rsp_num(void);
+
+#ifdef CONFIG_64BIT
+#define CALL_SMC			(0x72000000)
+#define CALL_IPI			(0x73000000)
+#else
+#define CALL_SMC			(0x33000000)
+#define CALL_IPI			(0x34000000)
+#endif
+
+static uint32_t _g_marvelltee_send_num;
+static bool _g_pt_thread_stop_flag;
+
+uint32_t g_msg_sent;
+uint32_t g_msg_recv;
+uint32_t g_msg_fake;
+uint32_t g_msg_ignd;
+uint32_t g_pre_ipi_num;
+uint32_t g_pst_ipi_num;
+uint32_t g_pre_dmy_num;
+uint32_t g_pst_dmy_num;
+
+static int marvelltee_proxy_thread(void *data)
+{
+	marvelltee_dev_t *dev;
+	tee_msg_head_t *tee_msg_send_head = NULL;
+
+	uint32_t nice;
+
+	uint32_t res_size = 0;
+	uint32_t msg_flag;
+
+	uint32_t ret;
+	bool list_ret;
+#ifdef MARVELLTEE_LPM
+	bool is_lpm_blocked = false;
+#endif
+
+	set_cpus_allowed_ptr(current, cpumask_of(0));
+	MARVELLTEE_DBG("marvelltee_proxy_thread on cpu %d\n", smp_processor_id());
+
+	current->flags |= PF_FREEZER_SKIP;
+	nice = task_nice(current);
+	MARVELLTEE_DBG("marvelltee_proxy_thread: nice = %d\n", nice);
+
+	dev = (marvelltee_dev_t *) data;
+
+	while (1) {
+		while (marvelltee_get_first_req(&tee_msg_send_head)) {
+#if 0
+			MARVELLTEE_DBG
+				("%s: tee_msg_send_head (0x%lx) = {magic (%c%c%c%c), size (0x%08x)}, cmd (0x%x)}\n",
+				__func__, (ulong_t) tee_msg_send_head,
+				tee_msg_send_head->magic[0],
+				tee_msg_send_head->magic[1],
+				tee_msg_send_head->magic[2],
+				tee_msg_send_head->magic[3],
+				tee_msg_send_head->msg_sz,
+				*((uint8_t *) (tee_msg_send_head) + sizeof(tee_msg_head_t) + 4));
+#endif /* 0 */
+			list_ret =
+				marvelltee_del_node_from_req_list(&
+							(tee_msg_send_head->
+							node));
+			OSA_ASSERT(list_ret);
+
+			marvelltee_pt_send(tee_msg_send_head);
+#ifdef MARVELLTEE_LPM
+			if (false == is_lpm_blocked) {
+				/* block LPM D1P and deeper than D1P */
+				osa_wait_for_sem(dev->pm_lock, INFINITE);
+				pm_qos_update_request(&(dev->marvelltee_lpm_cons),
+					dev->marvelltee_lpm);
+				is_lpm_blocked = true;
+			}
+#endif
+			tee_add_time_record_point("npct");
+			/* Call IPI to TW */
+			g_pre_ipi_num++;
+			tee_cm_smi(CALL_IPI);
+
+			g_pst_ipi_num++;
+			tee_add_time_record_point("npbt");
+			_g_marvelltee_send_num++;
+			g_msg_sent++;
+		}
+
+		res_size = tee_cm_get_data_size();
+
+		while (res_size) {
+
+			msg_flag = marvelltee_pt_recv();
+			if (msg_flag == TEE_MSG_IGNORE_COUNTER) {
+				/* do nothing */
+				g_msg_ignd++;
+			} else {	/* TEE_MSG_FAKE && TEE_MSG_NORMAL */
+				if (msg_flag == TEE_MSG_NORMAL)
+					g_msg_recv++;
+				else if (msg_flag == TEE_MSG_FAKE)
+					g_msg_fake++;
+				else
+					OSA_ASSERT(0);
+				_g_marvelltee_send_num--;
+			}
+
+			res_size = tee_cm_get_data_size();
+		}
+		tee_add_time_record_point("nprm");
+		/* all the requests are trapped in the callbacks in secure world.
+		   * requests from secure world are all served by PT.
+		   */
+		if (_g_marvelltee_send_num == 0 ||
+				((_g_marvelltee_send_num == (tee_cm_get_cb_req_num() - tee_cm_get_cb_rsp_num()))
+				&& (tee_cm_get_cb_req_num() == g_msg_ignd))) {
+#ifdef MARVELLTEE_LPM
+			/* release D1P LPM constraint */
+			if (true == is_lpm_blocked) {
+				pm_qos_update_request(&(dev->marvelltee_lpm_cons),
+					PM_QOS_CPUIDLE_BLOCK_DEFAULT_VALUE);
+				osa_release_sem(dev->pm_lock);
+				is_lpm_blocked = false;
+			}
+#endif
+			tee_add_time_record_point("npwa");
+			ret = osa_wait_for_sem(dev->pt_sem, INFINITE);
+			OSA_ASSERT(!ret);
+
+			if (true == _g_pt_thread_stop_flag) {
+				MARVELLTEE_DBG("marvelltee_proxy_thread(),P-break\n");
+				break;
+			}
+			tee_add_time_record_point("npet");
+		} else {
+			g_pre_dmy_num++;
+
+			tee_cm_smi(CALL_SMC);
+			g_pst_dmy_num++;
+		}
+	}
+
+	MARVELLTEE_DBG("proxy thread exit.\n");
+	return 0;
+
+}
+
+int marvelltee_proxy_thread_init(marvelltee_dev_t *dev)
+{
+	/* initialize the qos list at the first time */
+#ifdef MARVELLTEE_LPM
+	dev->marvelltee_lpm_cons.name = "MARVELLTEE";
+	pm_qos_add_request(&(dev->marvelltee_lpm_cons),
+			PM_QOS_CPUIDLE_BLOCK,
+			PM_QOS_CPUIDLE_BLOCK_DEFAULT_VALUE);
+#endif
+	dev->pt_sem = osa_create_sem(0);
+	dev->pm_lock = osa_create_sem(1);
+
+	dev->proxy_thd = kthread_run(marvelltee_proxy_thread, dev, "marvelltee");
+
+	if (!dev->proxy_thd) {
+		MARVELLTEE_DBG("%s: failed to create proxy thread.\n", __func__);
+		return -1;
+	}
+
+	return 0;
+}
+
+void marvelltee_proxy_thread_cleanup(marvelltee_dev_t *dev)
+{
+	_g_pt_thread_stop_flag = true;
+	osa_release_sem(dev->pt_sem);
+	osa_destroy_sem(dev->pt_sem);
+
+	osa_destroy_sem(dev->pm_lock);
+
+	pm_qos_remove_request(&(dev->marvelltee_lpm_cons));
+}
diff --git a/drivers/marvell/security/marvelltee/src/main/marvelltee_pt_core.c b/drivers/marvell/security/marvelltee/src/main/marvelltee_pt_core.c
new file mode 100644
index 0000000..26a3b7c
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/main/marvelltee_pt_core.c
@@ -0,0 +1,136 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+
+#include "marvelltee_internal.h"
+#include "marvelltee_pt_core.h"
+
+static uint32_t _check_message_flag(tee_msg_head_t tee_msg_head)
+{
+	/*
+	 * TEE_MSG_FAKE: (the fake message for SSTd)
+	 * 1. marvelltee_send_num --
+	 * 2. read the msg from RB, then discard it
+	 * TEE_MSG_IGNORE_COUNTER: (the real message for SSTd)
+	 * 1. handle the msg as normal
+	 * 2. did NOT modify the marvelltee_send_num
+	 */
+	if ((tee_msg_head.msg_prop.type == TEE_MSG_TYPE_CONTROL) &&
+		(tee_msg_head.msg_prop.ctl.cmd == TEE_MSG_CTL_TRAPPED)) {
+		return TEE_MSG_FAKE;
+	}
+
+	if (tee_msg_head.msg_prop.bp.has_trapped == true)
+		return TEE_MSG_IGNORE_COUNTER;
+
+	return TEE_MSG_NORMAL;
+}
+
+void marvelltee_pt_send(tee_msg_head_t *tee_msg_send_head)
+{
+	tee_msgm_t tee_msgm_handle;
+	tee_cmd_t tee_msg_cmd;
+
+	/* deal with cancellation */
+	if (tee_msg_send_head->msg_prop.bp.stat == TEE_MSG_STAT_CAN) {
+		void *arg;
+
+		tee_msgm_handle = tee_msgm_create_inst();
+		tee_msgm_set_msg_buf(tee_msgm_handle, NULL,
+					(uint8_t *) tee_msg_send_head +
+					sizeof(tee_msg_head_t), NULL);
+		tee_msgm_get_cmd(tee_msgm_handle, &tee_msg_cmd, NULL);
+
+		if (tee_msg_cmd == TEE_CMD_OPEN_SS) {
+			tee_set_ret_open_ss_arg_t tee_set_ret_open_ss_arg;
+
+			tee_set_ret_open_ss_arg.ss_tw = NULL;
+			tee_set_ret_open_ss_arg.ret_orig = TEEC_ORIGIN_API;
+			tee_set_ret_open_ss_arg.ret = TEEC_ERROR_CANCEL;
+
+			arg = &tee_set_ret_open_ss_arg;
+		} else if (tee_msg_cmd == TEE_CMD_INV_OP) {
+			tee_set_ret_inv_op_arg_t tee_set_ret_inv_op_arg;
+
+			tee_set_ret_inv_op_arg.ret_orig = TEEC_ORIGIN_API;
+			tee_set_ret_inv_op_arg.ret = TEEC_ERROR_CANCEL;
+
+			arg = &tee_set_ret_inv_op_arg;
+		} else {
+			OSA_ASSERT(0);
+		}
+
+		tee_msgm_set_ret(tee_msgm_handle, arg);
+
+		tee_msgm_destroy_inst(tee_msgm_handle);
+
+		osa_release_sem(tee_msg_send_head->comp);
+	}
+	/* Call ComM to copy the buffer into RC */
+	tee_cm_send_data((uint8_t *) tee_msg_send_head);
+}
+
+uint32_t marvelltee_pt_recv(void)
+{
+	tee_msg_head_t *tee_msg_recv_head;
+	tee_msgm_t tee_msgm_handle;
+	tee_cmd_t tee_msg_cmd;
+	tee_msg_head_t tee_msg_head;
+	uint32_t msg_flag;
+
+	tee_cm_get_msgm_head(&tee_msg_head);
+	msg_flag = _check_message_flag(tee_msg_head);
+
+	if (msg_flag != TEE_MSG_FAKE) {
+		#if 0
+		MARVELLTEE_DBG
+			("%s: tee_msg_head =\
+			{magic (%c%c%c%c) ,\
+			size (0x%08x)},\
+			cmd (0x%x),\
+			msg_flag (0x%x)\n",\
+			__func__, tee_msg_head.magic[0], tee_msg_head.magic[1],
+			tee_msg_head.magic[2], tee_msg_head.magic[3],
+			tee_msg_head.msg_sz,
+			*((uint32_t *) (tee_msg_head.tee_msg) + 8), msg_flag);
+		#endif /* 0 */
+
+		tee_msg_recv_head = tee_msg_head.tee_msg;
+		tee_cm_recv_data((uint8_t *)tee_msg_recv_head);
+
+		tee_msgm_handle = tee_msgm_create_inst();
+		tee_msgm_set_msg_buf(tee_msgm_handle, NULL,
+					(uint8_t *)tee_msg_recv_head +
+					sizeof(tee_msg_head_t), NULL);
+		tee_msgm_get_cmd(tee_msgm_handle, &tee_msg_cmd, NULL);
+		if (tee_msg_cmd == TEE_CMD_CAN_OP) {
+			osa_destroy_sem(tee_msg_recv_head->comp);
+			osa_kmem_free(tee_msg_recv_head);
+		} else {
+
+			osa_release_sem(tee_msg_recv_head->comp);
+		}
+		tee_msgm_destroy_inst(tee_msgm_handle);
+	} else if (msg_flag == TEE_MSG_FAKE) {
+		/* delete fake msg from comm channel */
+		tee_msg_head_t tee_msg_head_for_fake_msg;
+
+		tee_cm_recv_data((uint8_t *)&tee_msg_head_for_fake_msg);
+	}
+	return msg_flag;
+}
+
diff --git a/drivers/marvell/security/marvelltee/src/main/marvelltee_pt_core.h b/drivers/marvell/security/marvelltee/src/main/marvelltee_pt_core.h
new file mode 100644
index 0000000..24a4677
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/main/marvelltee_pt_core.h
@@ -0,0 +1,29 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+
+#ifndef _MARVELLTEE_PT_CORE_H_
+#define _MARVELLTEE_PT_CORE_H_
+
+#define TEE_MSG_NORMAL              (0x00000000)
+#define TEE_MSG_FAKE                (0x00000001)
+#define TEE_MSG_IGNORE_COUNTER      (0x00000002)
+
+void marvelltee_pt_send(tee_msg_head_t *tee_msg_send_head);
+uint32_t marvelltee_pt_recv(void);
+
+#endif /* _MARVELLTEE_PT_CORE_H_ */
diff --git a/drivers/marvell/security/marvelltee/src/main/marvelltee_sstd.h b/drivers/marvell/security/marvelltee/src/main/marvelltee_sstd.h
new file mode 100644
index 0000000..e7d88a8
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/main/marvelltee_sstd.h
@@ -0,0 +1,23 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+#ifndef _MARVELLTEE_SSTD_H_
+#define _MARVELLTEE_SSTD_H_
+
+#define MRVL_LOGIN_APPLICATION_DAEMON    (0x80000000)
+
+#endif /* _MARVELLTEE_SSTD_H_ */
diff --git a/drivers/marvell/security/marvelltee/src/main/teec_cb.c b/drivers/marvell/security/marvelltee/src/main/teec_cb.c
new file mode 100644
index 0000000..996b720
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/main/teec_cb.c
@@ -0,0 +1,365 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+
+#include "teec_types.h"
+#include "tee_cb_common_local.h"
+#include "teec_cb.h"
+#include "osa.h"
+#include "marvelltee_internal.h"
+
+#define INIT_CB_MAGIC(_m)	   do {				\
+				(_m)[0] = 'T';  \
+				(_m)[1] = 'e';  \
+				(_m)[2] = 'C';  \
+				(_m)[3] = 'b';  \
+			} while (0)
+#define CLEANUP_CB_MAGIC(_m)   do {				 \
+				(_m)[0] = 0;	\
+				(_m)[1] = 0;	\
+				(_m)[2] = 0;	\
+				(_m)[3] = 0;	\
+			} while (0)
+#define IS_CB_MAGIC_VALID(_m)   (('T' == (_m)[0]) && \
+				('e' == (_m)[1]) && \
+				('C' == (_m)[2]) && \
+				('b' == (_m)[3]))
+
+#define TEE_CB_DBG
+
+#ifdef TEE_CB_DBG
+#define _teec_cb_err_log(_f, _a...) osa_dbg_print(DBG_ERR, _f, ##_a)
+#define _teec_cb_dbg_log(_f, _a...) osa_dbg_print(DBG_INFO, _f, ##_a)
+#else /* !TEE_CB_DBG */
+#define _teec_cb_dbg_log(_f, _a...)
+#endif /* TEE_CB_DBG */
+
+typedef struct __teec_cb_struct_t {
+	/* mgmt */
+	uint8_t		 magic[4];
+	osa_list_t	  node;
+	osa_mutex_t	 lock;
+	osa_mutex_t	 ready;  /* create/destroy by api, post by worker */
+	teec_cb_stat_t  err;	/* returned by worker to api when init-ing */
+	bool			stop;   /* stop flag */
+
+	/* data xchg */
+	void			*shm;   /* set in worker */
+
+	/* data */
+	teec_cb_uuid_t  uuid;
+	teec_cb_fn_t	func;
+	teec_cb_cntx_t  cntx;
+	osa_thread_t	worker;
+} _teec_cb_struct_t;
+
+static TEEC_Context _g_cb_cntx; /* no lock */
+
+static OSA_LIST(_g_cb_list);
+static osa_mutex_t _g_cb_list_lock;
+
+static const TEEC_UUID _g_cb_uuid = TEE_CB_SRV_UUID;
+
+static void _teec_cb_worker(void *arg)
+{
+	_teec_cb_struct_t   *cb;
+	bool				is_stop;
+
+	TEEC_SharedMemory   shm;
+	TEEC_Session		ss;
+	TEEC_Operation	  op;
+	TEEC_Result		 res;
+
+	osa_err_t		   err;
+	teec_cb_stat_t	  ret;
+
+	OSA_ASSERT(arg);
+	cb = (_teec_cb_struct_t *)arg;
+	OSA_ASSERT(IS_CB_MAGIC_VALID(cb->magic));
+
+	memset(&shm, 0, sizeof(TEEC_SharedMemory));
+	shm.buffer = NULL;
+	shm.size = TEE_CB_SHM_MAX_SZ;
+	shm.flags = TEEC_MEM_INPUT | TEEC_MEM_OUTPUT;
+	res = TEEC_AllocateSharedMemory(&_g_cb_cntx, &shm);
+	if (res) {
+	_teec_cb_err_log("ERROR - alloc shm err = 0x%08x in %s\n",
+		res, __func__);
+	cb->err = res;
+	osa_release_mutex(cb->ready);
+	return;
+	}
+
+	/*
+	* open-ss:
+	* +-----------+--------+------+------+
+	* | tmpRefMem | memRef | none | none |
+	* |  cb_uuid  |  args  |	  |	  |
+	* +-----------+--------+------+------+
+	*/
+	memset(&op, 0, sizeof(TEEC_Operation));
+	op.paramTypes = TEEC_PARAM_TYPES(
+		TEEC_MEMREF_TEMP_INPUT, TEEC_MEMREF_WHOLE, TEEC_NONE, TEEC_NONE);
+	op.params[0].tmpref.buffer = &cb->uuid;
+	op.params[0].tmpref.size = sizeof(teec_cb_uuid_t);
+	op.params[1].memref.parent = &shm;
+	op.params[1].memref.size = TEE_CB_SHM_MAX_SZ;
+	op.params[1].memref.offset = 0;
+
+	res = TEEC_OpenSession(&_g_cb_cntx, &ss,
+		&_g_cb_uuid, MRVL_LOGIN_APPLICATION_DAEMON,
+		NULL, &op, NULL);
+	if (res) {
+		_teec_cb_err_log("ERROR - open ss err = 0x%08x in %s\n", res, __func__);
+		TEEC_ReleaseSharedMemory(&shm);
+		cb->err = res;
+		osa_release_mutex(cb->ready);
+		return;
+	}
+
+	/* release reg-api */
+	cb->err = TEEC_SUCCESS;
+
+	/* *BEFORE* releasing cb->ready, cb->lock is a must */
+
+	err = osa_wait_for_mutex(cb->lock, INFINITE);
+	OSA_ASSERT(err == OSA_OK);
+
+	osa_release_mutex(cb->ready);
+
+	/* now ready to trap in tw */
+	ret = TEEC_SUCCESS;
+	while (1) {
+		is_stop = cb->stop;
+		/*
+		* inv-op:
+		* +-------+------+------+------+
+		* | val.a | none | none | none |
+		* |  ret  |	  |	  |	  |
+		* | val.b |	  |	  |	  |
+		* |  ctrl |	  |	  |	  |
+		* +-------+------+------+------+
+		*/
+		memset(&op, 0, sizeof(TEEC_Operation));
+		op.paramTypes = TEEC_PARAM_TYPES(
+			TEEC_VALUE_INOUT, TEEC_NONE, TEEC_NONE, TEEC_NONE);
+			op.params[0].value.a = ret;
+		if (is_stop)
+			op.params[0].value.b = TEE_CB_CTRL_BIT_DYING; /* stop-flag */
+
+		osa_release_mutex(cb->lock);
+
+		res = TEEC_InvokeCommand(&ss, TEE_CB_FETCH_REQ, &op, NULL);
+		OSA_ASSERT(res == TEEC_SUCCESS);
+
+		err = osa_wait_for_mutex(cb->lock, INFINITE);
+		OSA_ASSERT(err == OSA_OK);
+
+		/*
+		* NOTE
+		* here comes is_stop rather than cp->stop
+		* we need to let tw know stop-flag first
+		* so tw-callers will not hang
+		*/
+		if (!is_stop && res) {
+		/* FIXME how to handle this err? */
+		continue;
+		}
+
+		if (!is_stop) {
+			if (!(TEE_CB_CTRL_BIT_FAKE & op.params[0].value.b)) {
+				/* functionality flow */
+				if (TEE_CB_IS_ARG_NULL(((tee_cb_arg_t *)shm.buffer)->nbytes))
+					ret = cb->func(NULL, cb->cntx);
+				else
+					ret = cb->func(shm.buffer, cb->cntx);
+			} else
+				/* no real call for fake ntw-calling */
+				ret = TEEC_SUCCESS;
+		} else {
+			/* for real exit*/
+			osa_release_mutex(cb->lock);
+			break;
+		}
+	}
+
+	TEEC_CloseSession(&ss);
+	TEEC_ReleaseSharedMemory(&shm);
+}
+
+teec_cb_handle_t teec_reg_cb(const teec_cb_uuid_t *uuid,
+	teec_cb_fn_t func, teec_cb_cntx_t cntx)
+{
+	_teec_cb_struct_t	   *cb;
+	osa_list_t			  *entry;
+	bool					found = false;
+	struct osa_thread_attr  attr;
+	osa_err_t			   err;
+
+	if ((uuid == NULL) || (func == NULL)) {
+		_teec_cb_err_log("ERROR - invalid param(s) in %s\n", __func__);
+		return NULL;
+	}
+
+	err = osa_wait_for_mutex(_g_cb_list_lock, INFINITE);
+	OSA_ASSERT(err == OSA_OK);
+
+	osa_list_iterate(&_g_cb_list, entry) {
+		OSA_LIST_ENTRY(entry, _teec_cb_struct_t, node, cb);
+		if (!memcmp(uuid, &cb->uuid, sizeof(teec_cb_uuid_t))) {
+			found = true;
+			break;
+		}
+	}
+
+	if (found) {
+		osa_release_mutex(_g_cb_list_lock);
+		_teec_cb_err_log("ERROR - uuid has been reg-ed in %s\n", __func__);
+		return NULL;
+	}
+
+	cb = osa_kmem_alloc(sizeof(_teec_cb_struct_t));
+	OSA_ASSERT(cb);
+
+	INIT_CB_MAGIC(cb->magic);
+	memcpy(&cb->uuid, uuid, sizeof(teec_cb_uuid_t));
+	cb->func = func;
+	cb->cntx = cntx;
+	cb->lock = osa_create_mutex();
+	OSA_ASSERT(cb->lock);
+	cb->ready = osa_create_mutex_locked();
+	OSA_ASSERT(cb->ready);
+	cb->stop = false;
+	attr.name = "tee-cb";
+	attr.prio = 0;			 /* highest prio */
+	attr.stack_addr = NULL;	/* not used */
+	attr.stack_size = 0;	   /* not used */
+	attr.flags = OSA_PF_FREEZER_SKIP;
+	cb->worker = osa_create_thread(_teec_cb_worker, cb, &attr);
+	OSA_ASSERT(cb->worker);
+
+	err = osa_wait_for_mutex(cb->ready, INFINITE);
+	OSA_ASSERT(err == OSA_OK);
+
+	if (cb->err) {
+		/* cb is not available so safe to free list-lock */
+		osa_release_mutex(_g_cb_list_lock);
+
+		/* free res, no lock req */
+		osa_destroy_thread(cb->worker);
+		osa_destroy_mutex(cb->ready);
+		osa_destroy_mutex(cb->lock);
+		CLEANUP_CB_MAGIC(cb->magic);
+		osa_kmem_free(cb);
+
+		return NULL;
+	}
+
+	osa_list_add(&cb->node, &_g_cb_list);
+	osa_release_mutex(_g_cb_list_lock);
+	return (teec_cb_handle_t)cb;
+}
+EXPORT_SYMBOL(teec_reg_cb);
+
+void teec_unreg_cb(teec_cb_handle_t handle)
+{
+	_teec_cb_struct_t   *cb;
+	TEEC_Session		ss;
+	TEEC_Operation	  op;
+	TEEC_Result		 res;
+	osa_err_t		   err;
+
+	if (handle == NULL) {
+		_teec_cb_err_log("ERROR - invalid param(s) in %s\n", __func__);
+		return;
+	}
+
+	err = osa_wait_for_mutex(_g_cb_list_lock, INFINITE);
+	OSA_ASSERT(err == OSA_OK);
+
+	cb = (_teec_cb_struct_t *)handle;
+	if (!IS_CB_MAGIC_VALID(cb->magic)) {
+		osa_release_mutex(_g_cb_list_lock);
+		_teec_cb_err_log("ERROR - invalid param(s) in %s\n", __func__);
+		return;
+	}
+
+	/* cb lock should be acquired before releasing cb-list-lock */
+	err = osa_wait_for_mutex(cb->lock, INFINITE);
+	OSA_ASSERT(err == OSA_OK);
+	osa_list_del(&cb->node);
+	/* make cb invalid before release list-lock */
+	CLEANUP_CB_MAGIC(cb->magic);
+	/* no cb now, safe to unlick list */
+	osa_release_mutex(_g_cb_list_lock);
+
+	/* set stop */
+	cb->stop = true;
+	osa_release_mutex(cb->lock);
+
+	/*
+	 * open-ss:
+	 * +-----------+------+------+------+
+	 * | tmpRefMem | none | none | none |
+	 * |  cb_uuid  |	  |	  |	  |
+	 * +-----------+------+------+------+
+	 *
+	 * the 2nd param is none for trig-stop ss.
+	 */
+	memset(&op, 0, sizeof(TEEC_Operation));
+	op.paramTypes = TEEC_PARAM_TYPES(
+			TEEC_MEMREF_TEMP_INPUT, TEEC_NONE, TEEC_NONE, TEEC_NONE);
+	op.params[0].tmpref.buffer = &cb->uuid;
+	op.params[0].tmpref.size = sizeof(teec_cb_uuid_t);
+	res = TEEC_OpenSession(&_g_cb_cntx, &ss,
+			&_g_cb_uuid, TEEC_LOGIN_APPLICATION, NULL, &op, NULL);
+	if (res == TEEC_SUCCESS) {
+		(void)TEEC_InvokeCommand(&ss, TEE_CB_TRIGGER_STOP, NULL, NULL);
+		TEEC_CloseSession(&ss);
+	} else {
+		/* FIXME - may hang here, no solution */
+	}
+
+	/* free res */
+	osa_destroy_thread(cb->worker);
+	osa_destroy_mutex(cb->ready);
+	osa_destroy_mutex(cb->lock);
+	osa_kmem_free(cb);
+}
+EXPORT_SYMBOL(teec_unreg_cb);
+
+teec_cb_stat_t teec_cb_module_init(void)
+{
+	TEEC_Result res = TEEC_InitializeContext(NULL, &_g_cb_cntx);
+
+	if (res) {
+		_teec_cb_err_log("ERROR - init cntx err = 0x%08x in %s\n",
+				res, __func__);
+		return res;
+	}
+	_g_cb_list_lock = osa_create_mutex();
+	OSA_ASSERT(_g_cb_list_lock);
+	return TEEC_SUCCESS;
+}
+
+void teec_cb_module_cleanup(void)
+{
+	/* we do not cover list-not-empty case */
+	OSA_ASSERT(osa_list_empty(&_g_cb_list));
+	osa_destroy_mutex(_g_cb_list_lock);
+	TEEC_FinalizeContext(&_g_cb_cntx);
+}
diff --git a/drivers/marvell/security/marvelltee/src/main/teec_cb_local.h b/drivers/marvell/security/marvelltee/src/main/teec_cb_local.h
new file mode 100644
index 0000000..90ca398
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/main/teec_cb_local.h
@@ -0,0 +1,33 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+
+#ifndef __TEEC_CB_LOCAL_H__
+#define __TEEC_CB_LOCAL_H__
+
+#include "teec_cb.h"
+
+/*
+ * below UUIDs are used internal.
+ * FF000000 0000 0000 00 00 00 00 00 00 00 01: TW time APIs
+ * FF000001 xxxx xxxx xx xx xx xx xx xx xx xx: SHD
+ */
+
+teec_cb_stat_t teec_cb_module_init(void);
+void teec_cb_module_cleanup(void);
+
+#endif /* __TEEC_CB_LOCAL_H__ */
diff --git a/drivers/marvell/security/marvelltee/src/main/teec_client_api.c b/drivers/marvell/security/marvelltee/src/main/teec_client_api.c
new file mode 100644
index 0000000..1734fe2
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/main/teec_client_api.c
@@ -0,0 +1,1459 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+#ifndef CONFIG_MINI_MARVELLTEE
+#include "marvelltee_internal.h"
+#else
+#include "mini_marvelltee_internal.h"
+#endif
+
+#define INIT_MAGIC(_n)  \
+	do {                \
+		((uint8_t *)_n)[0] = 'T';   \
+		((uint8_t *)_n)[1] = 'Z';   \
+		((uint8_t *)_n)[2] = 'D';   \
+		((uint8_t *)_n)[3] = 'D';   \
+	} while (0)
+
+#define IS_MAGIC_VALID(_n) \
+	(('T' == ((uint8_t *)_n)[0]) && \
+	('Z' == ((uint8_t *)_n)[1]) && \
+	('D' == ((uint8_t *)_n)[2]) && \
+	('D' == ((uint8_t *)_n)[3]))
+
+#define CLEANUP_MAGIC(_n) \
+	do {                            \
+		((uint8_t *)_n)[0] = '\0';  \
+		((uint8_t *)_n)[1] = '\0';  \
+		((uint8_t *)_n)[2] = '\0';  \
+		((uint8_t *)_n)[3] = '\0';  \
+	} while (0)
+
+#ifndef CONFIG_64BIT
+#define INIT_MSG_MAGIC(_m)  \
+	do {                \
+		_m[0] = 'M';    \
+		_m[1] = 's';    \
+		_m[2] = 'G';    \
+		_m[3] = 'm';    \
+	} while (0)
+#define IS_MSG_MAGIC_VALID(_m) \
+	(('M' == _m[0]) &&  \
+	 ('s' == _m[1]) &&  \
+	 ('G' == _m[2]) &&  \
+	 ('m' == _m[3]))
+#else
+#define INIT_MSG_MAGIC(_m)  \
+	do {                \
+		_m[0] = 'M';    \
+		_m[1] = 'g';    \
+		_m[2] = '6';    \
+		_m[3] = '4';    \
+	} while (0)
+#define IS_MSG_MAGIC_VALID(_m) \
+	(('M' == _m[0]) &&  \
+	('g' == _m[1]) &&  \
+	('6' == _m[2]) &&  \
+	('4' == _m[3]))
+#endif
+#define CLEANUP_MSG_MAGIC(_m)  \
+	do {                \
+		_m[0] = 0;    \
+		_m[1] = 0;    \
+		_m[2] = 0;    \
+		_m[3] = 0;    \
+	} while (0)
+
+#define CA_AOLLC_BUF    (1)
+#define DRV_AOLLC_BUF   (2)
+
+#define NO_SET          (0)
+#define INC_ATOMIC      (1)
+#define DEC_ATOMIC      (2)
+
+#define OP_PARAM_NUM    (4)
+
+#define MRVL_LOGIN_APPLICATION_SS	(0x80000001)
+
+static TEEC_Result _set_sharedMem_atomic(
+					tee_impl tee_ctx_ntw,
+					TEEC_Operation *operation,
+					uint32_t set_atomic_flag)
+{
+	uint32_t param_types;
+	uint32_t i, tmp;
+	_TEEC_MRVL_SharedMemory *_teec_mrvl_sharedMem;
+
+	param_types = operation->paramTypes;
+
+	for (i = 0; i < OP_PARAM_NUM; i++) {
+		tmp = TEEC_PARAM_TYPE_GET(param_types, i);
+		if (tmp == TEEC_NONE) {
+			continue;
+		} else {
+			switch (tmp) {
+			case TEEC_MEMREF_WHOLE:
+			case TEEC_MEMREF_PARTIAL_INPUT:
+			case TEEC_MEMREF_PARTIAL_OUTPUT:
+			case TEEC_MEMREF_PARTIAL_INOUT:
+				{
+					TEEC_RegisteredMemoryReference memref;
+
+					memref = operation->params[i].memref;
+					if (!memref.parent)
+						OSA_ASSERT(0);
+
+					_teec_mrvl_sharedMem =
+						(_TEEC_MRVL_SharedMemory *)
+						(memref.parent->imp);
+					if (!(IS_MAGIC_VALID(
+						_teec_mrvl_sharedMem->magic)))
+						OSA_ASSERT(0);
+#ifdef SHAREDMEM_CONTEXT_CHECKING
+					if (_teec_mrvl_sharedMem->tee_ctx_ntw !=
+						tee_ctx_ntw)
+						return TEEC_ERROR_BAD_PARAMETERS;
+#endif
+					if (set_atomic_flag == INC_ATOMIC)
+						osa_atomic_inc(
+						&(_teec_mrvl_sharedMem->count));
+					else if (set_atomic_flag == DEC_ATOMIC)
+						osa_atomic_dec(
+						&(_teec_mrvl_sharedMem->count));
+				}
+				break;
+			default:
+				break;
+			}
+		}
+
+	}
+
+	return TEEC_SUCCESS;
+}
+
+static tee_msg_head_t *_init_msg_head(uint8_t *tee_msg_buf, uint32_t buf_size)
+{
+	tee_msg_head_t *tee_msg_head = (tee_msg_head_t *)tee_msg_buf;
+
+	INIT_MSG_MAGIC(tee_msg_head->magic);
+	tee_msg_head->msg_sz = buf_size;
+	tee_msg_head->msg_prop.value = 0;
+	tee_msg_head->msg_prop.bp.stat = TEE_MSG_STAT_REQ;
+	tee_msg_head->caller_uuid = 0xFFFFFFFF;
+	tee_msg_head->tee_msg = (void *)tee_msg_buf;
+	tee_msg_head->comp = osa_create_sem(0);
+	tee_msg_head->reserved = NULL;
+
+	return tee_msg_head;
+}
+
+static TEEC_Result _teec_map_memory(
+		TEEC_Context *context,
+		TEEC_SharedMemory *sharedMem,
+		tee_get_ret_map_shm_arg_t *tee_get_ret)
+{
+	tee_msgm_t tee_msgm_handle;
+	tee_cmd_t tee_msg_cmd;
+	tee_set_cmd_map_shm_arg_t tee_msg_set_cmd_map_shm_arg;
+	tee_stat_t tee_msg_stat;
+	uint32_t buf_size;
+	tee_msgm_msg_info_t tee_msg_info;
+
+	uint8_t *tee_msg_buf;
+	tee_msg_head_t *tee_msg_head;
+
+	/* prepare the request, create the msg and add it to the msgQ */
+	tee_msgm_handle = tee_msgm_create_inst();
+	if (!tee_msgm_handle)
+		OSA_ASSERT(0);
+
+	tee_msg_info.cmd = TEE_CMD_MAP_SHM;
+	tee_msg_info.msg_map_shm_info = sharedMem;
+	tee_msg_info.msg_op_info = NULL;
+
+	/* Get buffer size */
+	tee_msg_stat =
+		tee_msgm_set_msg_buf(tee_msgm_handle, &tee_msg_info, NULL,
+				&buf_size);
+	if (tee_msg_stat != TEEC_SUCCESS)
+		OSA_ASSERT(0);
+
+	tee_msg_buf = osa_kmem_alloc(sizeof(tee_msg_head_t) + buf_size);
+	if (!tee_msg_buf) {
+		tee_msgm_destroy_inst(tee_msgm_handle);
+		return TEEC_ERROR_OUT_OF_MEMORY;
+	}
+
+	/* give the buffer to Msgm */
+	tee_msg_stat =
+		tee_msgm_set_msg_buf(tee_msgm_handle, NULL,
+				tee_msg_buf + sizeof(tee_msg_head_t),
+				&buf_size);
+	if (tee_msg_stat != TEEC_SUCCESS)
+		OSA_ASSERT(0);
+
+	/* init head_t */
+	tee_msg_head = _init_msg_head(tee_msg_buf, buf_size);
+
+	/* set cmd body */
+	tee_msg_cmd = TEE_CMD_MAP_SHM;
+	tee_msg_set_cmd_map_shm_arg.cntx = (ulong_t)context;
+	tee_msg_set_cmd_map_shm_arg.shm = sharedMem;
+
+	tee_msg_stat =
+		tee_msgm_set_cmd(tee_msgm_handle, tee_msg_cmd,
+				&tee_msg_set_cmd_map_shm_arg);
+	if (tee_msg_stat != TEEC_SUCCESS)
+		OSA_ASSERT(0);
+
+	/* pt-in/wait for response */
+	marvelltee_call_tw(tee_msg_head);
+
+	/* deal with the response */
+	if (!(IS_MSG_MAGIC_VALID(tee_msg_head->magic)))
+		OSA_ASSERT(0);
+
+	/* Get return */
+	tee_msg_stat = tee_msgm_get_ret(tee_msgm_handle, (void *)tee_get_ret);
+	if (tee_msg_stat != TEEC_SUCCESS)
+		OSA_ASSERT(0);
+
+	osa_kmem_free(tee_msg_buf);
+	tee_msgm_destroy_inst(tee_msgm_handle);
+
+	return tee_msg_stat;
+}
+
+#ifndef CONFIG_MINI_MARVELLTEE
+static uid_t _get_current_uid(void)
+{
+	kuid_t uid;
+
+	uid = current_uid();
+
+	return __kuid_val(uid);
+}
+
+static uid_t _get_current_gid(void)
+{
+	kgid_t gid;
+
+	gid = current_gid();
+
+	return __kgid_val(gid);
+}
+
+static uid_t _get_current_euid(void)
+{
+	kuid_t euid;
+
+	euid = current_euid();
+
+	return __kuid_val(euid);
+}
+#endif
+
+static void _teec_generate_connection_data(uint32_t connectionMethod,
+		tee_set_cmd_open_ss_arg_t *tee_msg_set_cmd_open_ss_arg)
+{
+	tee_msg_set_cmd_open_ss_arg->meth = connectionMethod;
+
+	switch (connectionMethod) {
+	case TEEC_LOGIN_PUBLIC:
+		{
+			memset(&(tee_msg_set_cmd_open_ss_arg->data), 0,
+				sizeof(TEEC_UUID));
+		}
+		break;
+	case TEEC_LOGIN_USER:
+		{
+			uid_t uid;
+
+			uid = _get_current_uid();
+			memset(&(tee_msg_set_cmd_open_ss_arg->data), 0,
+				sizeof(TEEC_UUID));
+			tee_msg_set_cmd_open_ss_arg->data.timeLow = uid;
+		}
+		break;
+	case TEEC_LOGIN_GROUP:
+		{
+			gid_t gid;
+
+			gid = _get_current_gid();
+			memset(&(tee_msg_set_cmd_open_ss_arg->data), 0,
+				sizeof(TEEC_UUID));
+			tee_msg_set_cmd_open_ss_arg->data.timeLow = gid;
+		}
+		break;
+	case TEEC_LOGIN_APPLICATION:
+		{
+			uid_t euid;
+
+			euid = _get_current_euid();
+			memset(&(tee_msg_set_cmd_open_ss_arg->data), 0,
+				sizeof(TEEC_UUID));
+			tee_msg_set_cmd_open_ss_arg->data.timeLow = euid;
+		}
+		break;
+	case TEEC_LOGIN_USER_APPLICATION:
+		{
+			uid_t uid;
+			uid_t euid;
+
+			uid = _get_current_uid();
+			euid = _get_current_euid();
+
+			memset(&(tee_msg_set_cmd_open_ss_arg->data), 0,
+				sizeof(TEEC_UUID));
+			tee_msg_set_cmd_open_ss_arg->data.timeLow =
+				(uid << 16 | euid);
+		}
+		break;
+	case TEEC_LOGIN_GROUP_APPLICATION:
+		{
+			gid_t gid;
+			uid_t euid;
+
+			gid = _get_current_gid();
+			euid = _get_current_euid();
+
+			memset(&(tee_msg_set_cmd_open_ss_arg->data), 0,
+				sizeof(TEEC_UUID));
+			tee_msg_set_cmd_open_ss_arg->data.timeLow =
+				(gid << 16 | euid);
+		}
+		break;
+#ifndef CONFIG_MINI_MARVELLTEE
+	case MRVL_LOGIN_APPLICATION_DAEMON:
+		{
+			memset(&(tee_msg_set_cmd_open_ss_arg->data), 0,
+				sizeof(TEEC_UUID));
+			/* add more in the future */
+		}
+		break;
+#endif
+	case MRVL_LOGIN_APPLICATION_SS:
+		{
+			uid_t uid;
+
+			uid = _get_current_uid();
+			memset(&(tee_msg_set_cmd_open_ss_arg->data), 0,
+				sizeof(TEEC_UUID));
+			tee_msg_set_cmd_open_ss_arg->data.timeLow = uid;
+		}
+		break;
+	default:
+		/* never be here */
+		OSA_ASSERT(0);
+		break;
+	}
+}
+
+TEEC_Result TEEC_InitializeContext(const char *name, TEEC_Context *context)
+{
+	_TEEC_MRVL_Context *_teec_mrvl_context;
+
+#ifdef TEE_PERF_MEASURE
+	/* Since performance measure is base on core level PMU registers.
+	 * So we put all processors on core 0, the same core as PT.
+	 */
+	set_cpus_allowed_ptr(current, cpumask_of(0));
+#endif
+
+	if (name && (osa_memcmp(name, DEVICE_NAME, DEVICE_NAME_SIZE))) {
+		MARVELLTEE_DBG("ERROR - invalid name: %s\n", name);
+		return TEEC_ERROR_BAD_PARAMETERS;
+	}
+
+	if (!context) {
+		MARVELLTEE_DBG("ERROR -invalid parameter: cntx = NULL\n");
+		return TEEC_ERROR_BAD_PARAMETERS;
+	}
+
+	context->imp = osa_kmem_alloc(sizeof(_TEEC_MRVL_Context));
+	if (!(context->imp)) {
+		MARVELLTEE_DBG("ERROR - failed to alloc mem for cntx->imp\n");
+		return TEEC_ERROR_OUT_OF_MEMORY;
+	}
+
+	_teec_mrvl_context = (_TEEC_MRVL_Context *) (context->imp);
+	INIT_MAGIC(_teec_mrvl_context->magic);
+
+	osa_atomic_set(&(_teec_mrvl_context->count), 0);
+	_teec_mrvl_context->tee_ctx_ntw = context;
+
+	tee_prepare_record_time();
+
+	return TEEC_SUCCESS;
+}
+EXPORT_SYMBOL(TEEC_InitializeContext);
+
+void TEEC_FinalizeContext(TEEC_Context *context)
+{
+	int32_t count;
+	_TEEC_MRVL_Context *_teec_mrvl_context;
+
+	if (!context) {
+		MARVELLTEE_DBG("ERROR - invalid cntx\n");
+		return;
+	}
+
+	tee_finish_record_time();
+
+	_teec_mrvl_context = (_TEEC_MRVL_Context *) (context->imp);
+
+	if (!(IS_MAGIC_VALID(_teec_mrvl_context->magic))) {
+		MARVELLTEE_DBG("ERROR - invalid cntx magic = %02x%02x%02x%02x\n",
+				_teec_mrvl_context->magic[0],
+				_teec_mrvl_context->magic[1],
+				_teec_mrvl_context->magic[2],
+				_teec_mrvl_context->magic[3]);
+		OSA_ASSERT(0);
+	}
+
+	CLEANUP_MAGIC(_teec_mrvl_context->magic);
+
+	count = osa_atomic_read(&(_teec_mrvl_context->count));
+	if (count != 0) {
+		MARVELLTEE_DBG("ERROR - invalid count in cntx, %d\n", count);
+		OSA_ASSERT(0);
+	}
+
+	osa_kmem_free(context->imp);
+}
+EXPORT_SYMBOL(TEEC_FinalizeContext);
+
+TEEC_Result TEEC_RegisterSharedMemory(TEEC_Context *context,
+					TEEC_SharedMemory *sharedMem)
+{
+	TEEC_Result tee_result = TEEC_SUCCESS;
+	TEEC_Result tee_msg_stat;
+	_TEEC_MRVL_Context *_teec_mrvl_context;
+	_TEEC_MRVL_SharedMemory *_teec_mrvl_sharedMem;
+
+	tee_get_ret_map_shm_arg_t tee_get_ret;
+
+	if (!context || !sharedMem || (!sharedMem->buffer && sharedMem->size)) {
+		MARVELLTEE_DBG("ERROR - invalid param, 0x%016llx, 0x%016llx,",
+				(marvelltee_size_t)context, sharedMem);
+		if (sharedMem)
+			MARVELLTEE_DBG(" 0x%64llx 0x%08x\n", (marvelltee_size_t)sharedMem->buffer, sharedMem->size);
+		else
+			MARVELLTEE_DBG(" 0x--------\n");
+		return TEEC_ERROR_BAD_PARAMETERS;
+	}
+
+	if ((sharedMem->flags != TEEC_MEM_INPUT) &&
+		(sharedMem->flags != TEEC_MEM_OUTPUT) &&
+		(sharedMem->flags != (TEEC_MEM_INPUT | TEEC_MEM_OUTPUT))) {
+		MARVELLTEE_DBG("ERROR - invalid flag, 0x%08x\n", sharedMem->flags);
+		return TEEC_ERROR_BAD_PARAMETERS;
+	}
+
+	_teec_mrvl_context = (_TEEC_MRVL_Context *)(context->imp);
+
+	if (!(IS_MAGIC_VALID(_teec_mrvl_context->magic))) {
+		MARVELLTEE_DBG("ERROR - invalid cntx magic = %02x%02x%02x%02x\n",
+				_teec_mrvl_context->magic[0],
+				_teec_mrvl_context->magic[1],
+				_teec_mrvl_context->magic[2],
+				_teec_mrvl_context->magic[3]);
+		return TEEC_ERROR_BAD_PARAMETERS;
+	}
+
+	if (sharedMem->size >= TEEC_CONFIG_SHAREDMEM_MAX_SIZE) {
+		MARVELLTEE_DBG("ERROR - memory chunk to share is too large: 0x%08x",
+				sharedMem->size);
+		return TEEC_ERROR_OUT_OF_MEMORY;
+	}
+
+	osa_atomic_inc(&(_teec_mrvl_context->count));
+
+	sharedMem->imp = osa_kmem_alloc(sizeof(_TEEC_MRVL_SharedMemory));
+	if (!(sharedMem->imp)) {
+		MARVELLTEE_DBG("ERROR - failed to alloc sharedMem->imp");
+		return TEEC_ERROR_OUT_OF_MEMORY;
+	}
+
+	_teec_mrvl_sharedMem = (_TEEC_MRVL_SharedMemory *) (sharedMem->imp);
+	_teec_mrvl_sharedMem->tee_ctx_ntw = &(context->imp);
+	_teec_mrvl_sharedMem->flag = CA_AOLLC_BUF;
+	osa_atomic_set(&(_teec_mrvl_sharedMem->count), 0);
+
+	if (sharedMem->size != 0) {
+		tee_msg_stat = _teec_map_memory(context, sharedMem, &tee_get_ret);
+		if (tee_msg_stat != TEEC_SUCCESS) {
+			MARVELLTEE_DBG("ERROR - _teec_map_memory failed, 0x%08x\n", tee_msg_stat);
+			OSA_ASSERT(0);
+		}
+
+		_teec_mrvl_sharedMem->vaddr_tw = tee_get_ret.vaddr_tw;
+		tee_result = tee_get_ret.ret;
+	} else {
+		_teec_mrvl_sharedMem->vaddr_tw = NULL;
+		tee_result = TEEC_SUCCESS;
+	}
+
+	INIT_MAGIC(_teec_mrvl_sharedMem->magic);
+
+	if (tee_result != TEEC_SUCCESS) {
+		osa_atomic_dec(&(_teec_mrvl_context->count));
+		MARVELLTEE_DBG("ERROR - _teec_map_memory failed, 0x%08x\n", tee_result);
+	}
+
+	return tee_result;
+}
+EXPORT_SYMBOL(TEEC_RegisterSharedMemory);
+
+TEEC_Result TEEC_AllocateSharedMemory(TEEC_Context *context,
+					TEEC_SharedMemory *sharedMem)
+{
+	TEEC_Result tee_result = TEEC_SUCCESS;
+	TEEC_Result tee_msg_stat;
+	_TEEC_MRVL_Context *_teec_mrvl_context;
+	_TEEC_MRVL_SharedMemory *_teec_mrvl_sharedMem;
+
+	tee_get_ret_map_shm_arg_t tee_get_ret;
+
+	if (!sharedMem) {
+		MARVELLTEE_DBG("ERROR - invalid sharedMem\n");
+		return TEEC_ERROR_BAD_PARAMETERS;
+	}
+
+	if (!context) {
+		MARVELLTEE_DBG("ERROR - invalid context\n");
+		sharedMem->buffer = NULL;
+		return TEEC_ERROR_BAD_PARAMETERS;
+	}
+
+	if ((sharedMem->flags != TEEC_MEM_INPUT) &&
+		(sharedMem->flags != TEEC_MEM_OUTPUT) &&
+		(sharedMem->flags != (TEEC_MEM_INPUT | TEEC_MEM_OUTPUT))) {
+		sharedMem->buffer = NULL;
+		MARVELLTEE_DBG("ERROR - invalid flags, 0x%08x\n", sharedMem->flags);
+		return TEEC_ERROR_BAD_PARAMETERS;
+	}
+
+	_teec_mrvl_context = (_TEEC_MRVL_Context *) (context->imp);
+
+	if (!(IS_MAGIC_VALID(_teec_mrvl_context->magic))) {
+		MARVELLTEE_DBG("ERROR - invalid cntx magic = %02x%02x%02x%02x\n",
+				_teec_mrvl_context->magic[0],
+				_teec_mrvl_context->magic[1],
+				_teec_mrvl_context->magic[2],
+				_teec_mrvl_context->magic[3]);
+		sharedMem->buffer = NULL;
+		return TEEC_ERROR_BAD_PARAMETERS;
+	}
+
+	if (sharedMem->size >= TEEC_CONFIG_SHAREDMEM_MAX_SIZE) {
+		sharedMem->buffer = NULL;
+		MARVELLTEE_DBG("ERROR - memory chunk to share is too large: 0x%08x",
+				sharedMem->size);
+		return TEEC_ERROR_BAD_PARAMETERS;
+	}
+
+	if (sharedMem->size) {
+		sharedMem->buffer = osa_kmem_alloc(sharedMem->size);
+		if (!sharedMem->buffer) {
+			MARVELLTEE_DBG("ERROR - failed to alloc mem for shardMem->buffer, %d\n",
+					sharedMem->size);
+			return TEEC_ERROR_OUT_OF_MEMORY;
+		}
+	} else {
+		sharedMem->buffer = NULL;
+	}
+
+	osa_atomic_inc(&(_teec_mrvl_context->count));
+
+	sharedMem->imp = osa_kmem_alloc(sizeof(_TEEC_MRVL_SharedMemory));
+	if (!sharedMem->imp) {
+		MARVELLTEE_DBG("ERROR - failed to alloc sharedMem->imp");
+		return TEEC_ERROR_OUT_OF_MEMORY;
+	}
+
+	_teec_mrvl_sharedMem = (_TEEC_MRVL_SharedMemory *) (sharedMem->imp);
+	_teec_mrvl_sharedMem->tee_ctx_ntw = &(context->imp);
+	_teec_mrvl_sharedMem->flag = DRV_AOLLC_BUF;
+	osa_atomic_set(&(_teec_mrvl_sharedMem->count), 0);
+
+	if (sharedMem->size != 0) {
+		tee_msg_stat = _teec_map_memory(context, sharedMem, &tee_get_ret);
+		if (tee_msg_stat != TEEC_SUCCESS) {
+			MARVELLTEE_DBG("ERROR - _teec_map_memory failed, 0x%08x\n", tee_msg_stat);
+			OSA_ASSERT(0);
+		}
+
+		_teec_mrvl_sharedMem->vaddr_tw = tee_get_ret.vaddr_tw;
+		tee_result = tee_get_ret.ret;
+	} else {
+		_teec_mrvl_sharedMem->vaddr_tw = NULL;
+		tee_result = TEEC_SUCCESS;
+	}
+
+	INIT_MAGIC(_teec_mrvl_sharedMem->magic);
+
+	if (tee_result != TEEC_SUCCESS) {
+		osa_kmem_free(sharedMem->buffer);
+		sharedMem->buffer = NULL;
+		osa_atomic_dec(&(_teec_mrvl_context->count));
+		MARVELLTEE_DBG("ERROR - _teec_map_memory failed, 0x%08x\n", tee_result);
+	}
+
+	return tee_result;
+}
+EXPORT_SYMBOL(TEEC_AllocateSharedMemory);
+
+void TEEC_ReleaseSharedMemory(TEEC_SharedMemory *sharedMem)
+{
+	TEEC_Context *teec_context;
+	int32_t count;
+
+	tee_msgm_t tee_msgm_handle;
+	tee_cmd_t tee_msg_cmd;
+	tee_set_cmd_unmap_shm_arg_t *tee_msg_set_cmd_ummap_shm_arg;
+	tee_stat_t tee_msg_stat;
+	uint32_t buf_size;
+	tee_msgm_msg_info_t tee_msg_info;
+
+	uint8_t *tee_msg_buf;
+	tee_msg_head_t *tee_msg_head;
+	_TEEC_MRVL_Context *_teec_mrvl_context;
+	_TEEC_MRVL_SharedMemory *_teec_mrvl_sharedMem;
+
+	if (!sharedMem) {
+		MARVELLTEE_DBG("ERROR - invalid sharedMem\n");
+		return;
+	}
+
+	_teec_mrvl_sharedMem = (_TEEC_MRVL_SharedMemory *) (sharedMem->imp);
+
+	if (!(IS_MAGIC_VALID(_teec_mrvl_sharedMem->magic))) {
+		MARVELLTEE_DBG("ERROR - invalid shm magic = %02x%02x%02x%02x\n",
+				_teec_mrvl_sharedMem->magic[0],
+				_teec_mrvl_sharedMem->magic[1],
+				_teec_mrvl_sharedMem->magic[2],
+				_teec_mrvl_sharedMem->magic[3]);
+		OSA_ASSERT(0);
+	}
+
+	CLEANUP_MAGIC(_teec_mrvl_sharedMem->magic);
+
+	if (_teec_mrvl_sharedMem->flag == DRV_AOLLC_BUF) {
+		osa_kmem_free(sharedMem->buffer);
+		sharedMem->buffer = NULL;
+		sharedMem->size = 0;
+		sharedMem->flags = 0;
+	} else if (_teec_mrvl_sharedMem->flag == CA_AOLLC_BUF) {
+		/* Do nothing */
+		/* Do not need to free the buffer, it's owned by CA */
+	}
+
+	count = osa_atomic_read(&(_teec_mrvl_sharedMem->count));
+	if (count != 0) {
+		MARVELLTEE_DBG("ERROR - invalid count, %d\n", count);
+		OSA_ASSERT(0);
+	}
+
+	if (sharedMem->size == 0)
+		goto exit;
+
+	/* prepare the request, create the msg and add it to the msgQ */
+	tee_msgm_handle = tee_msgm_create_inst();
+	if (!tee_msgm_handle) {
+		MARVELLTEE_DBG("ERROR - failed to create msgm handle\n");
+		OSA_ASSERT(0);
+	}
+
+	tee_msg_info.cmd = TEE_CMD_UNMAP_SHM;
+	tee_msg_info.msg_map_shm_info = NULL;
+	tee_msg_info.msg_op_info = NULL;
+
+	/* Get buffer size */
+	tee_msg_stat =
+		tee_msgm_set_msg_buf(tee_msgm_handle, &tee_msg_info, NULL,
+				&buf_size);
+	if (tee_msg_stat != TEEC_SUCCESS) {
+		MARVELLTEE_DBG("ERROR - failed to set msg buf, 0x%08x\n", tee_msg_stat);
+		OSA_ASSERT(0);
+	}
+
+	tee_msg_buf = osa_kmem_alloc(sizeof(tee_msg_head_t) + buf_size);
+	if (!tee_msg_buf) {
+		tee_msgm_destroy_inst(tee_msgm_handle);
+		MARVELLTEE_DBG("ERROR - failed to alloc msg buf, %d\n",
+				sizeof(tee_msg_head_t) + buf_size);
+		OSA_ASSERT(0);
+	}
+
+	/* give the buffer to Msgm */
+	tee_msg_stat =
+		tee_msgm_set_msg_buf(tee_msgm_handle, NULL,
+				tee_msg_buf + sizeof(tee_msg_head_t),
+				&buf_size);
+	if (tee_msg_stat != TEEC_SUCCESS) {
+		MARVELLTEE_DBG("ERROR - failed to set msg buf, 0x%08x\n", tee_msg_stat);
+		OSA_ASSERT(0);
+	}
+
+	/* init head_t */
+	tee_msg_head = _init_msg_head(tee_msg_buf, buf_size);
+
+	/* set cmd body */
+	tee_msg_cmd = TEE_CMD_UNMAP_SHM;
+	tee_msg_set_cmd_ummap_shm_arg = sharedMem;
+	tee_msg_stat =
+		tee_msgm_set_cmd(tee_msgm_handle, tee_msg_cmd,
+				tee_msg_set_cmd_ummap_shm_arg);
+	if (tee_msg_stat != TEEC_SUCCESS) {
+		MARVELLTEE_DBG("ERROR - failed to set cmd, 0x%08x\n", tee_msg_stat);
+		OSA_ASSERT(0);
+	}
+
+	marvelltee_call_tw(tee_msg_head);
+
+	tee_msgm_destroy_inst(tee_msgm_handle);
+	osa_kmem_free(tee_msg_buf);
+
+exit:
+	teec_context =
+		container_of(_teec_mrvl_sharedMem->tee_ctx_ntw, TEEC_Context, imp);
+	_teec_mrvl_context = (_TEEC_MRVL_Context *) (teec_context->imp);
+	osa_atomic_dec(&(_teec_mrvl_context->count));
+
+	_teec_mrvl_sharedMem->tee_ctx_ntw = NULL;
+	_teec_mrvl_sharedMem->vaddr_tw = NULL;
+	_teec_mrvl_sharedMem->size = 0;
+	_teec_mrvl_sharedMem->flag = 0;
+
+	osa_kmem_free(sharedMem->imp);
+}
+EXPORT_SYMBOL(TEEC_ReleaseSharedMemory);
+
+TEEC_Result TEEC_OpenSession(TEEC_Context *context,
+				TEEC_Session *session,
+				const TEEC_UUID *destination,
+				uint32_t connectionMethod,
+				const void *connectionData,
+				TEEC_Operation *operation,
+				uint32_t *returnOrigin)
+{
+	TEEC_Result tee_result = TEEC_SUCCESS;
+
+	tee_msgm_t tee_msgm_handle;
+	tee_cmd_t tee_msg_cmd;
+	tee_set_cmd_open_ss_arg_t tee_msg_set_cmd_open_ss_arg;
+	tee_stat_t tee_msg_stat;
+	uint32_t buf_size;
+	tee_msgm_msg_info_t tee_msg_info;
+	tee_get_ret_open_ss_arg_t tee_get_ret;
+
+	uint8_t *tee_msg_buf;
+	tee_msg_head_t *tee_msg_head;
+	_TEEC_MRVL_Context *_teec_mrvl_context;
+	_TEEC_MRVL_Session *_teec_mrvl_session;
+	_TEEC_MRVL_Operation *_teec_mrvl_operation;
+
+	if (!context || !session || !destination) {
+		if (returnOrigin)
+			*returnOrigin = TEEC_ORIGIN_API;
+		MARVELLTEE_DBG("ERROR - invalid param, 0x%016llx, 0x%016llx, 0x%016llx\n",
+				(marvelltee_size_t)context, (marvelltee_size_t)session, (marvelltee_size_t)destination);
+		return TEEC_ERROR_BAD_PARAMETERS;
+	}
+
+	tee_add_time_record_point("naoe");
+	switch (connectionMethod) {
+	case TEEC_LOGIN_PUBLIC:
+	case TEEC_LOGIN_USER:
+	case TEEC_LOGIN_APPLICATION:
+	case TEEC_LOGIN_USER_APPLICATION:
+		{
+			if (connectionData) {
+				if (returnOrigin)
+					*returnOrigin = TEEC_ORIGIN_API;
+				MARVELLTEE_DBG("ERROR - invalid conn data, NULL\n");
+				return TEEC_ERROR_BAD_PARAMETERS;
+			}
+		}
+		break;
+	case TEEC_LOGIN_GROUP:
+	case TEEC_LOGIN_GROUP_APPLICATION:
+		{
+			if (!connectionData) {
+				if (returnOrigin)
+					*returnOrigin = TEEC_ORIGIN_API;
+				MARVELLTEE_DBG("ERROR - invalid conn data, NULL\n");
+				return TEEC_ERROR_BAD_PARAMETERS;
+			}
+		}
+		break;
+#ifndef CONFIG_MINI_MARVELLTEE
+	case MRVL_LOGIN_APPLICATION_DAEMON:
+		{
+			/* Mrvl internal method */
+			/* The thread should NOT be frozen
+			* even the system is suspending
+			*/
+			unsigned long flags;
+
+			local_irq_save(flags);
+
+			current->flags |= PF_NOFREEZE;
+			current->flags |= PF_FREEZER_SKIP;
+			local_irq_restore(flags);
+		}
+		break;
+#endif
+	case MRVL_LOGIN_APPLICATION_SS:
+		break;
+	default:
+		{
+			if (returnOrigin)
+				*returnOrigin = TEEC_ORIGIN_API;
+			MARVELLTEE_DBG("ERROR - invalid conn meth, 0x%08x\n",
+					connectionMethod);
+			return TEEC_ERROR_BAD_PARAMETERS;
+		}
+		break;
+	}
+
+	_teec_mrvl_context = (_TEEC_MRVL_Context *) (context->imp);
+
+	if (!(IS_MAGIC_VALID(_teec_mrvl_context->magic))) {
+		if (returnOrigin)
+			*returnOrigin = TEEC_ORIGIN_API;
+		MARVELLTEE_DBG("ERROR - invalid cntx magic = %02x%02x%02x%02x\n",
+				_teec_mrvl_context->magic[0],
+				_teec_mrvl_context->magic[1],
+				_teec_mrvl_context->magic[2],
+				_teec_mrvl_context->magic[3]);
+		return TEEC_ERROR_BAD_PARAMETERS;
+	}
+
+	if (operation) {
+		tee_result = _set_sharedMem_atomic((tee_impl)&(context->imp),
+										operation, INC_ATOMIC);
+		if (tee_result != TEEC_SUCCESS) {
+			if (returnOrigin)
+				*returnOrigin = TEEC_ORIGIN_API;
+			MARVELLTEE_DBG("ERROR - failed to set shm atom cntr, 0x%08x\n",
+					tee_result);
+			return TEEC_ERROR_BAD_PARAMETERS;
+		}
+	}
+
+	osa_atomic_inc(&(_teec_mrvl_context->count));
+
+	session->imp = osa_kmem_alloc(sizeof(_TEEC_MRVL_Session));
+	if (!(session->imp)) {
+		if (returnOrigin)
+			*returnOrigin = TEEC_ORIGIN_API;
+		MARVELLTEE_DBG("ERROR - failed to alloc mem for session->imp\n");
+		return TEEC_ERROR_OUT_OF_MEMORY;
+	}
+	_teec_mrvl_session = (_TEEC_MRVL_Session *) (session->imp);
+	INIT_MAGIC(_teec_mrvl_session->magic);
+	_teec_mrvl_session->tee_ctx_ntw = &(context->imp);
+	osa_atomic_set(&(_teec_mrvl_session->count), 0);
+
+	if (operation)
+		osa_atomic_inc(&(_teec_mrvl_session->count));
+
+	/* prepare the request, create the msg and add it to the msgQ */
+	tee_msgm_handle = tee_msgm_create_inst();
+	if (!tee_msgm_handle) {
+		MARVELLTEE_DBG("ERROR - failed to create msgm inst\n");
+		OSA_ASSERT(0);
+	}
+
+	tee_msg_info.cmd = TEE_CMD_OPEN_SS;
+	tee_msg_info.msg_map_shm_info = NULL;
+	tee_msg_info.msg_op_info = operation;
+
+	/* Get buffer size */
+	tee_msg_stat =
+		tee_msgm_set_msg_buf(tee_msgm_handle, &tee_msg_info, NULL,
+				&buf_size);
+	if (tee_msg_stat != TEEC_SUCCESS) {
+		MARVELLTEE_DBG("ERROR - failed to set msg buf, 0x%08x\n", tee_msg_stat);
+		OSA_ASSERT(0);
+	}
+
+	tee_msg_buf = osa_kmem_alloc(sizeof(tee_msg_head_t) + buf_size);
+	if (!tee_msg_buf) {
+		tee_msgm_destroy_inst(tee_msgm_handle);
+		if (returnOrigin)
+			*returnOrigin = TEEC_ORIGIN_API;
+		MARVELLTEE_DBG("ERROR - failed to alloc msg buf, %d\n",
+				sizeof(tee_msg_head_t) + buf_size);
+		return TEEC_ERROR_GENERIC;
+	}
+
+	/* give the buffer to Msgm */
+	tee_msg_stat =
+		tee_msgm_set_msg_buf(tee_msgm_handle, NULL,
+				tee_msg_buf + sizeof(tee_msg_head_t),
+				&buf_size);
+	if (tee_msg_stat != TEEC_SUCCESS) {
+		MARVELLTEE_DBG("ERROR - failed to set msg buf, 0x%08x\n", tee_msg_stat);
+		OSA_ASSERT(0);
+	}
+
+	/* init head_t */
+	tee_msg_head = _init_msg_head(tee_msg_buf, buf_size);
+
+	if (operation) {
+		operation->imp = osa_kmem_alloc(sizeof(_TEEC_MRVL_Operation));
+		if (!(operation->imp)) {
+			if (returnOrigin)
+				*returnOrigin = TEEC_ORIGIN_API;
+			MARVELLTEE_DBG("ERROR - failed to alloc mem for op->imp\n");
+			return TEEC_ERROR_OUT_OF_MEMORY;
+		}
+		_teec_mrvl_operation =
+			(_TEEC_MRVL_Operation *) (operation->imp);
+		INIT_MAGIC(_teec_mrvl_operation->magic);
+		_teec_mrvl_operation->tee_ss_ntw = &(session->imp);
+
+		_teec_mrvl_operation->tee_msg_ntw = (void *)tee_msg_buf;
+	}
+
+	/* set cmd body */
+	tee_msg_cmd = TEE_CMD_OPEN_SS;
+	tee_msg_set_cmd_open_ss_arg.uuid = (TEEC_UUID *) destination;
+	_teec_generate_connection_data(connectionMethod,
+					&tee_msg_set_cmd_open_ss_arg);
+	tee_msg_set_cmd_open_ss_arg.cntx = (ulong_t)context;
+	tee_msg_stat =
+		tee_msgm_set_cmd(tee_msgm_handle, tee_msg_cmd,
+				&tee_msg_set_cmd_open_ss_arg);
+	if (tee_msg_stat != TEEC_SUCCESS) {
+		MARVELLTEE_DBG("ERROR - failed to set cmd, 0x%08x\n", tee_msg_stat);
+		OSA_ASSERT(0);
+	}
+
+	/* set params body */
+	if (operation) {
+		tee_msg_stat = tee_msgm_set_params(tee_msgm_handle, operation);
+		if (tee_msg_stat != TEEC_SUCCESS) {
+			osa_atomic_dec(&(_teec_mrvl_context->count));
+			if (operation) {
+				osa_atomic_dec(&(_teec_mrvl_session->count));
+				_set_sharedMem_atomic((tee_impl)&(context->imp),
+										operation, DEC_ATOMIC);
+			}
+			osa_kmem_free(tee_msg_buf);
+			tee_msgm_destroy_inst(tee_msgm_handle);
+			if (returnOrigin)
+				*returnOrigin = TEEC_ORIGIN_API;
+			MARVELLTEE_DBG("ERROR - failed to set params, 0x%08x\n", tee_msg_stat);
+			return tee_msg_stat;
+		}
+	}
+
+	tee_add_time_record_point("naow");
+	marvelltee_call_tw(tee_msg_head);
+	tee_add_time_record_point("naob");
+
+	/* deal with the response */
+	if (!(IS_MSG_MAGIC_VALID(tee_msg_head->magic))) {
+		MARVELLTEE_DBG("ERROR - invalid msg magic = %02x%02x%02x%02x\n",
+				tee_msg_head->magic[0],
+				tee_msg_head->magic[1],
+				tee_msg_head->magic[2],
+				tee_msg_head->magic[3]);
+		OSA_ASSERT(0);
+	}
+
+	/* Get return */
+	if (operation) {
+		tee_msg_stat =
+			tee_msgm_update_params(tee_msgm_handle, operation);
+		if (tee_msg_stat != TEEC_SUCCESS) {
+			MARVELLTEE_DBG("ERROR - failed to update params, 0x%08x\n",
+					tee_msg_stat);
+			OSA_ASSERT(0);
+		}
+	}
+
+	tee_msg_stat = tee_msgm_get_ret(tee_msgm_handle, (void *)&tee_get_ret);
+	if (tee_msg_stat != TEEC_SUCCESS) {
+		MARVELLTEE_DBG("ERROR - failed to get ret, 0x%08x\n", tee_msg_stat);
+		OSA_ASSERT(0);
+	}
+
+	_teec_mrvl_session->tee_ss_tw = tee_get_ret.ss_tw;
+	if (returnOrigin)
+		*returnOrigin = tee_get_ret.ret_orig;
+
+	tee_result = tee_get_ret.ret;
+
+	if (tee_result != TEEC_SUCCESS) {
+		osa_atomic_dec(&(_teec_mrvl_context->count));
+		MARVELLTEE_DBG("ERROR - error ret from tw, 0x%08x\n", tee_result);
+	}
+
+	if (operation) {
+		osa_atomic_dec(&(_teec_mrvl_session->count));
+		_set_sharedMem_atomic((tee_impl)&(context->imp),
+								operation, DEC_ATOMIC);
+	}
+
+	osa_kmem_free(tee_msg_buf);
+	tee_msgm_destroy_inst(tee_msgm_handle);
+
+	if (operation)
+		osa_kmem_free(operation->imp);
+
+	tee_add_time_record_point("naox");
+
+	return tee_result;
+}
+EXPORT_SYMBOL(TEEC_OpenSession);
+
+void TEEC_CloseSession(TEEC_Session *session)
+{
+	TEEC_Context *teec_context;
+	int32_t count;
+
+	tee_msgm_t tee_msgm_handle;
+	tee_cmd_t tee_msg_cmd;
+	tee_set_cmd_close_ss_arg_t tee_msg_set_cmd_close_ss_arg;
+	tee_stat_t tee_msg_stat;
+	uint32_t buf_size;
+	tee_msgm_msg_info_t tee_msg_info;
+
+	uint8_t *tee_msg_buf;
+	tee_msg_head_t *tee_msg_head;
+	_TEEC_MRVL_Context *_teec_mrvl_context;
+	_TEEC_MRVL_Session *_teec_mrvl_session;
+
+	if (!session) {
+		MARVELLTEE_DBG("ERROR - invalid ss, NULL\n");
+		return;
+	}
+
+	tee_add_time_record_point("nace");
+	_teec_mrvl_session = (_TEEC_MRVL_Session *) (session->imp);
+
+	if (!(IS_MAGIC_VALID(_teec_mrvl_session->magic))) {
+		MARVELLTEE_DBG("ERROR - invalid ss magic = %02x%02x%02x%02x\n",
+				_teec_mrvl_session->magic[0],
+				_teec_mrvl_session->magic[1],
+				_teec_mrvl_session->magic[2],
+				_teec_mrvl_session->magic[3]);
+		OSA_ASSERT(0);
+	}
+
+	CLEANUP_MAGIC(_teec_mrvl_session->magic);
+
+	count = osa_atomic_read(&(_teec_mrvl_session->count));
+	if (count != 0) {
+		MARVELLTEE_DBG("ERROR - invalid count in cntx, %d\n", count);
+		OSA_ASSERT(0);
+	}
+
+	/* prepare the request, create the msg and add it to the msgQ */
+	tee_msgm_handle = tee_msgm_create_inst();
+	if (!tee_msgm_handle) {
+		MARVELLTEE_DBG("ERROR - failed to create msgm inst\n");
+		OSA_ASSERT(0);
+	}
+
+	tee_msg_info.cmd = TEE_CMD_CLOSE_SS;
+	tee_msg_info.msg_map_shm_info = NULL;
+	tee_msg_info.msg_op_info = NULL;
+
+	/* Get buffer size */
+	tee_msg_stat =
+		tee_msgm_set_msg_buf(tee_msgm_handle, &tee_msg_info, NULL,
+				&buf_size);
+	if (tee_msg_stat != TEEC_SUCCESS) {
+		MARVELLTEE_DBG("ERROR - failed to set msg buf, 0x%08x\n", tee_msg_stat);
+		OSA_ASSERT(0);
+	}
+
+	tee_msg_buf = osa_kmem_alloc(sizeof(tee_msg_head_t) + buf_size);
+	if (!tee_msg_buf) {
+		tee_msgm_destroy_inst(tee_msgm_handle);
+		MARVELLTEE_DBG("ERROR - failed to alloc msg buf, %d\n",
+				sizeof(tee_msg_head_t) + buf_size);
+		OSA_ASSERT(0);
+	}
+
+	/* give the buffer to Msgm */
+	tee_msg_stat =
+		tee_msgm_set_msg_buf(tee_msgm_handle, NULL,
+				tee_msg_buf + sizeof(tee_msg_head_t),
+				&buf_size);
+	if (tee_msg_stat != TEEC_SUCCESS) {
+		MARVELLTEE_DBG("ERROR - failed to set msg buf, 0x%08x\n", tee_msg_stat);
+		OSA_ASSERT(0);
+	}
+
+	/* init head_t */
+	tee_msg_head = _init_msg_head(tee_msg_buf, buf_size);
+
+	/* set cmd body */
+	tee_msg_cmd = TEE_CMD_CLOSE_SS;
+	tee_msg_set_cmd_close_ss_arg = _teec_mrvl_session->tee_ss_tw;
+	tee_msg_stat =
+		tee_msgm_set_cmd(tee_msgm_handle, tee_msg_cmd,
+				tee_msg_set_cmd_close_ss_arg);
+	if (tee_msg_stat != TEEC_SUCCESS) {
+		MARVELLTEE_DBG("ERROR - failed to set cmd, 0x%08x\n", tee_msg_stat);
+		OSA_ASSERT(0);
+	}
+
+	tee_add_time_record_point("nacw");
+	marvelltee_call_tw(tee_msg_head);
+	tee_add_time_record_point("nacb");
+
+	/* deal with the response */
+	osa_kmem_free(tee_msg_buf);
+	tee_msgm_destroy_inst(tee_msgm_handle);
+
+	teec_context =
+		container_of(_teec_mrvl_session->tee_ctx_ntw, TEEC_Context, imp);
+	_teec_mrvl_context = (_TEEC_MRVL_Context *) (teec_context->imp);
+	osa_atomic_dec(&(_teec_mrvl_context->count));
+
+	_teec_mrvl_session->tee_ctx_ntw = NULL;
+	_teec_mrvl_session->tee_ss_tw = NULL;
+
+	osa_kmem_free(session->imp);
+	tee_add_time_record_point("nacx");
+}
+EXPORT_SYMBOL(TEEC_CloseSession);
+
+TEEC_Result TEEC_InvokeCommand(TEEC_Session *session,
+				uint32_t commandID,
+				TEEC_Operation *operation,
+				uint32_t *returnOrigin)
+{
+	TEEC_Result tee_result = TEEC_SUCCESS;
+
+	tee_msgm_t tee_msgm_handle;
+	tee_cmd_t tee_msg_cmd;
+	tee_set_cmd_inv_op_arg_t tee_msg_set_cmd_inv_op_arg;
+	tee_stat_t tee_msg_stat;
+	uint32_t buf_size;
+	tee_msgm_msg_info_t tee_msg_info;
+	tee_get_ret_inv_op_arg_t tee_get_ret;
+
+	uint8_t *tee_msg_buf;
+	tee_msg_head_t *tee_msg_head;
+	_TEEC_MRVL_Session *_teec_mrvl_session;
+	_TEEC_MRVL_Operation *_teec_mrvl_operation;
+
+	tee_add_time_record_point("naie");
+	if (!session) {
+		if (returnOrigin)
+			*returnOrigin = TEEC_ORIGIN_API;
+		MARVELLTEE_DBG("ERROR - invalid ss, NULL\n");
+		return TEEC_ERROR_BAD_PARAMETERS;
+	}
+
+	_teec_mrvl_session = (_TEEC_MRVL_Session *) (session->imp);
+
+	if (!(IS_MAGIC_VALID(_teec_mrvl_session->magic))) {
+		if (returnOrigin)
+			*returnOrigin = TEEC_ORIGIN_API;
+		MARVELLTEE_DBG("ERROR - invalid ss magic = %02x%02x%02x%02x\n",
+				_teec_mrvl_session->magic[0],
+				_teec_mrvl_session->magic[1],
+				_teec_mrvl_session->magic[2],
+				_teec_mrvl_session->magic[3]);
+		return TEEC_ERROR_BAD_PARAMETERS;
+	}
+
+	if (operation) {
+		tee_result = _set_sharedMem_atomic(
+						_teec_mrvl_session->tee_ctx_ntw,
+						operation, INC_ATOMIC);
+		if (tee_result != TEEC_SUCCESS) {
+			if (returnOrigin)
+				*returnOrigin = TEEC_ORIGIN_API;
+			MARVELLTEE_DBG("ERROR - failed to set shm atom cntr, 0x%08x\n",
+					tee_result);
+			return TEEC_ERROR_BAD_PARAMETERS;
+		}
+	}
+
+	if (operation)
+		osa_atomic_inc(&(_teec_mrvl_session->count));
+
+	/* prepare the request, create the msg and add it to the msgQ */
+	tee_msgm_handle = tee_msgm_create_inst();
+	if (!tee_msgm_handle) {
+		MARVELLTEE_DBG("ERROR - failed to create msgm inst\n");
+		OSA_ASSERT(0);
+	}
+
+	tee_msg_info.cmd = TEE_CMD_INV_OP;
+	tee_msg_info.msg_map_shm_info = NULL;
+	if (operation)
+		tee_msg_info.msg_op_info = operation;
+	else
+		tee_msg_info.msg_op_info = NULL;
+
+	/* Get buffer size */
+	tee_msg_stat =
+		tee_msgm_set_msg_buf(tee_msgm_handle, &tee_msg_info, NULL,
+				&buf_size);
+	if (tee_msg_stat != TEEC_SUCCESS) {
+		MARVELLTEE_DBG("ERROR - failed to set msg buf, 0x%08x\n", tee_msg_stat);
+		OSA_ASSERT(0);
+	}
+
+	tee_msg_buf = osa_kmem_alloc(sizeof(tee_msg_head_t) + buf_size);
+	if (!tee_msg_buf) {
+		tee_msgm_destroy_inst(tee_msgm_handle);
+		if (returnOrigin)
+			*returnOrigin = TEEC_ORIGIN_API;
+		MARVELLTEE_DBG("ERROR - failed to alloc msg buf, %d\n",
+				sizeof(tee_msg_head_t) + buf_size);
+		return TEEC_ERROR_GENERIC;
+	}
+
+	/* give the buffer to Msgm */
+	tee_msg_stat =
+		tee_msgm_set_msg_buf(tee_msgm_handle, NULL,
+				tee_msg_buf + sizeof(tee_msg_head_t),
+				&buf_size);
+	if (tee_msg_stat != TEEC_SUCCESS) {
+		MARVELLTEE_DBG("ERROR - failed to set msg buf, 0x%08x\n", tee_msg_stat);
+		OSA_ASSERT(0);
+	}
+
+	/* init head_t */
+	tee_msg_head = _init_msg_head(tee_msg_buf, buf_size);
+
+	if (operation) {
+		operation->imp = osa_kmem_alloc(sizeof(_TEEC_MRVL_Operation));
+		if (!(operation->imp)) {
+			if (returnOrigin)
+				*returnOrigin = TEEC_ORIGIN_API;
+			MARVELLTEE_DBG("ERROR - failed to alloc mem for op->imp\n");
+			return TEEC_ERROR_OUT_OF_MEMORY;
+		}
+
+		_teec_mrvl_operation =
+			(_TEEC_MRVL_Operation *) (operation->imp);
+		INIT_MAGIC(_teec_mrvl_operation->magic);
+		_teec_mrvl_operation->tee_ss_ntw = &(session->imp);
+		_teec_mrvl_operation->tee_msg_ntw = (void *)tee_msg_buf;
+	}
+
+	/* set cmd body */
+	tee_msg_cmd = TEE_CMD_INV_OP;
+	tee_msg_set_cmd_inv_op_arg.ss = _teec_mrvl_session->tee_ss_tw;
+	tee_msg_set_cmd_inv_op_arg.srv_cmd = commandID;
+	tee_msg_stat =
+		tee_msgm_set_cmd(tee_msgm_handle, tee_msg_cmd,
+				&tee_msg_set_cmd_inv_op_arg);
+	if (tee_msg_stat != TEEC_SUCCESS) {
+		MARVELLTEE_DBG("ERROR - failed to set cmd, 0x%08x\n", tee_msg_stat);
+		OSA_ASSERT(0);
+	}
+
+	/* set params body */
+	if (operation) {
+		tee_msg_stat = tee_msgm_set_params(tee_msgm_handle, operation);
+		if (tee_msg_stat != TEEC_SUCCESS) {
+			if (operation) {
+				osa_atomic_dec(&(_teec_mrvl_session->count));
+				_set_sharedMem_atomic(_teec_mrvl_session->tee_ctx_ntw,
+									operation, DEC_ATOMIC);
+			}
+
+			osa_kmem_free(tee_msg_buf);
+			tee_msgm_destroy_inst(tee_msgm_handle);
+			if (returnOrigin)
+				*returnOrigin = TEEC_ORIGIN_API;
+			MARVELLTEE_DBG("ERROR - failed to set params, 0x%08x\n", tee_msg_stat);
+			return tee_msg_stat;
+		}
+	}
+
+	tee_add_time_record_point("naiw");
+	marvelltee_call_tw(tee_msg_head);
+	tee_add_time_record_point("naib");
+
+	/* deal with the response */
+	if (!(IS_MSG_MAGIC_VALID(tee_msg_head->magic))) {
+		MARVELLTEE_DBG("ERROR - invalid msg magic = %02x%02x%02x%02x\n",
+				tee_msg_head->magic[0],
+				tee_msg_head->magic[1],
+				tee_msg_head->magic[2],
+				tee_msg_head->magic[3]);
+		OSA_ASSERT(0);
+	}
+
+	/* Get return */
+	if (operation) {
+		tee_msg_stat =
+			tee_msgm_update_params(tee_msgm_handle, operation);
+		if (tee_msg_stat != TEEC_SUCCESS) {
+			MARVELLTEE_DBG("ERROR - failed to update params, 0x%08x\n",
+					tee_msg_stat);
+			OSA_ASSERT(0);
+		}
+	}
+
+	tee_msg_stat = tee_msgm_get_ret(tee_msgm_handle, (void *)&tee_get_ret);
+	if (tee_msg_stat != TEEC_SUCCESS) {
+		MARVELLTEE_DBG("ERROR - failed to get ret, 0x%08x\n", tee_msg_stat);
+		OSA_ASSERT(0);
+	}
+
+	if (returnOrigin)
+		*returnOrigin = tee_get_ret.ret_orig;
+
+	tee_result = tee_get_ret.ret;
+	if (tee_result)
+		MARVELLTEE_DBG("ERROR - error ret from tw, 0x%08x\n", tee_result);
+
+	if (operation) {
+		osa_atomic_dec(&(_teec_mrvl_session->count));
+		_set_sharedMem_atomic(_teec_mrvl_session->tee_ctx_ntw,
+							operation, DEC_ATOMIC);
+	}
+
+	osa_kmem_free(tee_msg_buf);
+	tee_msgm_destroy_inst(tee_msgm_handle);
+
+	if (operation)
+		osa_kmem_free(operation->imp);
+
+	tee_add_time_record_point("naix");
+	return tee_result;
+}
+EXPORT_SYMBOL(TEEC_InvokeCommand);
+
+#ifdef CONFIG_MINI_MARVELLTEE
+
+void TEEC_RequestCancellation(TEEC_Operation *operation)
+{
+	MARVELLTEE_DBG("ERROR - %s is not supported in mini-MARVELLTEE\n", __func__);
+}
+
+#else /* !CONFIG_MINI_MARVELLTEE */
+
+void TEEC_RequestCancellation(TEEC_Operation *operation)
+{
+	tee_msg_head_t *tee_msg_head;
+
+	tee_msgm_t tee_msgm_handle;
+	tee_cmd_t tee_msg_cmd;
+	tee_set_cmd_can_op_arg_t tee_msg_set_cmd_can_op_arg;
+	tee_stat_t tee_msg_stat;
+	uint32_t buf_size;
+	tee_msgm_msg_info_t tee_msg_info;
+
+	uint8_t *tee_msg_buf;
+	TEEC_Session *teec_session;
+	_TEEC_MRVL_Session *_teec_mrvl_session;
+	_TEEC_MRVL_Operation *_teec_mrvl_operation;
+
+	if (!operation) {
+		MARVELLTEE_DBG("ERROR - invalid op, NULL\n");
+		OSA_ASSERT(0);
+	}
+
+	_teec_mrvl_operation = (_TEEC_MRVL_Operation *)(operation->imp);
+
+	tee_msg_head = _teec_mrvl_operation->tee_msg_ntw;
+
+	if (marvelltee_chk_node_on_req_list(&(tee_msg_head->node))) {
+		/* The msg is in the msgQ in NTW */
+		tee_msg_head->msg_prop.bp.stat = TEE_MSG_STAT_CAN;
+		return;
+	}
+
+	/* The msg has been sent to the TW */
+	/* prepare the request, create the msg and add it to the msgQ */
+	tee_msgm_handle = tee_msgm_create_inst();
+	if (!tee_msgm_handle) {
+		MARVELLTEE_DBG("ERROR - failed to create msgm inst\n");
+		OSA_ASSERT(0);
+	}
+
+	tee_msg_info.cmd = TEE_CMD_CAN_OP;
+	tee_msg_info.msg_map_shm_info = NULL;
+	tee_msg_info.msg_op_info = operation;
+
+	/* Get buffer size */
+	tee_msg_stat =
+		tee_msgm_set_msg_buf(tee_msgm_handle, &tee_msg_info, NULL,
+				&buf_size);
+	if (tee_msg_stat != TEEC_SUCCESS) {
+		MARVELLTEE_DBG("ERROR - failed to set msg buf, 0x%08x\n", tee_msg_stat);
+		OSA_ASSERT(0);
+	}
+
+	tee_msg_buf = osa_kmem_alloc(sizeof(tee_msg_head_t) + buf_size);
+	if (!tee_msg_buf) {
+		tee_msgm_destroy_inst(tee_msgm_handle);
+		MARVELLTEE_DBG("ERROR - failed to alloc msg buf, %d\n",
+				sizeof(tee_msg_head_t) + buf_size);
+		OSA_ASSERT(0);
+	}
+
+	/* give the buffer to Msgm */
+	tee_msg_stat =
+		tee_msgm_set_msg_buf(tee_msgm_handle, NULL,
+				tee_msg_buf + sizeof(tee_msg_head_t),
+				&buf_size);
+	if (tee_msg_stat != TEEC_SUCCESS) {
+		MARVELLTEE_DBG("ERROR - failed to set msg buf, 0x%08x\n", tee_msg_stat);
+		OSA_ASSERT(0);
+	}
+
+	/* init head_t */
+	tee_msg_head = _init_msg_head(tee_msg_buf, buf_size);
+
+	/* set cmd body */
+	teec_session =
+	container_of(_teec_mrvl_operation->tee_ss_ntw, TEEC_Session, imp);
+	_teec_mrvl_session = (_TEEC_MRVL_Session *) (teec_session->imp);
+
+	tee_msg_cmd = TEE_CMD_CAN_OP;
+
+	tee_msg_set_cmd_can_op_arg.ss = _teec_mrvl_session->tee_ss_tw;
+	tee_msg_set_cmd_can_op_arg.operation = operation;
+	tee_msg_stat =
+		tee_msgm_set_cmd(tee_msgm_handle, tee_msg_cmd,
+				&tee_msg_set_cmd_can_op_arg);
+	if (tee_msg_stat != TEEC_SUCCESS) {
+		MARVELLTEE_DBG("ERROR - failed to set cmd, 0x%08x\n", tee_msg_stat);
+		OSA_ASSERT(0);
+	}
+
+	marvelltee_add_node_to_req_list(&(tee_msg_head->node));
+
+	/* Wake up PT */
+	osa_release_sem(marvelltee_dev->pt_sem);
+	/* osa_wakeup_process(marvelltee_dev->proxy_thd); */
+
+	tee_msgm_destroy_inst(tee_msgm_handle);
+}
+EXPORT_SYMBOL(TEEC_RequestCancellation);
+
+#endif /* CONFIG_MINI_MARVELLTEE */
diff --git a/drivers/marvell/security/marvelltee/src/main/teec_seed_src.c b/drivers/marvell/security/marvelltee/src/main/teec_seed_src.c
new file mode 100644
index 0000000..bbac2d0
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/main/teec_seed_src.c
@@ -0,0 +1,107 @@
+/*
+ * Copyright (c) [2009-2015] Marvell International Ltd. and its affiliates. All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell and you have entered into a commercial
+ * license agreement (a "Commercial License") with Marvell, the File is licensed
+ * to you under the terms of the applicable Commercial License.
+ *
+ */
+
+#include <linux/time.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/uaccess.h>
+#include "tee_client_api.h"
+
+static TEEC_UUID _g_rkek_src_uuid_t = {
+	0x00000011, 0x0000, 0x0000,
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
+};
+
+#define TEE_SRV_CMD_GEN_RKEK  0xffff0916
+#define MAC_ADDRESS_FILE  "/sys/class/net/eth0/address"
+
+TEEC_Result teec_pass_seed(uint8_t *buffer, size_t len)
+{
+	TEEC_Result result = TEEC_SUCCESS;
+	TEEC_Context teec_context;
+	TEEC_Session teec_session;
+	TEEC_Operation teec_operation;
+
+	result = TEEC_InitializeContext(NULL, &teec_context);
+	if (result != TEEC_SUCCESS) {
+		pr_err("TEEC_InitializeContext failed, result = 0x%x\n", result);
+		goto cleanup1;
+	}
+
+	result = TEEC_OpenSession(&teec_context, &teec_session, &_g_rkek_src_uuid_t,
+							  TEEC_LOGIN_USER, NULL, NULL, NULL);
+	if (result != TEEC_SUCCESS) {
+		pr_err("TEEC_OpenSession failed, result = 0x%x\n", result);
+		goto cleanup2;
+	}
+
+	teec_operation.paramTypes = TEEC_PARAM_TYPES(TEEC_MEMREF_TEMP_INPUT, TEEC_NONE,
+												 TEEC_NONE, TEEC_NONE);
+	teec_operation.params[0].tmpref.buffer = (void *)buffer;
+	teec_operation.params[0].tmpref.size = len;
+	result = TEEC_InvokeCommand(&teec_session, TEE_SRV_CMD_GEN_RKEK, &teec_operation, NULL);
+	if (result != TEEC_SUCCESS) {
+		pr_err("TEEC_InvokeCommand failed, result = 0x%x\n", result);
+		goto cleanup3;
+	}
+
+cleanup3:
+	TEEC_CloseSession(&teec_session);
+cleanup2:
+	TEEC_FinalizeContext(&teec_context);
+cleanup1:
+	return result;
+
+}
+
+int32_t teec_get_seed(void)
+{
+	struct file *fp = NULL;
+	loff_t pos = 0;
+	mm_segment_t fs;
+	int len = 17, count, i;
+	uint8_t temp[len];
+	uint8_t uc_buffer[6];
+	uint32_t ui_buffer[6];
+	TEEC_Result result = TEEC_SUCCESS;
+
+	fp = filp_open(MAC_ADDRESS_FILE, O_RDONLY, 0);
+	if (IS_ERR(fp)) {
+		pr_err("marvelltee: open file %s failed\n", MAC_ADDRESS_FILE);
+		return -1;
+	}
+
+	fs = get_fs();
+	set_fs(KERNEL_DS);
+	vfs_read(fp, temp, len, &pos);
+	set_fs(fs);
+	filp_close(fp, NULL);
+
+	count = sscanf(temp, "%02x:%02x:%02x:%02x:%02x:%02x"
+					, &ui_buffer[0]
+					, &ui_buffer[1]
+					, &ui_buffer[2]
+					, &ui_buffer[3]
+					, &ui_buffer[4]
+					, &ui_buffer[5]);
+	if (count != 6) {
+		pr_err("marvelltee: input error! Input is %s\n", temp);
+		return -1;
+	}
+	for (i = 0; i < 6; i++)
+		uc_buffer[i] = (uint8_t)ui_buffer[i];
+
+	result = teec_pass_seed(uc_buffer, 6);
+	if (result != TEEC_SUCCESS)
+		return -1;
+
+	return 0;
+}
diff --git a/drivers/marvell/security/marvelltee/src/main/teec_shd.c b/drivers/marvell/security/marvelltee/src/main/teec_shd.c
new file mode 100644
index 0000000..d8e927a
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/main/teec_shd.c
@@ -0,0 +1,257 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+
+#include "teec_types.h"
+#include "marvelltee_internal.h"
+#include "teec_shd.h"
+#include "teec_cb.h"
+#include "tee_shd_common.h"
+
+#define SHD_DBG(format, a...) MARVELLTEE_DBG("%s(%d): " format, __func__, __LINE__, ##a)
+
+typedef enum _teec_shd_stat_t {
+	TEEC_SHD_INV,
+	TEEC_SHD_READY,
+	TEEC_SHD_SHARED,
+} teec_shd_stat_t;
+
+typedef struct _teec_shd_rec_t {
+	teec_shd_t        shd;
+
+	teec_shd_stat_t   stat;
+	osa_mutex_t       stat_lock;
+
+	void              *ntw_addr;
+	void              *tw_addr;
+	uint32_t          data_sz;
+
+	teec_cb_handle_t  handle;
+	osa_list_t        node;
+
+	TEEC_SharedMemory shm;
+} teec_shd_rec_t;
+
+static osa_list_t _g_shd_list;
+static osa_mutex_t _g_shd_list_lock;
+static TEEC_Context _g_shd_context;
+
+static void *_teec_shd_reg_shm(teec_shd_rec_t *shd_rec, void *ntw_data, uint32_t ntw_data_sz)
+{
+	TEEC_Result ret;
+
+	shd_rec->shm.buffer = ntw_data;
+	shd_rec->shm.size = ntw_data_sz;
+	shd_rec->shm.flags = TEEC_MEM_INPUT | TEEC_MEM_OUTPUT;
+	ret = TEEC_RegisterSharedMemory(&_g_shd_context, &shd_rec->shm);
+	if (ret != TEEC_SUCCESS) {
+		SHD_DBG("failed to register shm\n");
+		return NULL;
+	}
+
+	return ((_TEEC_MRVL_SharedMemory *)shd_rec->shm.imp)->vaddr_tw;
+}
+
+static teec_cb_stat_t _teec_shd_cb_fn(tee_cb_arg_t *arg, teec_cb_cntx_t cntx)
+{
+	teec_shd_rec_t *rec;
+	teec_shd_t *shd;
+	tee_shd_cb_cmd_desc_t *cmd_desc;
+	int32_t ret;
+
+	OSA_ASSERT(arg->nbytes == sizeof(tee_shd_cb_cmd_desc_t));
+
+	rec = (teec_shd_rec_t *)cntx;
+	shd = &rec->shd;
+	cmd_desc = (tee_shd_cb_cmd_desc_t *)arg->args;
+
+	switch (cmd_desc->cmd) {
+	case TEEC_SHD_CMD_SHARING:
+		osa_wait_for_mutex(rec->stat_lock, INFINITE);
+		if (rec->stat != TEEC_SHD_READY) {
+			osa_release_mutex(rec->stat_lock);
+			SHD_DBG("share device in error stat %d\n", rec->stat);
+			return TEEC_ERROR_GENERIC;
+		}
+		if (shd->sharing == NULL) {
+			osa_release_mutex(rec->stat_lock);
+			return TEEC_SUCCESS;
+		}
+		ret = shd->sharing(shd, rec->ntw_addr);
+		if (ret < 0) {
+			osa_release_mutex(rec->stat_lock);
+			SHD_DBG("failed to share device %s: %d (%d)\n",
+					shd->name, shd->id, ret);
+			return TEEC_ERROR_GENERIC;
+		}
+		cmd_desc->data = rec->tw_addr;
+
+		rec->stat = TEEC_SHD_SHARED;
+		osa_release_mutex(rec->stat_lock);
+		break;
+	case TEEC_SHD_CMD_REVERT:
+		osa_wait_for_mutex(rec->stat_lock, INFINITE);
+		if (rec->stat != TEEC_SHD_SHARED) {
+			osa_release_mutex(rec->stat_lock);
+			SHD_DBG("share device in error stat %d\n", rec->stat);
+			return TEEC_ERROR_GENERIC;
+		}
+		if (shd->revert == NULL) {
+			osa_release_mutex(rec->stat_lock);
+			return TEEC_SUCCESS;
+		}
+		ret = shd->revert(shd, rec->ntw_addr);
+		if (ret < 0) {
+			osa_release_mutex(rec->stat_lock);
+			SHD_DBG("failed to share device %s: %d (%d)\n",
+					shd->name, shd->id, ret);
+			return TEEC_ERROR_GENERIC;
+		}
+		cmd_desc->data = NULL;
+
+		rec->stat = TEEC_SHD_READY;
+		osa_release_mutex(rec->stat_lock);
+		break;
+	default:
+		OSA_ASSERT(0);
+		break;
+	}
+
+	return TEEC_SUCCESS;
+}
+
+int32_t teec_register_shd(teec_shd_t *shd)
+{
+	teec_shd_rec_t *new_rec;
+	int32_t ret;
+	teec_cb_uuid_t uuid;
+	void *ntw_data;
+	uint32_t ntw_data_sz;
+
+	if (shd == NULL || shd->magic != TEEC_SHD_MAGIC)
+		return -EINVAL;
+
+	tee_shd_get_uuid(shd->name, shd->type, shd->id, &uuid);
+
+	new_rec = kzalloc(sizeof(teec_shd_rec_t), GFP_KERNEL);
+	if (new_rec == NULL) {
+		SHD_DBG("failed to alloc new rec\n");
+		return -ENOMEM;
+	}
+	new_rec->shd = *shd;
+	osa_list_init_head(&new_rec->node);
+
+	new_rec->stat_lock = osa_create_mutex();
+	OSA_ASSERT(new_rec->stat_lock != NULL);
+
+	/* check and register shd */
+	new_rec->handle = teec_reg_cb(&uuid, _teec_shd_cb_fn, new_rec);
+	if (new_rec->handle == NULL) {
+		SHD_DBG("failed to register callback\n");
+		kfree(new_rec);
+		return -EIO;
+	}
+
+	if (shd->init) {
+		/* init shd */
+		ret = shd->init(&new_rec->shd, &ntw_data, &ntw_data_sz);
+		if (ret < 0) {
+			SHD_DBG("failed to init shd\n");
+			teec_unreg_cb(new_rec->handle);
+			kfree(new_rec);
+			return ret;
+		}
+		if (ntw_data != NULL && ntw_data_sz != 0) {
+			new_rec->tw_addr = _teec_shd_reg_shm(new_rec, ntw_data, ntw_data_sz);
+			if (new_rec->tw_addr == NULL) {
+				shd->cleanup(&new_rec->shd);
+				teec_unreg_cb(new_rec->handle);
+				kfree(new_rec);
+				SHD_DBG("failed to register shm\n");
+				return -ENODEV;
+			}
+			new_rec->ntw_addr = ntw_data;
+			new_rec->data_sz = ntw_data_sz;
+		}
+	}
+
+	new_rec->stat = TEEC_SHD_READY;
+
+	osa_wait_for_mutex(_g_shd_list_lock, INFINITE);
+	osa_list_add(&new_rec->node, &_g_shd_list);
+	osa_release_mutex(_g_shd_list_lock);
+
+	return 0;
+}
+
+int32_t teec_unregister_shd(teec_shd_t *shd)
+{
+	osa_list_t *entry;
+	teec_shd_rec_t *rec;
+
+	if (shd == NULL || shd->magic != TEEC_SHD_MAGIC)
+		return -EINVAL;
+
+	osa_wait_for_mutex(_g_shd_list_lock, INFINITE);
+	osa_list_iterate(&_g_shd_list, entry) {
+		OSA_LIST_ENTRY(entry, teec_shd_rec_t, node, rec);
+		if (!strcmp(shd->name, rec->shd.name) && shd->id == rec->shd.id) {
+			osa_wait_for_mutex(rec->stat_lock, INFINITE);
+			if (rec->stat == TEEC_SHD_SHARED) {
+				SHD_DBG("in error stat %d\n", rec->stat);
+				return -EIO;
+			}
+
+			rec->stat = TEEC_SHD_INV;
+			osa_release_mutex(rec->stat_lock);
+			osa_list_del(&rec->node);
+			osa_release_mutex(_g_shd_list_lock);
+
+			shd->cleanup(&rec->shd);
+
+			TEEC_ReleaseSharedMemory(&rec->shm);
+			rec->tw_addr = NULL;
+			teec_unreg_cb(rec->handle);
+
+			memset(rec, 0, sizeof(teec_shd_rec_t));
+			kfree(rec);
+			return 0;
+		}
+	}
+	osa_release_mutex(_g_shd_list_lock);
+	return -ENODEV;
+}
+
+int32_t teec_shd_init(void)
+{
+	TEEC_Result ret;
+
+	ret = TEEC_InitializeContext(NULL, &_g_shd_context);
+	if (ret != TEEC_SUCCESS) {
+		SHD_DBG("failed to init context\n");
+		return -EINVAL;
+	}
+	osa_list_init_head(&_g_shd_list);
+	_g_shd_list_lock = osa_create_mutex();
+
+	return 0;
+}
+void teec_shd_cleanup(void)
+{
+	osa_destroy_mutex(_g_shd_list_lock);
+	TEEC_FinalizeContext(&_g_shd_context);
+}
diff --git a/drivers/marvell/security/marvelltee/src/main/teec_time.c b/drivers/marvell/security/marvelltee/src/main/teec_time.c
new file mode 100644
index 0000000..518595c
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/main/teec_time.c
@@ -0,0 +1,69 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+
+#include "teec_cb.h"
+#include "teec_time.h"
+#include "osa.h"
+
+/* vvv sync with tw vvv */
+
+typedef struct _ree_time {
+	uint32_t sec;
+	uint32_t nsec;
+} ree_time;
+
+static const teec_cb_uuid_t _g_ree_time_uuid = {
+	0xFF000000, 0x0000, 0x0000,
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 },
+};
+
+/* ^^^ sync with tw ^^^ */
+teec_cb_stat_t _teec_get_ree_time(tee_cb_arg_t *args, teec_cb_cntx_t cntx)
+{
+	ree_time *t;
+	struct timespec ts;
+
+	OSA_ASSERT(sizeof(ree_time) == args->nbytes);
+
+	getnstimeofday(&ts);
+
+	t = (ree_time *)args->args;
+	t->sec = ts.tv_sec;
+	t->nsec = ts.tv_nsec;
+	return TEEC_SUCCESS;
+}
+
+tee_stat_t teec_reg_time_cb(marvelltee_dev_t *dev)
+{
+	if (dev->time_cb_h)
+		return TEEC_SUCCESS;
+
+	dev->time_cb_h = teec_reg_cb(&_g_ree_time_uuid, _teec_get_ree_time, NULL);
+	if (dev->time_cb_h == NULL)
+		return TEEC_ERROR_GENERIC;
+
+	return TEEC_SUCCESS;
+}
+
+void teec_unreg_time_cb(marvelltee_dev_t *dev)
+{
+	if (dev->time_cb_h) {
+		teec_unreg_cb(dev->time_cb_h);
+		dev->time_cb_h = NULL;
+	}
+}
diff --git a/drivers/marvell/security/marvelltee/src/main/teec_time.h b/drivers/marvell/security/marvelltee/src/main/teec_time.h
new file mode 100644
index 0000000..3747474
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/main/teec_time.h
@@ -0,0 +1,28 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+
+#ifndef __TEEC_TIME_H__
+#define __TEEC_TIME_H__
+
+#include "marvelltee_internal.h"
+
+tee_stat_t teec_reg_time_cb(marvelltee_dev_t *dev);
+void teec_unreg_time_cb(marvelltee_dev_t *dev);
+
+#endif /* __TEEC_TIME_H__ */
+
diff --git a/drivers/marvell/security/marvelltee/src/memm/tee_memm.c b/drivers/marvell/security/marvelltee/src/memm/tee_memm.c
new file mode 100644
index 0000000..ca7c5df
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/memm/tee_memm.c
@@ -0,0 +1,345 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+#ifndef CONFIG_MINI_MARVELLTEE
+#include "tee_memm_internal.h"
+#else
+#include "mt_memm_internal.h"
+#define MMU_ENABLE_BIT	(1)
+#endif
+
+#define MAGIC_NUM   (4)
+
+#define INIT_MEMM_MAGIC(_n)  \
+	do {                            \
+		((uint8_t *)_n)[0] = 'M';   \
+		((uint8_t *)_n)[1] = 'E';   \
+		((uint8_t *)_n)[2] = 'M';   \
+		((uint8_t *)_n)[3] = 'M';   \
+	} while (0)
+
+#define IS_MEMM_MAGIC_VALID(_n)  \
+	(('M' == ((uint8_t *)_n)[0]) && \
+	('E' == ((uint8_t *)_n)[1]) && \
+	('M' == ((uint8_t *)_n)[2]) && \
+	('M' == ((uint8_t *)_n)[3]))
+
+#define CLEANUP_MEMM_MAGIC(_n) \
+	do {                            \
+		((uint8_t *)_n)[0] = '\0';   \
+		((uint8_t *)_n)[1] = '\0';   \
+		((uint8_t *)_n)[2] = '\0';   \
+		((uint8_t *)_n)[3] = '\0';   \
+	} while (0)
+
+#define TEE_MEMM_UNINIT	(0xACACACAC)
+
+typedef struct _tee_memm_handle_t {
+	uint8_t magic[MAGIC_NUM];
+	uint32_t reserve;
+} tee_memm_handle_t;
+
+#ifdef CONFIG_MINI_MARVELLTEE
+
+#ifdef CONFIG_64BIT
+/* The value of __PAGE_SIZE should be aligned with the one in OBM
+ * Loader/Platforms/EDEN/mmu.c
+ */
+#define __PAGE_SIZE		(0x200000)
+typedef union {
+	struct {
+		ulong_t  rsvd:56;
+		uint32_t inner:4;
+		uint32_t outer:4;
+	} bits;
+	ulong_t all;
+} phy_addr_reg;
+#else
+typedef union {
+	struct {
+		ulong_t  rsvd:2;
+		uint32_t outer:2;
+		uint32_t inner:3;
+	} bits;
+	uint32_t all;
+} phy_addr_reg;
+#endif
+
+#define PHYS_ADDR_BITS (0xFFFFFFFFFFFF)
+static void *_osa_virt_to_phys_by_cp15_ex(ulong_t virt, bool *cacheable)
+{
+#ifdef CONFIG_64BIT
+	volatile ulong_t ret;
+	phy_addr_reg par;
+
+	__asm__ __volatile__("at s1e2r, %0" : : "r"(virt));
+	__asm__ __volatile__("mrs %0, par_el1" : "=r"(ret) : );
+
+	par.all = ret;
+	if (par.bits.outer == 0x4 &&
+		par.bits.inner == 0x4)
+		*cacheable = false;
+	else
+		*cacheable = true;
+
+	ret &= ~(__PAGE_SIZE - 1);
+	ret |= (virt & (__PAGE_SIZE - 1));
+	ret &= PHYS_ADDR_BITS;
+
+	return (void *)ret;
+#else
+	volatile ulong_t ret;
+	phy_addr_reg par;
+
+	/* fail to get the phys_addr when using 0, c7, c8, 1 */
+	__asm__ __volatile__("mcr p15, 0, %1, c7, c8, 0\n\t"
+		"mrc p15, 0, %0, c7, c4, 0\n\t" : "=r"(ret) : "r"
+		(virt));
+
+	par.all = ret;
+	if (par.bits.outer == 0x0 &&
+	   (par.bits.inner & 0x4) == 0x0)
+		*cacheable = false;
+	else if (par.bits.outer > 0x0 &&
+			(par.bits.inner & 0x4) == 0x4)
+		*cacheable = true;
+	else
+		OSA_ASSERT(0);
+	ret &= ~(PAGE_SIZE - 1);
+	ret |= (virt & (PAGE_SIZE - 1));
+
+	return (void *)ret;
+#endif
+}
+
+#endif /* CONFIG_MINI_MARVELLTEE */
+
+static inline void *osa_ext_virt_to_phys(void *virt_addr, bool *cacheable_cur)
+{
+#ifdef CONFIG_MINI_MARVELLTEE
+	volatile ulong_t ret;
+
+#ifdef CONFIG_64BIT
+	__asm__ __volatile__("mrs %0, SCTLR_EL2" : "=r"(ret) : );
+#else
+	__asm__ __volatile__("MRC p15, 0, %0, c1, c0, 0" : "=r"(ret) : );
+#endif
+
+	if (ret & MMU_ENABLE_BIT) {
+		/* MMU enabled in EL2 */
+		void *phys_addr;
+
+		phys_addr = _osa_virt_to_phys_by_cp15_ex(
+			(ulong_t)virt_addr, cacheable_cur);
+		return phys_addr;
+	} else {
+		return virt_addr;
+	}
+
+#else
+	return osa_virt_to_phys_ex((void *)virt_addr, cacheable_cur);
+#endif
+}
+
+tee_memm_ss_t tee_memm_create_ss(void)
+{
+	tee_memm_handle_t *tee_memm_handle;
+
+	tee_memm_handle = osa_kmem_alloc(sizeof(tee_memm_handle_t));
+	if (!tee_memm_handle)
+		return NULL;
+
+	memset(tee_memm_handle, 0, sizeof(tee_memm_handle_t));
+	INIT_MEMM_MAGIC(tee_memm_handle->magic);
+
+	return (tee_memm_ss_t) tee_memm_handle;
+}
+
+void tee_memm_destroy_ss(tee_memm_ss_t tee_memm_ss)
+{
+	tee_memm_handle_t *tee_memm_handle;
+
+	if (!tee_memm_ss)
+		return;
+
+	tee_memm_handle = (tee_memm_handle_t *) tee_memm_ss;
+	if (!(IS_MEMM_MAGIC_VALID(tee_memm_handle->magic)))
+		return;
+
+	CLEANUP_MEMM_MAGIC(tee_memm_handle->magic);
+
+	osa_kmem_free(tee_memm_handle);
+}
+
+/* if pages = NULL, return pages_num
+ * if pages_num = NULL, return pages
+*/
+tee_stat_t tee_memm_set_phys_pages(tee_memm_ss_t tee_memm_ss,
+				void *virt, uint32_t size,
+				tee_mem_page_t *pages, uint32_t *pages_num)
+{
+	uint32_t num = 0;
+	ulong_t base = (ulong_t)virt;
+	uint32_t length = size;
+	tee_memm_handle_t *tee_memm_handle;
+
+	uint8_t *buf;
+	tee_mem_page_t *page;
+	tee_mem_page_t tmp;
+	uint32_t tmp_len = 0;
+	uint32_t count = 0;
+	bool cacheable_cur = false, cacheable_base = false;
+
+	if (!tee_memm_ss || !virt)
+		OSA_ASSERT(0);
+
+	if (!pages && !pages_num)
+		OSA_ASSERT(0);
+
+	tee_memm_handle = (tee_memm_handle_t *) tee_memm_ss;
+	if (!(IS_MEMM_MAGIC_VALID(tee_memm_handle->magic)))
+		OSA_ASSERT(0);
+
+	size += base & (~PAGE_MASK);
+	num = size / PAGE_SIZE;
+	if (size & (PAGE_SIZE - 1))
+		num++;
+
+	/* NOTE: num >= count, so alloc enough memory. !!!FIXME!!! */
+	buf = osa_vmem_alloc(
+	num * sizeof(tee_mem_page_t), OSA_MEM_READ_WRITE);
+	OSA_ASSERT(buf != NULL);
+
+	memset(buf, 0, sizeof(num * sizeof(tee_mem_page_t)));
+
+	page = (tee_mem_page_t *)buf;
+	tmp.phy_addr = NULL;
+	tmp.len = 0;
+
+	page->phy_addr = osa_ext_virt_to_phys((void *)base, &cacheable_base);
+	while (base < ((ulong_t)virt + length)) {
+		page->phy_addr = osa_ext_virt_to_phys((void *)base, &cacheable_cur);
+		if (base == (ulong_t) virt) {
+			/* the first page */
+			tmp.len = PAGE_SIZE - (base - (base & PAGE_MASK));
+			if (tmp.len > length)
+				tmp.len = length;
+			tmp_len = tmp.len;
+		} else if (((ulong_t) virt + length) - base <= PAGE_SIZE) {
+			/* the last page */
+			tmp_len = ((ulong_t) virt + length) - base;
+		} else {
+			tmp_len = PAGE_SIZE;
+		}
+
+		if (page->phy_addr == (tmp.phy_addr + tmp.len) &&
+			cacheable_cur == cacheable_base) {
+			page--;
+			page->len += tmp_len;
+		} else {
+			page->len = tmp_len;
+			page->cacheable = cacheable_cur;
+			count++;
+		}
+
+		tmp.phy_addr = page->phy_addr;
+		tmp.len = page->len;
+		page++;
+
+		base = (base & PAGE_MASK) + PAGE_SIZE;
+		cacheable_base = cacheable_cur;
+	}
+
+	if (pages_num)
+		*pages_num = count;
+
+	if (pages)
+		memcpy(pages, buf, count * sizeof(tee_mem_page_t));
+	osa_vmem_free(buf);
+
+	return TEEC_SUCCESS;
+}
+
+#ifndef CONFIG_MINI_MARVELLTEE
+tee_stat_t tee_memm_get_user_mem(tee_memm_ss_t tee_memm_ss,
+				void __user *virt, uint32_t size,
+				void __kernel **kvirt)
+{
+	ulong_t start = (ulong_t) virt;
+	ulong_t end = (start + size + PAGE_SIZE - 1) & PAGE_MASK;
+
+	struct vm_area_struct *vma;
+	ulong_t cur = start & PAGE_MASK, cur_end;
+	int32_t err, write;
+	tee_memm_handle_t *tee_memm_handle;
+
+	OSA_ASSERT(virt && tee_memm_ss);
+
+	tee_memm_handle = (tee_memm_handle_t *) tee_memm_ss;
+	if (!(IS_MEMM_MAGIC_VALID(tee_memm_handle->magic)))
+		OSA_ASSERT(0);
+
+	down_read(&current->mm->mmap_sem);
+
+	do {
+		vma = find_vma(current->mm, cur);
+		if (!vma) {
+			up_read(&current->mm->mmap_sem);
+			*kvirt = NULL;
+			return TEEC_SUCCESS;
+		}
+		cur_end = ((end <= vma->vm_end) ? end : vma->vm_end);
+
+		/* this vma is NOT mmap-ed and pfn-direct mapped */
+		if (!(vma->vm_flags & (VM_IO | VM_PFNMAP))) {
+			write = ((vma->vm_flags & VM_WRITE) != 0);
+			/* NOTE: no get_page since overall sync-flow */
+			err = get_user_pages(current, current->mm,
+						(ulong_t) cur,
+						(cur_end - cur) >> PAGE_SHIFT,
+						write, 0, NULL, NULL);
+			if (err < 0) {
+				up_read(&current->mm->mmap_sem);
+				*kvirt = NULL;
+				return TEEC_SUCCESS;
+			}
+		}
+
+		cur = cur_end;
+	} while (cur_end < end);
+
+	up_read(&current->mm->mmap_sem);
+
+	*kvirt = virt;
+
+	/* fake wtm_vm handle here */
+	return TEEC_SUCCESS;
+}
+
+void tee_memm_put_user_mem(tee_memm_ss_t tee_memm_ss, void *vm)
+{
+	tee_memm_handle_t *tee_memm_handle;
+
+	tee_memm_handle = (tee_memm_handle_t *) tee_memm_ss;
+	if (!(IS_MEMM_MAGIC_VALID(tee_memm_handle->magic)))
+		OSA_ASSERT(0);
+
+	OSA_ASSERT(vm);
+
+	/* nothing */
+}
+#endif /* CONFIG_MINI_MARVELLTEE */
diff --git a/drivers/marvell/security/marvelltee/src/memm/tee_memm_internal.h b/drivers/marvell/security/marvelltee/src/memm/tee_memm_internal.h
new file mode 100644
index 0000000..b014ab3
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/memm/tee_memm_internal.h
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+
+#ifndef _TEE_MEMM_INTERNAL_H_
+#define _TEE_MEMM_INTERNAL_H_
+
+#include "osa.h"
+#include "tee_msgm_ntw.h"
+#include "tee_memm.h"
+
+#endif /* _TEE_MEMM_INTERNAL_H_ */
diff --git a/drivers/marvell/security/marvelltee/src/msgm/ntw/tee_msgm_can_op.c b/drivers/marvell/security/marvelltee/src/msgm/ntw/tee_msgm_can_op.c
new file mode 100644
index 0000000..353c30b
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/msgm/ntw/tee_msgm_can_op.c
@@ -0,0 +1,63 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+#include "tee_client_api.h"
+#include "tee_msgm_op_internal.h"
+
+tee_stat_t set_cmd_can_op(tee_msgm_t msgm, void *arg)
+{
+	can_op_body *ptr = NULL;
+	tee_set_cmd_can_op_arg_t *src = NULL;
+	tee_msgm_ntw_struct *ntw_handle = NULL;
+	_TEEC_MRVL_Operation *_teec_mrvl_operation;
+
+	src = (tee_set_cmd_can_op_arg_t *) arg;
+	ntw_handle = (tee_msgm_ntw_struct *) msgm;
+	ptr = (can_op_body *) ntw_handle->body;
+	ptr->ss_tw = src->ss;
+
+	_teec_mrvl_operation = (_TEEC_MRVL_Operation *) (src->operation->imp);
+	ptr->tee_msg_ntw = _teec_mrvl_operation->tee_msg_ntw;
+	return TEEC_SUCCESS;
+}
+
+tee_stat_t get_cmd_can_op(tee_msgm_t msgm, void *arg)
+{
+	can_op_body *ptr = NULL;
+	tee_get_cmd_can_op_arg_t *dst = NULL;
+	tee_msgm_ntw_struct *ntw_handle = NULL;
+
+	dst = (tee_get_cmd_can_op_arg_t *) arg;
+	ntw_handle = (tee_msgm_ntw_struct *) msgm;
+	ptr = (can_op_body *) ntw_handle->body;
+	dst->ss = ptr->ss_tw;
+	dst->msg = ptr->tee_msg_ntw;
+	return TEEC_SUCCESS;
+}
+
+bool cmd_class_can_op(tee_cmd_t cmd)
+{
+	return (cmd == TEE_CMD_CAN_OP);
+}
+
+const tee_msgm_op_class can_op_class = {
+	.set_cmd = set_cmd_can_op,
+	.get_cmd = get_cmd_can_op,
+	.set_ret = NULL,
+	.get_ret = NULL,
+	.cmd_class = cmd_class_can_op,
+};
diff --git a/drivers/marvell/security/marvelltee/src/msgm/ntw/tee_msgm_close_ss.c b/drivers/marvell/security/marvelltee/src/msgm/ntw/tee_msgm_close_ss.c
new file mode 100644
index 0000000..daea71b
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/msgm/ntw/tee_msgm_close_ss.c
@@ -0,0 +1,58 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+#include "tee_client_api.h"
+#include "tee_msgm_op_internal.h"
+
+tee_stat_t set_cmd_close_ss(tee_msgm_t msgm, void *arg)
+{
+	close_ss_body *dst = NULL;
+	tee_set_cmd_close_ss_arg_t src = NULL;
+	tee_msgm_ntw_struct *ntw_handle = NULL;
+
+	src = (tee_set_cmd_close_ss_arg_t) arg;
+	ntw_handle = (tee_msgm_ntw_struct *) msgm;
+	dst = (close_ss_body *) ntw_handle->body;
+	dst->ss_tw = src;
+	return TEEC_SUCCESS;
+}
+
+tee_stat_t get_cmd_close_ss(tee_msgm_t msgm, void *arg)
+{
+	close_ss_body *src = NULL;
+	tee_get_cmd_close_ss_arg_t *dst = NULL;
+	tee_msgm_ntw_struct *ntw_handle = NULL;
+
+	dst = (tee_get_cmd_close_ss_arg_t *) arg;
+	ntw_handle = (tee_msgm_ntw_struct *) msgm;
+	src = (close_ss_body *) ntw_handle->body;
+	dst->ss = src->ss_tw;
+	return TEEC_SUCCESS;
+}
+
+bool cmd_class_close_ss(tee_cmd_t cmd)
+{
+	return (cmd == TEE_CMD_CLOSE_SS);
+}
+
+const tee_msgm_op_class close_ss_class = {
+	.set_cmd = set_cmd_close_ss,
+	.get_cmd = get_cmd_close_ss,
+	.set_ret = NULL,
+	.get_ret = NULL,
+	.cmd_class = cmd_class_close_ss,
+};
diff --git a/drivers/marvell/security/marvelltee/src/msgm/ntw/tee_msgm_handle_params.c b/drivers/marvell/security/marvelltee/src/msgm/ntw/tee_msgm_handle_params.c
new file mode 100644
index 0000000..e8f0c09
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/msgm/ntw/tee_msgm_handle_params.c
@@ -0,0 +1,169 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+#include "tee_client_api.h"
+#ifndef CONFIG_MINI_MARVELLTEE
+#include "marvelltee_internal.h"
+#else
+#include "mini_marvelltee_internal.h"
+#endif
+#define IS_TYPE_UNMATCH_PARENT_FLAG(_m, _n) (((_n) ^ (_m)) & (_n) & 0x3)
+const char cmd_magic[] = "CmDm";
+#include "tee_msgm_op_internal.h"
+
+#define ALIGN_SIZE  (sizeof(void *))
+#define ROUND_UP(_v, _a)        (((size_t)(_v) + (_a) - 1) & (~((_a) - 1)))
+
+tee_stat_t set_params(tee_msgm_t msgm, tee_msg_op_info_t *arg)
+{
+	params_struct *dst = NULL;
+	uint32_t index = 0, value = 0;
+	uint8_t *last = NULL;
+	tee_msgm_ntw_struct *ntw_handle = NULL;
+	_TEEC_MRVL_SharedMemory *_teec_mrvl_sharedMem;
+
+	ntw_handle = (tee_msgm_ntw_struct *) msgm;
+	dst = ntw_handle->ntw_params;
+	if (!dst)
+		return TEEC_SUCCESS;
+	last = (uint8_t *) dst + sizeof(params_struct);
+	dst->paramTypes = arg->paramTypes;
+
+	for (index = 0; index < PARAM_NUMBERS; index++) {
+		value = TEEC_PARAM_TYPE_GET(arg->paramTypes, index);
+		if (IS_TYPE_NONE(value)) {
+			memset(&(dst->param[index].value), 0,
+			       sizeof(Union_Parameter));
+			continue;
+		}
+
+		if (IS_TYPE_TMPREF(value)) {
+			if (IS_PARAM_TAGED_INPUT(value)) {
+				/* type of input */
+				if (arg->params[index].tmpref.buffer) {
+					memcpy(last,
+					       arg->params[index].tmpref.buffer,
+					       arg->params[index].tmpref.size);
+				}
+			} else {
+				/* type of output, so clear it */
+				memset(last, 0, arg->params[index].tmpref.size);
+			}
+			dst->param[index].tmpref.buffer =
+			    (void *)(last -
+				     ((uint8_t *) dst +
+				      OFFSETOF(params_struct, param[index])));
+			dst->param[index].tmpref.size =
+			    arg->params[index].tmpref.size;
+			last += dst->param[index].tmpref.size;
+			last = (uint8_t *)ROUND_UP(last, ALIGN_SIZE);
+		} else if (IS_TYPE_MEMREF(value)) {
+			/* for memref */
+			if (value == TEEC_MEMREF_WHOLE) {
+				_teec_mrvl_sharedMem =
+					(_TEEC_MRVL_SharedMemory *)(arg->params[index].memref.parent->imp);
+				dst->param[index].memref.buffer =
+				    _teec_mrvl_sharedMem->vaddr_tw;
+				dst->param[index].memref.size =
+				    arg->params[index].memref.parent->size;
+			} else {
+				if (IS_TYPE_UNMATCH_PARENT_FLAG
+				    (arg->params[index].memref.parent->flags,
+				     value)) {
+					MARVELLTEE_DBG("set_params: in/out un-compatible\n");
+					return TEEC_ERROR_BAD_PARAMETERS;
+				}
+				OSA_ASSERT((arg->params[index].memref.offset +
+					    arg->params[index].memref.size <=
+					    arg->params[index].memref.parent->
+					    size));
+
+				_teec_mrvl_sharedMem = (_TEEC_MRVL_SharedMemory *)(arg->
+				params[index].memref.parent->imp);
+
+				dst->param[index].memref.buffer =
+				    _teec_mrvl_sharedMem->vaddr_tw +
+				    arg->params[index].memref.offset;
+				dst->param[index].memref.size =
+				    arg->params[index].memref.size;
+			}
+		} else if (IS_TYPE_VALUE(value)
+			&& IS_PARAM_TAGED_INPUT(value)) {
+			dst->param[index].value.a = arg->params[index].value.a;
+			dst->param[index].value.b = arg->params[index].value.b;
+		} else {
+			MARVELLTEE_DBG("set_params: no input\n");
+		}
+	}
+	return TEEC_SUCCESS;
+}
+
+/*
+ * get temp_memref to tw/ntw
+ * in ntw: set-> set offset and convert to abstract-addr
+ * get-> get buffer and convert to relative-addr
+ */
+tee_stat_t update_params(tee_msgm_t msgm, tee_msg_op_info_t *arg)
+{
+	params_struct *src = NULL;
+	uint32_t index = 0, value = 0;
+	uint8_t *last = NULL, *start = NULL;
+	TEEC_Result stat = TEEC_SUCCESS;
+	tee_msgm_ntw_struct *ntw_handle = NULL;
+
+	ntw_handle = (tee_msgm_ntw_struct *) msgm;
+	src = ntw_handle->ntw_params;
+	if (!src)
+		return stat;
+
+	start = (uint8_t *) src;
+	arg->paramTypes = src->paramTypes;
+
+	for (index = 0; index < PARAM_NUMBERS; index++) {
+		value = TEEC_PARAM_TYPE_GET(src->paramTypes, index);
+		if (IS_TYPE_NONE(value)
+		    || (!IS_PARAM_TAGED_OUTPUT(value) && (value != 0xc))) {
+			continue;
+		}
+
+		if (IS_TYPE_TMPREF(value) || IS_TYPE_MEMREF(value)) {
+			/* update size, update content if tmpref */
+			if (src->param[index].memref.size >
+			    arg->params[index].memref.size) {
+				MARVELLTEE_DBG("Warning: short buffer\n");
+			} else if (IS_TYPE_TMPREF(value)) {
+				last =
+				    start + OFFSETOF(params_struct,
+						     param[index]) +
+				    (ulong_t) src->param[index].memref.buffer;
+				if (arg->params[index].tmpref.buffer) {
+					memcpy(arg->params[index].tmpref.buffer,
+					       last,
+					       src->param[index].memref.size);
+				}
+			}
+			arg->params[index].memref.size =
+			    src->param[index].memref.size;
+		} else if (IS_TYPE_VALUE(value)) {
+			arg->params[index].value.a = src->param[index].value.a;
+			arg->params[index].value.b = src->param[index].value.b;
+		} else {
+			MARVELLTEE_DBG("update_params: index is TEEC_NONE\n");
+		}
+	}
+	return stat;
+}
diff --git a/drivers/marvell/security/marvelltee/src/msgm/ntw/tee_msgm_inv_op.c b/drivers/marvell/security/marvelltee/src/msgm/ntw/tee_msgm_inv_op.c
new file mode 100644
index 0000000..85570fa
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/msgm/ntw/tee_msgm_inv_op.c
@@ -0,0 +1,88 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+#include "tee_client_api.h"
+#include "tee_msgm_op_internal.h"
+
+tee_stat_t set_cmd_inv_op(tee_msgm_t msgm, void *arg)
+{
+	inv_op_body *dst = NULL;
+	tee_set_cmd_inv_op_arg_t *src = NULL;
+	tee_msgm_ntw_struct *ntw_handle = NULL;
+
+	src = (tee_set_cmd_inv_op_arg_t *) arg;
+	ntw_handle = (tee_msgm_ntw_struct *) msgm;
+	dst = (inv_op_body *) ntw_handle->body;
+	dst->srv_cmd = src->srv_cmd;
+	dst->ss_tw = src->ss;
+	return TEEC_SUCCESS;
+}
+
+tee_stat_t get_cmd_inv_op(tee_msgm_t msgm, void *arg)
+{
+	inv_op_body *src = NULL;
+	tee_get_cmd_inv_op_arg_t *dst = NULL;
+	tee_msgm_ntw_struct *ntw_handle = NULL;
+
+	dst = (tee_get_cmd_inv_op_arg_t *) arg;
+	ntw_handle = (tee_msgm_ntw_struct *) msgm;
+	src = (inv_op_body *) ntw_handle->body;
+	dst->ss = src->ss_tw;
+	dst->srv_cmd = src->srv_cmd;
+	return TEEC_SUCCESS;
+}
+
+tee_stat_t set_ret_inv_op(tee_msgm_t msgm, void *arg)
+{
+	inv_op_body *dst = NULL;
+	tee_set_ret_inv_op_arg_t *src = NULL;
+	tee_msgm_ntw_struct *ntw_handle = NULL;
+
+	src = (tee_set_ret_inv_op_arg_t *) arg;
+	ntw_handle = (tee_msgm_ntw_struct *) msgm;
+	dst = (inv_op_body *) ntw_handle->body;
+	dst->ret_orig = src->ret_orig;
+	dst->ret = src->ret;
+	return TEEC_SUCCESS;
+}
+
+tee_stat_t get_ret_inv_op(tee_msgm_t msgm, void *arg)
+{
+	inv_op_body *src = NULL;
+	tee_get_ret_inv_op_arg_t *dst = NULL;
+	tee_msgm_ntw_struct *ntw_handle = NULL;
+
+	dst = (tee_get_ret_inv_op_arg_t *) arg;
+	ntw_handle = (tee_msgm_ntw_struct *) msgm;
+	src = (inv_op_body *) ntw_handle->body;
+	dst->ret_orig = src->ret_orig;
+	dst->ret = src->ret;
+	return TEEC_SUCCESS;
+}
+
+bool cmd_class_inv_op(tee_cmd_t cmd)
+{
+	return (cmd == TEE_CMD_INV_OP);
+}
+
+const tee_msgm_op_class inv_op_class = {
+	.set_cmd = set_cmd_inv_op,
+	.get_cmd = get_cmd_inv_op,
+	.set_ret = set_ret_inv_op,
+	.get_ret = get_ret_inv_op,
+	.cmd_class = cmd_class_inv_op,
+};
diff --git a/drivers/marvell/security/marvelltee/src/msgm/ntw/tee_msgm_map_shm.c b/drivers/marvell/security/marvelltee/src/msgm/ntw/tee_msgm_map_shm.c
new file mode 100644
index 0000000..83888d5
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/msgm/ntw/tee_msgm_map_shm.c
@@ -0,0 +1,111 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+#include "tee_client_api.h"
+
+#ifndef CONFIG_MINI_MARVELLTEE
+#include "marvelltee_internal.h"
+#else
+#include "mini_marvelltee_internal.h"
+#endif
+
+#include "tee_memm.h"
+#include "tee_msgm_op_internal.h"
+
+tee_stat_t set_cmd_map_shm(tee_msgm_t msgm, void *arg)
+{
+	uint32_t pages_num = 0;
+	tee_memm_ss_t memm_handle = NULL;
+	map_shm_body *ptr = NULL;
+	tee_set_cmd_map_shm_arg_t *src = NULL;
+	tee_stat_t ntw_stat = TEEC_SUCCESS;
+	tee_msgm_ntw_struct *ntw_handle = NULL;
+
+	memm_handle = tee_memm_create_ss();
+	src = (tee_set_cmd_map_shm_arg_t *) arg;
+	ntw_handle = (tee_msgm_ntw_struct *) msgm;
+	ptr = (map_shm_body *) ntw_handle->body;
+
+	ntw_stat = tee_memm_set_phys_pages(
+			   memm_handle,
+			   src->shm->buffer, src->shm->size,
+			   (tee_msgm_phys_memblock_t *)((uint8_t *)ptr +
+			   sizeof(map_shm_body)), &pages_num);
+	if (ntw_stat != TEEC_SUCCESS)
+		return ntw_stat;
+
+	tee_memm_destroy_ss(memm_handle);
+	ptr->arr_sz = pages_num;
+	ptr->flags = src->shm->flags;
+	ptr->cntx = src->cntx;
+	return TEEC_SUCCESS;
+}
+
+tee_stat_t get_cmd_map_shm(tee_msgm_t msgm, void *arg)
+{
+	map_shm_body *src = NULL;
+	tee_get_cmd_map_shm_arg_t *dst = NULL;
+	tee_msgm_ntw_struct *ntw_handle = NULL;
+
+	dst = (tee_get_cmd_map_shm_arg_t *) arg;
+	ntw_handle = (tee_msgm_ntw_struct *) msgm;
+	src = (map_shm_body *) ntw_handle->body;
+	dst->arr_sz = src->arr_sz;
+	dst->arr = (tee_msgm_phys_memblock_t(*)[])src->arr;
+	return TEEC_SUCCESS;
+}
+
+tee_stat_t set_ret_map_shm(tee_msgm_t msgm, void *arg)
+{
+	map_shm_body *dst = NULL;
+	tee_set_ret_map_shm_arg_t *src = NULL;
+	tee_msgm_ntw_struct *ntw_handle = NULL;
+
+	src = (tee_set_ret_map_shm_arg_t *) arg;
+	ntw_handle = (tee_msgm_ntw_struct *) msgm;
+	dst = (map_shm_body *) ntw_handle->body;
+	dst->vaddr_tw = src->vaddr_tw;
+	dst->ret = src->ret;
+	return TEEC_SUCCESS;
+}
+
+tee_stat_t get_ret_map_shm(tee_msgm_t msgm, void *arg)
+{
+	map_shm_body *src = NULL;
+	tee_get_ret_map_shm_arg_t *dst = NULL;
+	tee_msgm_ntw_struct *ntw_handle = NULL;
+
+	dst = (tee_get_ret_map_shm_arg_t *) arg;
+	ntw_handle = (tee_msgm_ntw_struct *) msgm;
+	src = (map_shm_body *) ntw_handle->body;
+	dst->vaddr_tw = src->vaddr_tw;
+	dst->ret = src->ret;
+	return TEEC_SUCCESS;
+}
+
+bool cmd_class_map_shm(tee_cmd_t cmd)
+{
+	return (cmd == TEE_CMD_MAP_SHM);
+}
+
+const tee_msgm_op_class map_shm_class = {
+	.set_cmd = set_cmd_map_shm,
+	.get_cmd = get_cmd_map_shm,
+	.set_ret = set_ret_map_shm,
+	.get_ret = get_ret_map_shm,
+	.cmd_class = cmd_class_map_shm,
+};
diff --git a/drivers/marvell/security/marvelltee/src/msgm/ntw/tee_msgm_ntw.c b/drivers/marvell/security/marvelltee/src/msgm/ntw/tee_msgm_ntw.c
new file mode 100644
index 0000000..74c654d
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/msgm/ntw/tee_msgm_ntw.c
@@ -0,0 +1,364 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+#include "tee_msgm_ntw.h"
+#include "tee_msgm_op_internal.h"
+#ifndef CONFIG_MINI_MARVELLTEE
+#include "marvelltee_internal.h"
+#else
+#include "mini_marvelltee_internal.h"
+#endif
+#include "tee_memm.h"
+
+#define ALIGN_SIZE  (sizeof(void *))
+#define ROUND_UP(_v, _a)        (((size_t)(_v) + (_a) - 1) & (~((_a) - 1)))
+
+extern const char cmd_magic[];
+static uint8_t magic[] = { 'm', 'N', 'T', 'W', };
+
+#define INIT_MAGIC(_m)	\
+	do {                                \
+		((uint8_t *)(_m))[0] = magic[0]; \
+		((uint8_t *)(_m))[1] = magic[1]; \
+		((uint8_t *)(_m))[2] = magic[2]; \
+		((uint8_t *)(_m))[3] = magic[3]; \
+	} while (0)
+#define IS_MAGIC_VALID(_m) \
+	((magic[0] == ((uint8_t *)(_m))[0]) && \
+	(magic[1] == ((uint8_t *)(_m))[1]) &&  \
+	(magic[2] == ((uint8_t *)(_m))[2]) &&  \
+	(magic[3] == ((uint8_t *)(_m))[3]))
+#define CLEANUP_MAGIC(_m) \
+	do {                                \
+		((uint8_t *)(_m))[0] = '\0';    \
+		((uint8_t *)(_m))[1] = '\0';    \
+		((uint8_t *)(_m))[2] = '\0';    \
+		((uint8_t *)(_m))[3] = '\0';    \
+	} while (0)
+#define IS_PARAMTYPES_TYPE_VALID(_m) \
+	(IS_TYPE_NONE(_m) || \
+	 IS_TYPE_VALUE(_m) || \
+	IS_TYPE_TMPREF(_m) || \
+	IS_TYPE_MEMREF(_m))
+#define IS_NTW_MEM_FLAG_VALID(_m) ((_m) > 0 && (_m) < 4)
+static uint32_t _g_body_size_array[] = {
+	0, MAP_SHM_SZ, UNMAP_SHM_SZ, OPEN_SS_SZ,
+	CLOSE_SS_SZ, INV_OP_SZ, CAN_OP_SZ,
+};
+
+const tee_msgm_op_class *_g_op_array[] = {
+	NULL, &map_shm_class, &unmap_shm_class,
+	&open_ss_class, &close_ss_class,
+	&inv_op_class, &can_op_class,
+};
+
+/* ********************
+ * create instance
+ * ********************/
+tee_msgm_t tee_msgm_create_inst(void)
+{
+	tee_msgm_ntw_struct *handle = NULL;
+
+	handle =
+	    (tee_msgm_ntw_struct *) osa_kmem_alloc(sizeof(tee_msgm_ntw_struct));
+	if (handle == NULL) {
+		MARVELLTEE_DBG("In tee_msgm_create_inst, alloc err\n");
+		goto err;
+	}
+	osa_memset(handle, 0, sizeof(tee_msgm_ntw_struct));
+	INIT_MAGIC(handle->magic);
+	handle->ntw_cmd = NULL;
+	handle->body = NULL;
+	handle->op = NULL;
+	handle->cmd_record.cmd = TEE_CMD_INVALID;
+	handle->cmd_record.cmd_sz = 0;
+	handle->cmd_record.param_size = 0;
+	handle->cmd_record.stat = TEE_NTW_CMD_STAT_CLEAR;
+	return (tee_msgm_t) handle;
+err:
+	MARVELLTEE_DBG("In tee_msgm_create_inst err\n");
+	return NULL;
+}
+
+/* ******************************
+ * will not destroy the msg buf
+ * *******************************/
+void tee_msgm_destroy_inst(tee_msgm_t msgm)
+{
+	tee_msgm_ntw_struct *ntw_handle = NULL;
+
+	OSA_ASSERT(msgm);
+	ntw_handle = (tee_msgm_ntw_struct *) msgm;
+	OSA_ASSERT(IS_MAGIC_VALID(ntw_handle->magic));
+	CLEANUP_MAGIC(ntw_handle->magic);
+	osa_kmem_free(ntw_handle);
+	ntw_handle = NULL;
+}
+
+/* ************************************
+ * calculate the sizo of tmp_memref
+ * ************************************/
+static inline tee_stat_t _calc_map_shm_len(TEEC_SharedMemory *obj,
+					   uint32_t *num)
+{
+	tee_memm_ss_t memm_handle = NULL;
+	tee_stat_t ntw_stat = TEEC_SUCCESS;
+
+	memm_handle = tee_memm_create_ss();
+	OSA_ASSERT(memm_handle);
+	ntw_stat = tee_memm_set_phys_pages(
+		memm_handle,
+		obj->buffer, obj->size,
+		NULL, num);
+	if (ntw_stat != TEEC_SUCCESS)
+		return ntw_stat;
+
+	tee_memm_destroy_ss(memm_handle);
+	memm_handle = NULL;
+	return TEEC_SUCCESS;
+}
+
+/* *************************************************************************
+ * "buf = NULL" to get the buf size first
+ *
+ * the buffer does NOT include the command header.
+ * the header is maintained by callers.
+ * the typical behavior of callers is to alloc
+ * sizeof(tee_msg_head_t) + buf-size.
+ * then set "mem + sizeof(tee_msg_head_t)" as the arg, buf.
+ *
+ * send Msg: tee_msgm_set_msg_buf(msgm, mi, NULL, &size); STAT_SET
+ *           tee_msgm_set_msg_buf(msgm, NULL, buf, NULL); STAT_CLEAR
+ * receive Msg: tee_msgm_set_msg_buf(msgm, NULL, buf, NULL);
+ * ***************************************************************************/
+tee_stat_t tee_msgm_set_msg_buf(tee_msgm_t msgm, tee_msgm_msg_info_t *mi,
+				uint8_t *buf, uint32_t *size)
+{
+	tee_msgm_ntw_struct *ntw_handle = NULL;
+	uint32_t buf_size = 0, pages = 0, types = 0, idx = 0, value = 0;
+	tee_stat_t shm_stat = TEEC_SUCCESS;
+	TEEC_Operation *ntw_op = NULL;
+
+	/* either mi && size or buf non-NULL; */
+	OSA_ASSERT(((mi && size) || buf));
+	OSA_ASSERT(msgm);
+	ntw_handle = (tee_msgm_ntw_struct *) msgm;
+	OSA_ASSERT(IS_MAGIC_VALID(ntw_handle->magic));
+
+	if (buf != NULL) {
+		/* set handle-item according to buf-ptr */
+		ntw_handle->ntw_cmd = (cmd_struct *) buf;
+		ntw_handle->body = buf + sizeof(cmd_struct);
+		if (ntw_handle->cmd_record.stat == TEE_NTW_CMD_STAT_SET) {
+			/* send msg: empty buffer for set cmd and params */
+			osa_memset(buf, 0, ntw_handle->cmd_record.msg_sz);
+			INIT_CMD_MAGIC(ntw_handle->ntw_cmd->magic);
+			ntw_handle->ntw_params =
+			    (params_struct *) (ntw_handle->body +
+					       ntw_handle->cmd_record.cmd_sz);
+			ntw_handle->ntw_cmd->cmd_sz =
+			    ntw_handle->cmd_record.cmd_sz;
+			ntw_handle->op =
+			    _g_op_array[ntw_handle->cmd_record.cmd];
+			ntw_handle->cmd_record.stat = TEE_NTW_CMD_STAT_CLEAR;
+		} else {
+			/* receive msg: msg for get cmd or params */
+			OSA_ASSERT(IS_CMD_MAGIC_VALID
+				   (ntw_handle->ntw_cmd->magic));
+			ntw_handle->ntw_params =
+			    (params_struct *) (ntw_handle->body +
+					       ntw_handle->ntw_cmd->cmd_sz);
+			ntw_handle->op = _g_op_array[ntw_handle->ntw_cmd->cmd];
+		}
+	} else if (mi && size) {
+		/* send msg: calculate the size of msg-buf
+		 * according info provided by mi
+		*/
+		OSA_ASSERT(TEE_NTW_CMD_STAT_CLEAR ==
+			   ntw_handle->cmd_record.stat);
+		/* handle tmp_mem_ref */
+		if (mi->msg_op_info) {
+			ntw_op = mi->msg_op_info;
+			types = ntw_op->paramTypes;
+			for (idx = 0; idx < 4; idx++) {
+				value = TEEC_PARAM_TYPE_GET(types, idx);
+				if (IS_TYPE_TMPREF(value)) {
+					buf_size +=
+					    ntw_op->params[idx].tmpref.size;
+					buf_size = ROUND_UP(buf_size, ALIGN_SIZE);
+				}
+			}
+		}
+		/* calculate the size of cmd_body */
+		if (TEE_CMD_INVALID <= mi->cmd && TEE_CMD_CAN_OP >= mi->cmd) {
+			if (mi->cmd == TEE_CMD_MAP_SHM
+			    && mi->msg_map_shm_info != NULL) {
+				shm_stat =
+				    _calc_map_shm_len(mi->msg_map_shm_info,
+						      &pages);
+				if (shm_stat != TEEC_SUCCESS)
+					return shm_stat;
+
+				ntw_handle->cmd_record.cmd_sz =
+				    _g_body_size_array[mi->cmd] +
+				    pages * sizeof(tee_msgm_phys_memblock_t);
+			} else
+				ntw_handle->cmd_record.cmd_sz =
+				    _g_body_size_array[mi->cmd];
+		} else {
+			MARVELLTEE_DBG("ERROR: cmd not exist\n");
+			OSA_ASSERT(0);
+		}
+		/* saved rec to cmd_record */
+		ntw_handle->cmd_record.param_size = buf_size;
+		ntw_handle->cmd_record.cmd = mi->cmd;
+		ntw_handle->cmd_record.stat = TEE_NTW_CMD_STAT_SET;
+		*size = sizeof(cmd_struct) + ntw_handle->cmd_record.cmd_sz +
+		    sizeof(params_struct) + ntw_handle->cmd_record.param_size;
+		ntw_handle->cmd_record.msg_sz = *size;
+	} else {
+		MARVELLTEE_DBG("ERROR: both mi&&size and buf are NULL pointer\n");
+		OSA_ASSERT(0);
+	}
+	return TEEC_SUCCESS;
+}
+
+/* ********************
+ * set cmd in ntw
+ * ********************/
+tee_stat_t tee_msgm_set_cmd(tee_msgm_t msgm, tee_cmd_t cmd, void *arg)
+{
+	tee_msgm_ntw_struct *ntw_handle = NULL;
+	tee_stat_t set_cmd_stat = TEEC_SUCCESS;
+
+	OSA_ASSERT(msgm);
+	if (cmd == TEE_CMD_INVALID) {
+		MARVELLTEE_DBG("cmd TEE_CMD_INVALID\n");
+		return set_cmd_stat;
+	}
+	ntw_handle = (tee_msgm_ntw_struct *) msgm;
+	OSA_ASSERT(IS_MAGIC_VALID(ntw_handle->magic));
+	INIT_CMD_MAGIC(ntw_handle->ntw_cmd->magic);
+
+	ntw_handle->ntw_cmd->cmd = cmd;
+	if (arg != NULL)
+		set_cmd_stat = ntw_handle->op->set_cmd(msgm, arg);
+
+	return set_cmd_stat;
+}
+
+/* ******************
+ * get cmd in ntw
+ * *******************/
+tee_stat_t tee_msgm_get_cmd(tee_msgm_t msgm, tee_cmd_t *cmd, void *arg)
+{
+	tee_msgm_ntw_struct *ntw_handle = NULL;
+	tee_stat_t get_cmd_stat = TEEC_SUCCESS;
+
+	OSA_ASSERT(msgm);
+	OSA_ASSERT((cmd || arg));
+	ntw_handle = (tee_msgm_ntw_struct *) msgm;
+	OSA_ASSERT(IS_MAGIC_VALID(ntw_handle->magic));
+
+	if (cmd != NULL)
+		*cmd = ntw_handle->ntw_cmd->cmd;
+
+	if (arg != NULL)
+		get_cmd_stat = ntw_handle->op->get_cmd(msgm, arg);
+
+	return get_cmd_stat;
+}
+
+/* *****************
+ * get ret in ntw
+ * *****************/
+tee_stat_t tee_msgm_get_ret(tee_msgm_t msgm, void *arg)
+{
+	tee_msgm_ntw_struct *ntw_handle = NULL;
+	tee_stat_t get_ret_stat = TEEC_SUCCESS;
+
+	OSA_ASSERT(msgm);
+	ntw_handle = (tee_msgm_ntw_struct *) msgm;
+	OSA_ASSERT(IS_MAGIC_VALID(ntw_handle->magic));
+
+	if (arg != NULL)
+		get_ret_stat = ntw_handle->op->get_ret(msgm, arg);
+
+	return get_ret_stat;
+}
+
+/* ****************
+ * set ret in ntw
+ * ****************/
+tee_stat_t tee_msgm_set_ret(tee_msgm_t msgm, void *arg)
+{
+	tee_msgm_ntw_struct *ntw_handle = NULL;
+	tee_stat_t set_ret_stat = TEEC_SUCCESS;
+
+	OSA_ASSERT((arg && msgm));
+	ntw_handle = (tee_msgm_ntw_struct *) msgm;
+	OSA_ASSERT(IS_MAGIC_VALID(ntw_handle->magic));
+
+	set_ret_stat = ntw_handle->op->set_ret(msgm, arg);
+	return set_ret_stat;
+}
+
+/* *********************
+ * set params in ntw
+ * *********************/
+tee_stat_t tee_msgm_set_params(tee_msgm_t msgm, tee_msg_op_info_t *params)
+{
+	tee_msgm_ntw_struct *ntw_handle = NULL;
+	tee_stat_t set_params_stat = TEEC_SUCCESS;
+	uint32_t times = PARAM_NUMBERS, idx = 0, type = TEEC_NONE;
+
+	OSA_ASSERT((msgm && params));
+	ntw_handle = (tee_msgm_ntw_struct *) msgm;
+	OSA_ASSERT(IS_MAGIC_VALID(ntw_handle->magic));
+	while (times--) {
+		type = TEEC_PARAM_TYPE_GET(params->paramTypes, idx);
+		if (!IS_PARAMTYPES_TYPE_VALID(type)) {
+			MARVELLTEE_DBG("tee_msgm_set_params: bad paramsTypes\n");
+			return TEEC_ERROR_BAD_PARAMETERS;
+		}
+		if (IS_TYPE_MEMREF(type)) {
+			if (!IS_NTW_MEM_FLAG_VALID(params->params[idx].memref.parent->flags)) {
+				MARVELLTEE_DBG("tee_msgm_set_params: un-compatible arg\n");
+				return TEEC_ERROR_BAD_PARAMETERS;
+			}
+		}
+		idx++;
+	}
+	set_params_stat = set_params(msgm, params);
+	return set_params_stat;
+}
+
+/* **********************
+ * update_params in ntw
+ * **********************/
+tee_stat_t tee_msgm_update_params(tee_msgm_t msgm, tee_msg_op_info_t *params)
+{
+	tee_msgm_ntw_struct *ntw_handle = NULL;
+	tee_stat_t update_params_stat = TEEC_SUCCESS;
+
+	OSA_ASSERT((msgm && params));
+	ntw_handle = (tee_msgm_ntw_struct *) msgm;
+	OSA_ASSERT(IS_MAGIC_VALID(ntw_handle->magic));
+
+	update_params_stat = update_params(msgm, params);
+	return update_params_stat;
+}
diff --git a/drivers/marvell/security/marvelltee/src/msgm/ntw/tee_msgm_op_internal.h b/drivers/marvell/security/marvelltee/src/msgm/ntw/tee_msgm_op_internal.h
new file mode 100644
index 0000000..4dc4eb0
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/msgm/ntw/tee_msgm_op_internal.h
@@ -0,0 +1,186 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+#ifndef _TEE_MSGM_OP_INTERNAL_H_
+#define _TEE_MSGM_OP_INTERNAL_H_
+#include "tee_msgm_ntw.h"
+
+extern const char cmd_magic[];
+#define BYTES_OF_MAGIC (4)
+#define INIT_CMD_MAGIC(_m) \
+	do {                         \
+		_m[0] = cmd_magic[0];    \
+		_m[1] = cmd_magic[1];    \
+		_m[2] = cmd_magic[2];    \
+		_m[3] = cmd_magic[3];    \
+	} while (0)
+#define CLEANUP_CMD_MAGIC(_m)  \
+	do {                \
+		_m[0] = 0;    \
+		_m[1] = 0;    \
+		_m[2] = 0;    \
+		_m[3] = 0;    \
+	} while (0)
+
+#define IS_CMD_MAGIC_VALID(_m) \
+	((cmd_magic[0] == _m[0]) &&   \
+	(cmd_magic[1] == _m[1]) &&   \
+	(cmd_magic[2] == _m[2]) &&   \
+	(cmd_magic[3] == _m[3]))
+/* for translate cmd idx */
+#define TEE_TW_SUB_CMD_SIZE       (8)
+#define TEE_TW_PREM_CMD_MASK      ((1 << (32 - TEE_TW_SUB_CMD_SIZE)) - 1)
+
+/* for parameters */
+#define  PARAM_NUMBERS      (4)
+#define IS_TYPE_NONE(_m)    (TEEC_NONE == (_m))
+#define IS_TYPE_VALUE(_m)   ((_m) >= TEEC_VALUE_INPUT && (_m) <= TEEC_VALUE_INOUT)
+/*
+ * shared memory in secure world is treated as
+ * the tmpref memory in non-secure world
+ */
+#define IS_TYPE_TMPREF(_m)  ((_m) >= TEEC_MEMREF_TEMP_INPUT && (_m) <= TEEC_MEMREF_TEMP_INOUT)
+#define IS_TYPE_MEMREF(_m)  ((_m) >= TEEC_MEMREF_WHOLE && (_m) <= TEEC_MEMREF_PARTIAL_INOUT)
+
+/* memory in/out */
+#define IS_PARAM_TAGED_INPUT(_m)   (((_m) & TEEC_MEM_INPUT) == TEEC_MEM_INPUT)
+#define IS_PARAM_TAGED_OUTPUT(_m)  (((_m) & TEEC_MEM_OUTPUT) == TEEC_MEM_OUTPUT)
+
+#define OFFSETOF(TYPE, MEMBER)     __builtin_offsetof(TYPE, MEMBER)
+
+/* vvv cmd_body struct vvv */
+typedef struct _map_shm_body {
+	ulong_t cntx;
+	void *vaddr_tw;
+	uint32_t flags;
+	tee_stat_t ret;
+
+	uint32_t arr_sz;
+	uint32_t rsvd;
+	tee_msgm_phys_memblock_t arr[];
+} map_shm_body;
+typedef struct _unmap_shm_body {
+	void *vaddr_tw;
+	size_t sz;
+} unmap_shm_body;
+typedef struct _open_ss_body {
+	ulong_t cntx;
+	TEEC_UUID uuid;
+	uint32_t meth;
+	uint32_t data_sz;
+	TEEC_UUID data;
+	void *ss_tw;
+	uint32_t ret_orig;
+	tee_stat_t ret;
+} open_ss_body;
+typedef struct _close_ss_body {
+	void *ss_tw;
+} close_ss_body;
+typedef struct _inv_op_body {
+	uint32_t srv_cmd;
+	void *ss_tw;
+
+	uint32_t ret_orig;
+	tee_stat_t ret;
+} inv_op_body;
+typedef struct _can_op_body {
+	void *ss_tw;
+	void *tee_msg_ntw;
+} can_op_body;
+/* ^^^^^^ cmd_body struct ^^^^^^^ */
+
+/* vvv size of cmd_body vvv */
+#define MAP_SHM_SZ     (sizeof(map_shm_body))
+#define UNMAP_SHM_SZ   (sizeof(unmap_shm_body))
+#define OPEN_SS_SZ     (sizeof(open_ss_body))
+#define CLOSE_SS_SZ    (sizeof(close_ss_body))
+#define INV_OP_SZ      (sizeof(inv_op_body))
+#define CAN_OP_SZ      (sizeof(can_op_body))
+/* ^^^ size of cmd_body ^^^ */
+
+/* vvv cmd operation class vvv */
+typedef struct _tee_msgm_op_class {
+	tee_stat_t (*set_cmd)(tee_msgm_t msgm, void *arg);
+	tee_stat_t (*get_cmd)(tee_msgm_t msgm, void *arg);
+	tee_stat_t (*set_ret)(tee_msgm_t msgm, void *arg);
+	tee_stat_t (*get_ret)(tee_msgm_t msgm, void *arg);
+	bool (*cmd_class)(tee_cmd_t cmd);
+} tee_msgm_op_class;
+extern const tee_msgm_op_class map_shm_class;
+extern const tee_msgm_op_class unmap_shm_class;
+extern const tee_msgm_op_class open_ss_class;
+extern const tee_msgm_op_class close_ss_class;
+extern const tee_msgm_op_class inv_op_class;
+extern const tee_msgm_op_class can_op_class;
+/* ^^^^^ cmd operation class ^^^^ */
+
+/* vvv  params handling vvv */
+tee_stat_t get_params(tee_msgm_t msgm, tee_msg_op_info_t *arg);
+tee_stat_t set_params(tee_msgm_t msgm, tee_msg_op_info_t *arg);
+tee_stat_t update_params(tee_msgm_t msgm, tee_msg_op_info_t *arg);
+/* ^^^^^^^^^^ params handling ^^^^^^ */
+
+/* vvv  msg params format vvv */
+typedef struct _cmd_struct {
+	uint8_t magic[4];
+	tee_cmd_t cmd;
+	uint32_t cmd_sz;	/* size of cmd */
+	uint32_t rsvd;		/* keep 64b-aligned */
+	uint8_t cmd_body[0];
+} cmd_struct;
+typedef union {
+	struct {
+		void *buffer;
+		size_t size;
+	} tmpref;
+	struct {
+		void *buffer;
+		size_t size;
+	} memref;
+	struct {
+		uint32_t a, b;
+	} value;
+} Union_Parameter;
+typedef struct _params_struct {
+	uint32_t paramTypes;
+	Union_Parameter param[4];
+} params_struct;
+/* ^^^  msg params format ^^^ */
+
+/* vvv  internal handler vvv */
+typedef enum _tee_ntw_cmd_stat_t {
+	TEE_NTW_CMD_STAT_CLEAR,
+	TEE_NTW_CMD_STAT_SET,
+} tee_ntw_cmd_stat_t;
+typedef struct _tee_ntw_cmd_record_t {
+	tee_cmd_t cmd;
+	uint32_t cmd_sz;
+	uint32_t param_size;
+	uint32_t msg_sz;	/* the summary size of msg */
+	tee_ntw_cmd_stat_t stat;
+} tee_ntw_cmd_record_t;
+typedef struct _tee_msgm_ntw_struct {
+	uint8_t magic[BYTES_OF_MAGIC];
+
+	cmd_struct *ntw_cmd;
+	uint8_t *body;
+	params_struct *ntw_params;
+	const tee_msgm_op_class *op;
+	tee_ntw_cmd_record_t cmd_record;
+} tee_msgm_ntw_struct;
+
+#endif
diff --git a/drivers/marvell/security/marvelltee/src/msgm/ntw/tee_msgm_open_ss.c b/drivers/marvell/security/marvelltee/src/msgm/ntw/tee_msgm_open_ss.c
new file mode 100644
index 0000000..409da2c
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/msgm/ntw/tee_msgm_open_ss.c
@@ -0,0 +1,101 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+#include "tee_client_api.h"
+#define LOGIN_METHOD_NULL  (0)
+#define LOGIN_METHOD_VALID (sizeof(TEEC_UUID))
+#include "tee_msgm_op_internal.h"
+
+/* set cmd */
+tee_stat_t set_cmd_open_ss(tee_msgm_t msgm, void *arg)
+{
+	open_ss_body *dst = NULL;
+	tee_set_cmd_open_ss_arg_t *src = NULL;
+	tee_msgm_ntw_struct *ntw_handle = NULL;
+
+	src = (tee_set_cmd_open_ss_arg_t *) arg;
+	ntw_handle = (tee_msgm_ntw_struct *) msgm;
+	dst = (open_ss_body *) ntw_handle->body;
+	dst->cntx = src->cntx;
+	memcpy(&(dst->uuid), (uint8_t *) src->uuid, sizeof(TEEC_UUID));
+	dst->meth = src->meth;
+	dst->data_sz = LOGIN_METHOD_VALID;
+	dst->data = src->data;
+	return TEEC_SUCCESS;
+}
+
+/* get cmd */
+tee_stat_t get_cmd_open_ss(tee_msgm_t msgm, void *arg)
+{
+	open_ss_body *src = NULL;
+	tee_get_cmd_open_ss_arg_t *dst = NULL;
+	tee_msgm_ntw_struct *ntw_handle = NULL;
+
+	dst = (tee_get_cmd_open_ss_arg_t *) arg;
+	ntw_handle = (tee_msgm_ntw_struct *) msgm;
+	src = (open_ss_body *) ntw_handle->body;
+	dst->uuid = &(src->uuid);
+	dst->meth = src->meth;
+	dst->data_sz = src->data_sz;
+	dst->data = src->data;
+	return TEEC_SUCCESS;
+}
+
+/* set ret */
+tee_stat_t set_ret_open_ss(tee_msgm_t msgm, void *arg)
+{
+	open_ss_body *dst = NULL;
+	tee_set_ret_open_ss_arg_t *src = NULL;
+	tee_msgm_ntw_struct *ntw_handle = NULL;
+
+	src = (tee_set_ret_open_ss_arg_t *) arg;
+	ntw_handle = (tee_msgm_ntw_struct *) msgm;
+	dst = (open_ss_body *) ntw_handle->body;
+	dst->ss_tw = src->ss_tw;
+	dst->ret_orig = src->ret_orig;
+	dst->ret = src->ret;
+	return TEEC_SUCCESS;
+}
+
+/* get ret */
+tee_stat_t get_ret_open_ss(tee_msgm_t msgm, void *arg)
+{
+	open_ss_body *src = NULL;
+	tee_get_ret_open_ss_arg_t *dst = NULL;
+	tee_msgm_ntw_struct *ntw_handle = NULL;
+
+	dst = (tee_get_ret_open_ss_arg_t *) arg;
+	ntw_handle = (tee_msgm_ntw_struct *) msgm;
+	src = (open_ss_body *) ntw_handle->body;
+	dst->ss_tw = src->ss_tw;
+	dst->ret_orig = src->ret_orig;
+	dst->ret = src->ret;
+	return TEEC_SUCCESS;
+}
+
+bool cmd_class_open_ss(tee_cmd_t cmd)
+{
+	return (cmd == TEE_CMD_OPEN_SS);
+}
+
+const tee_msgm_op_class open_ss_class = {
+	.set_cmd = set_cmd_open_ss,
+	.get_cmd = get_cmd_open_ss,
+	.set_ret = set_ret_open_ss,
+	.get_ret = get_ret_open_ss,
+	.cmd_class = cmd_class_open_ss,
+};
diff --git a/drivers/marvell/security/marvelltee/src/msgm/ntw/tee_msgm_unmap_shm.c b/drivers/marvell/security/marvelltee/src/msgm/ntw/tee_msgm_unmap_shm.c
new file mode 100644
index 0000000..cdedc0b
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/msgm/ntw/tee_msgm_unmap_shm.c
@@ -0,0 +1,63 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+#include "tee_client_api.h"
+#include "tee_msgm_op_internal.h"
+
+tee_stat_t set_cmd_unmap_shm(tee_msgm_t msgm, void *arg)
+{
+	unmap_shm_body *dst = NULL;
+	tee_set_cmd_unmap_shm_arg_t *src = NULL;
+	tee_msgm_ntw_struct *ntw_handle = NULL;
+	_TEEC_MRVL_SharedMemory *_teec_mrvl_sharedMem;
+
+	src = (tee_set_cmd_unmap_shm_arg_t *) arg;
+	ntw_handle = (tee_msgm_ntw_struct *) msgm;
+	dst = (unmap_shm_body *) ntw_handle->body;
+
+	_teec_mrvl_sharedMem = (_TEEC_MRVL_SharedMemory *) (src->imp);
+
+	dst->vaddr_tw = _teec_mrvl_sharedMem->vaddr_tw;
+	dst->sz = _teec_mrvl_sharedMem->size;
+	return TEEC_SUCCESS;
+}
+
+tee_stat_t get_cmd_unmap_shm(tee_msgm_t msgm, void *arg)
+{
+	unmap_shm_body *src = NULL;
+	tee_get_cmd_unmap_shm_arg_t *dst = NULL;
+	tee_msgm_ntw_struct *ntw_handle = NULL;
+
+	dst = (tee_get_cmd_unmap_shm_arg_t *) arg;
+	ntw_handle = (tee_msgm_ntw_struct *) msgm;
+	src = (unmap_shm_body *) ntw_handle->body;
+	dst->vaddr_tw = src->vaddr_tw;
+	return TEEC_SUCCESS;
+}
+
+bool cmd_class_unmap_shm(tee_cmd_t cmd)
+{
+	return (cmd == TEE_CMD_UNMAP_SHM);
+}
+
+const tee_msgm_op_class unmap_shm_class = {
+	.set_cmd = set_cmd_unmap_shm,
+	.get_cmd = get_cmd_unmap_shm,
+	.set_ret = NULL,
+	.get_ret = NULL,
+	.cmd_class = cmd_class_unmap_shm,
+};
diff --git a/drivers/marvell/security/marvelltee/src/osa/include/linux/osa_os_inc.h b/drivers/marvell/security/marvelltee/src/osa/include/linux/osa_os_inc.h
new file mode 100644
index 0000000..319d13e
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/osa/include/linux/osa_os_inc.h
@@ -0,0 +1,78 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ * Filename     : osa_os_inc.h
+ * Author       : Dafu Lv
+ * Date Created : 04/06/08
+ * Description  : specifiec os files of osa for linux
+ *
+ */
+
+#ifndef _OSA_OS_INC_H_
+#define _OSA_OS_INC_H_
+
+#include <stdarg.h>
+
+#include <linux/delay.h>
+#include <linux/kernel.h>
+#include <linux/kthread.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/vmalloc.h>
+#include <linux/semaphore.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/mm.h>
+#include <linux/vmalloc.h>
+#include <linux/dma-mapping.h>
+#include <linux/platform_device.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/nvram.h>
+
+#include <asm-generic/cacheflush.h>
+
+#include <linux/io.h>
+#include <linux/mmu_context.h>
+#include <asm/pgalloc.h>
+#include <asm/tlbflush.h>
+#include <asm/sizes.h>
+#include <linux/atomic.h>
+#include <asm/pgtable.h>
+#include <linux/uaccess.h>
+#include <asm/pgtable.h>
+#include <linux/signal.h>
+#include <linux/io.h>
+#include <asm/memory.h>
+
+#define OSA_EXPORT_SYMBOL       EXPORT_SYMBOL
+#define INFINITE                (0xFFFFFFFF)
+
+#define true                    (1)
+#define false                   (0)
+
+typedef signed long long_t;
+typedef unsigned long ulong_t;
+
+#endif /* _OSA_OS_INC_H_ */
diff --git a/drivers/marvell/security/marvelltee/src/osa/include/osa.h b/drivers/marvell/security/marvelltee/src/osa/include/osa.h
new file mode 100644
index 0000000..25c1975
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/osa/include/osa.h
@@ -0,0 +1,94 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ * Filename     : osa.h
+ * Author       : Dafu Lv
+ * Date Created : 30/09/2009
+ * Description  : osa header file
+ *
+ */
+
+#ifndef _OSA_H_
+#define _OSA_H_
+
+typedef struct osa_list {
+	struct osa_list *next;
+	struct osa_list *prev;
+} osa_list_t;
+
+typedef struct _osa_time_t {
+	unsigned int sec;
+	unsigned int msec;
+} osa_time_t;
+
+typedef void *osa_drv_t;
+typedef int osa_err_t;
+typedef void *osa_irq_t;
+typedef void *osa_mpool_t;
+typedef void *osa_mutex_t;
+typedef void *osa_event_t;
+typedef void *osa_rw_sem_t;
+typedef void *osa_sem_t;
+typedef void *osa_timer_t;
+typedef void *osa_thread_id_t;
+typedef void *osa_thread_t;
+
+#define LINUX
+
+#ifdef LINUX
+
+#include "linux/osa_os_inc.h"
+
+#elif defined(WINCE)
+
+#include "wince/osa_os_inc.h"
+
+#elif defined(ECOS)
+
+#include "ecos/osa_os_inc.h"
+
+#elif defined(MINOS)
+
+#include "minos/osa_os_inc.h"
+
+#else
+
+#error "invalid OS or no OS defined."
+
+#endif
+
+typedef atomic_t osa_atomic_t;
+
+#include "osa_err.h"
+
+#include "osa_atomic.h"
+#include "osa_dbg.h"
+#include "osa_delay.h"
+#include "osa_drv.h"
+#include "osa_irq.h"
+#include "osa_list.h"
+#include "osa_mem.h"
+#include "osa_misc.h"
+#include "osa_sched.h"
+#include "osa_sync.h"
+#include "osa_time.h"
+#include "osa_timer.h"
+#include "osa_thread.h"
+
+extern osa_err_t osa_init_module(void);
+extern void osa_cleanup_module(void);
+
+#endif /* _OSA_H_ */
diff --git a/drivers/marvell/security/marvelltee/src/osa/include/osa_atomic.h b/drivers/marvell/security/marvelltee/src/osa/include/osa_atomic.h
new file mode 100644
index 0000000..272b54e
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/osa/include/osa_atomic.h
@@ -0,0 +1,31 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+
+#ifndef _OSA_ATOMIC_H_
+#define _OSA_ATOMIC_H_
+
+#include <osa.h>
+
+extern int osa_atomic_read(osa_atomic_t *v);
+extern void osa_atomic_set(osa_atomic_t *v, int i);
+extern void osa_atomic_add(int i, osa_atomic_t *v);
+extern void osa_atomic_sub(int i, osa_atomic_t *v);
+extern void osa_atomic_inc(osa_atomic_t *v);
+extern void osa_atomic_dec(osa_atomic_t *v);
+
+#endif
diff --git a/drivers/marvell/security/marvelltee/src/osa/include/osa_dbg.h b/drivers/marvell/security/marvelltee/src/osa/include/osa_dbg.h
new file mode 100644
index 0000000..7e71cff
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/osa/include/osa_dbg.h
@@ -0,0 +1,62 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+
+#ifndef _OSA_DBG_H_
+#define _OSA_DBG_H_
+
+#include "osa.h"
+
+#define OSA_RM_WARNING(x)   ((void)(x))
+
+/* no implemented in print proc, for osa_dbg_level only */
+#define DBG_ALL         (0)
+
+#define DBG_INFO        (1)
+#define DBG_WARN        (2)
+#define DBG_ERR         (3)
+
+/* DBG LOG will be printed even in release version */
+#define DBG_LOG         (0xFFFFFFFF)
+
+#ifdef OSA_DEBUG
+
+#define OSA_ASSERT(x) \
+	{ \
+		if (!(x)) { \
+			osa_dbg_print(DBG_ERR, \
+				"ASSERT FAILURE:\r\n");\
+			osa_dbg_print(DBG_ERR, \
+				"%s (%d): %s\r\n", \
+				__FILE__, __LINE__, __func__); \
+			osa_dbg_bt(); \
+			while (1) \
+				; \
+		} \
+	}
+#else
+
+#define OSA_ASSERT(x)
+
+#endif
+
+extern uint32_t osa_dbg_level;
+
+extern uint32_t osa_dbg_print(uint32_t level, const void *format, ...);
+extern void osa_dbg_bt(void);
+
+#endif /* _OSA_DBG_H_ */
diff --git a/drivers/marvell/security/marvelltee/src/osa/include/osa_delay.h b/drivers/marvell/security/marvelltee/src/osa/include/osa_delay.h
new file mode 100644
index 0000000..dd9ba8d
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/osa/include/osa_delay.h
@@ -0,0 +1,31 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ * Filename     : osa_delay.h
+ * Author       : Dafu Lv
+ * Date Created : 21/03/08
+ * Description  : This is the header file of delay/sleep function in osa.
+ *
+ */
+
+#ifndef _OSA_DELAY_H_
+#define _OSA_DELAY_H_
+
+#include "osa.h"
+
+extern void osa_sleep(uint32_t msec);
+
+#endif /* _OSA_DELAY_H_ */
diff --git a/drivers/marvell/security/marvelltee/src/osa/include/osa_drv.h b/drivers/marvell/security/marvelltee/src/osa/include/osa_drv.h
new file mode 100644
index 0000000..d6e0f49
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/osa/include/osa_drv.h
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+
+#ifndef _OSA_DRV_H_
+#define _OSA_DRV_H_
+
+#include <osa.h>
+
+struct osa_pseudo_drv_ops {
+	osa_err_t (*open)(int8_t *, int32_t);
+	osa_err_t (*close)(osa_drv_t);
+	osa_err_t (*ioctl)(osa_drv_t, int32_t, ulong_t);
+};
+
+/* called by OS */
+extern osa_err_t osa_pseudo_drv_init(void);
+extern osa_err_t osa_pseudo_drv_cleanup(void);
+
+/* called by OS or driver */
+extern osa_err_t osa_pseudo_drv_reg(int8_t *name,
+					struct osa_pseudo_drv_ops *ops,
+					int32_t flags);
+extern osa_err_t osa_pseudo_drv_unreg(int8_t *name);
+
+/* called by middle-ware */
+extern osa_drv_t osa_pseudo_drv_open(int8_t *name, int32_t flags);
+extern osa_err_t osa_pseudo_drv_close(osa_drv_t drv);
+extern osa_err_t osa_pseudo_drv_ioctl(osa_drv_t drv, int32_t cmd, ulong_t arg);
+
+#endif /* _OSA_DRV_H_ */
diff --git a/drivers/marvell/security/marvelltee/src/osa/include/osa_err.h b/drivers/marvell/security/marvelltee/src/osa/include/osa_err.h
new file mode 100644
index 0000000..6b17514
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/osa/include/osa_err.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+
+#ifndef _OSA_ERR_H_
+#define _OSA_ERR_H_
+
+#define OSA_OK                  (0)
+#define OSA_ERR                 (-1)
+
+#define OSA_BAD_ARG             (-10)
+#define OSA_OUT_OF_MEM          (-11)
+#define OSA_BUSY                (-12)
+#define OSA_ITEM_NOT_FOUND      (-13)
+
+#define OSA_SEM_WAIT_FAILED     (-100)
+#define OSA_SEM_WAIT_TO         (-101)
+#define OSA_MUTEX_WAIT_FAILED   (-102)
+#define OSA_MUTEX_WAIT_TO       (-103)
+#define OSA_EVENT_WAIT_FAILED   (-102)
+#define OSA_EVENT_WAIT_TO       (-103)
+
+#define OSA_THREAD_BAD_STATUS   (-110)
+#define OSA_THREAD_STOP_FAILED  (-111)
+
+#define OSA_BAD_USER_VIR_ADDR   (-120)
+
+#define OSA_DUP_DRV             (-130)
+
+#define OSA_TIMER_BAD_STATUS    (-140)
+#define OSA_INIT_TIMER_FAILED   (-141)
+
+#endif /* _OSA_ERR_H_ */
diff --git a/drivers/marvell/security/marvelltee/src/osa/include/osa_irq.h b/drivers/marvell/security/marvelltee/src/osa/include/osa_irq.h
new file mode 100644
index 0000000..976e0aa
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/osa/include/osa_irq.h
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ * Filename     : osa_irq.h
+ * Author       : Dafu Lv
+ * Date Created : 21/03/08
+ * Description  : This is the header file of irq-related functions in osa layer.
+ *
+ */
+
+#ifndef _OSA_IRQ_H_
+#define _OSA_IRQ_H_
+
+#include <osa.h>
+
+#define OSA_IRQ_INVALID     ((osa_irq_t)(0xFFFFFFFF))
+
+struct osa_irq_param {
+	uint32_t flag;
+	uint32_t priority;
+};
+
+extern void osa_disable_irq(void);
+extern void osa_enable_irq(void);
+
+extern void osa_save_irq(uint32_t *flags);
+extern void osa_restore_irq(uint32_t *flags);
+
+extern osa_irq_t osa_hook_irq(int32_t irq,
+		void (*isr)(void *), void (*dsr)(void *),
+		void *arg, struct osa_irq_param *param);
+extern osa_err_t osa_free_irq(osa_irq_t handle);
+extern void osa_mask_irq(uint32_t irq);
+extern void osa_unmask_irq(uint32_t irq);
+
+#endif /* _OSA_IRQ_H_ */
diff --git a/drivers/marvell/security/marvelltee/src/osa/include/osa_list.h b/drivers/marvell/security/marvelltee/src/osa/include/osa_list.h
new file mode 100644
index 0000000..cbb48e4
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/osa/include/osa_list.h
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ * Filename     : osa_list.h
+ * Author       : Dafu Lv
+ * Date Created : 21/03/08
+ * Description  : This is the header file of list-related functions in osa.
+ *
+ */
+
+#ifndef _OSA_LIST_H_
+#define _OSA_LIST_H_
+
+#include "osa.h"
+
+#define OSA_LIST(head) \
+	struct osa_list head = { &(head), &(head) }
+
+#define OSA_LIST_HEAD(head) { &(head), &(head) }
+
+#define OSA_LIST_ENTRY(_addr, _type, _member, _entry)   do {           \
+		_type _tmp;                                                    \
+		ulong_t _offset = ((ulong_t)(&_tmp._member) - (ulong_t)&_tmp); \
+		_entry = (_type *)((ulong_t)_addr - _offset);                  \
+} while (0)
+
+#define osa_list_iterate(head, entry) \
+	for ((entry) = (head)->next; (entry) != (head); (entry) = (entry)->next)
+
+#define osa_list_iterate_safe(head, entry, n) \
+	for (entry = (head)->next, n = entry->next; entry != (head); \
+		entry = n, n = entry->next)
+
+extern void osa_list_init_head(struct osa_list *head);
+extern void osa_list_add(struct osa_list *entry, struct osa_list *head);
+extern void osa_list_add_tail(struct osa_list *entry, struct osa_list *head);
+extern void osa_list_del(struct osa_list *entry);
+extern bool osa_list_empty(struct osa_list *head);
+
+#endif /* _OSA_LIST_H_ */
diff --git a/drivers/marvell/security/marvelltee/src/osa/include/osa_mem.h b/drivers/marvell/security/marvelltee/src/osa/include/osa_mem.h
new file mode 100644
index 0000000..36d8563
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/osa/include/osa_mem.h
@@ -0,0 +1,222 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ * Filename     : osa_mem.h
+ * Author       : Dafu Lv
+ * Date Created : 21/03/08
+ * Description  : This is the header file of memory-related functions in osa.
+ *
+ */
+
+#ifndef _OSA_MEM_H_
+#define _OSA_MEM_H_
+
+/*
+ ******************************
+ *          HEADERS
+ ******************************
+ */
+
+#include <osa.h>
+
+/*
+ ******************************
+ *           MACROS
+ ******************************
+ */
+
+#ifndef PAGE_SHIFT
+#define PAGE_SHIFT                  (12)
+#endif
+#ifndef PAGE_SIZE
+#define PAGE_SIZE                   (1UL << PAGE_SHIFT)
+#endif
+#ifndef PAGE_MASK
+#define PAGE_MASK                   (~(PAGE_SIZE - 1))
+#endif
+
+#ifndef SECTION_SHIFT
+#define SECTION_SHIFT               (20)
+#endif
+#ifndef SECTION_SIZE
+#define SECTION_SIZE                (1UL << SECTION_SHIFT)
+#endif
+#ifndef SECTION_MASK
+#define SECTION_MASK                (~(SECTION_SIZE - 1))
+#endif
+
+#define INVALID_PHYS_ADDR           ((void *)0xFFFFFFFF)
+#define INVALID_USER_VIRT_ADDR      ((void *)0xFFFFFFFF)
+
+/* for OSA in secure world */
+#define OSA_MAP_EC                  (0x1)
+#define OSA_MAP_EB                  (0x2)
+#define OSA_MAP_RO                  (0x4)
+#define OSA_MAP_WO                  (0x8)
+#define OSA_MAP_EWR                 (OSA_MAP_RO | OSA_MAP_WO)
+
+/*
+ ******************************
+ *        ENUMERATIONS
+ ******************************
+ */
+
+typedef enum osa_mem_attr {
+	OSA_MEM_NO_ACCESS,	/* can not access */
+	OSA_MEM_READ_ONLY,	/* read only mapping */
+	OSA_MEM_WRITE_ONLY,	/* write only mapping */
+	OSA_MEM_READ_WRITE	/* read and write */
+} osa_mem_attr_t;
+
+/* for cache/TLB only */
+typedef enum _osa_mode_t {
+	MODE_USER,
+	MODE_KERNEL
+} osa_mode_t;
+
+/* for OSA in secure world */
+typedef enum osa_mmap_type {
+	OSA_MMAP_SECTION,	/* mapping as section */
+	OSA_MMAP_LARGE_PAGE,	/* mapping as 16k page */
+	OSA_MMAP_SMALL_PAGE,	/* mapping as 4k page */
+	OSA_MMAP_TINY_PAGE,	/* mapping as 1k page */
+} osa_mmap_type_t;
+
+/* for OSA in secure world */
+typedef enum osa_mpool_type {
+	OSA_MPOOL_FIX,		/* fixed memory pool */
+	OSA_MPOOL_VAR,		/* variable memory pool */
+	OSA_MPOOL_SEP,		/* sepmeta memory pool */
+	OSA_MPOOL_DL		/* dynamic memory pool */
+} osa_mpool_type_t;
+
+/*
+ ******************************
+ *         STRUCTURES
+ ******************************
+ */
+
+struct osa_page_entry {
+	void *phy_addr;
+	uint32_t len;
+
+	struct osa_page_entry *next;
+};
+
+/* for OSA in secure world */
+struct osa_mpool_info {
+	osa_mpool_type_t type;
+	void *base;
+	uint32_t size;
+	uint32_t block_size;
+	void *meta_addr;
+	uint32_t meta_len;
+	uint32_t alignment;
+};
+
+/*
+ ******************************
+ *          FUNCTIONS
+ ******************************
+ */
+
+/* allocate/free physical and virtual continuous memory block */
+extern void __kernel *osa_kmem_alloc(uint32_t size);
+extern void osa_kmem_free(void __kernel *addr);
+
+/* allocate/free virtual continuous memory block */
+extern void __kernel *osa_vmem_alloc(uint32_t size, osa_mem_attr_t attr);
+extern void osa_vmem_free(void __kernel *addr);
+
+/* allocate/free pages */
+extern void __kernel *osa_pages_alloc(uint32_t nr);
+extern void osa_pages_free(void __kernel *addr);
+
+/* allocate/free physical continuous memory block w' cache & alignment */
+extern osa_err_t osa_phys_mem_pool_init(void);
+extern void osa_phys_mem_pool_cleanup(void);
+extern void __kernel *osa_alloc_phys_mem(uint32_t size, bool is_cached,
+					 uint32_t alignment, void **phys);
+extern void osa_free_phys_mem(void __kernel *virt);
+
+/* memory map/unmap */
+extern osa_err_t osa_iomap_rgn_init(void);
+extern void osa_iomap_rgn_cleanup(void);
+extern void __kernel *osa_ioremap(void *phy_addr, uint32_t size);
+extern osa_err_t osa_iounmap(void __kernel *vir_addr, uint32_t size);
+extern void __kernel *osa_ioremap_cached(void *phy_addr, uint32_t size);
+extern osa_err_t osa_iounmap_cached(void __kernel *vir_addr, uint32_t size);
+
+/* the following two functions should be called in process context */
+extern osa_err_t osa_map_to_user(void __user *vir_addr, void *phy_addr,
+				 uint32_t size, uint32_t prot);
+extern osa_err_t osa_unmap_from_user(void __user *vir_addr);
+
+/* memory map/unmap */
+extern osa_err_t osa_map_section(void *phy_addr, void *vir_addr, uint32_t size,
+				 uint32_t property);
+extern osa_err_t osa_unmap_section(void *vir_addr, uint32_t size);
+extern osa_err_t osa_map_page(void *phy_addr, void *vir_addr,
+			      void *pte_phy_addr, void *pte_vir_addr,
+			      uint32_t size, uint32_t property);
+extern osa_err_t osa_unmap_page(void *vir_addr, uint32_t size);
+extern osa_err_t osa_set_map_property(void *vir_addr, uint32_t size,
+				      osa_mmap_type_t type, uint32_t property);
+
+/* memory pool related interfaces */
+extern osa_mpool_t osa_mpool_create(struct osa_mpool_info *arg);
+extern osa_err_t osa_mpool_destroy(osa_mpool_t handle);
+extern void *osa_mpool_alloc(osa_mpool_t handle, uint32_t len);
+extern void osa_mpool_free(osa_mpool_t handle, void *addr);
+extern osa_err_t osa_mpool_get_info(osa_mpool_t handle,
+				    struct osa_mpool_info *mpool_info);
+
+/* NW only */
+/* caller needs to free the list generated by osa_vmem_to_pages */
+extern struct osa_page_entry *osa_vmem_to_pages(void __user *vir_addr,
+						uint32_t size);
+
+/* memory will be real-allocated by calling this function */
+/* NOTE: no copy_xxx_user needed then */
+extern osa_err_t osa_validate_vmem(void __user *vir_addr, uint32_t size);
+/* re-enable the swap-able attribute of the memory block */
+extern osa_err_t osa_invalidate_vmem(void __user *vir_addr, uint32_t size);
+/* memory will be real-allocated for a string */
+extern osa_err_t osa_validate_string(void __user *string);
+/* re-enable the swap-able attribute of the memory block */
+extern osa_err_t osa_invalidate_string(void __user *string);
+
+/* translate virtual address to physical address */
+extern void *osa_virt_to_phys(void *virt_addr);
+extern void *osa_virt_to_phys_ex(void *virt_addr, bool *cacheable);
+/* for SW only */
+extern void *osa_phys_to_virt(void __kernel *phys_addr);
+
+/* cache-related and TLB-related interfaces */
+extern void osa_invalidate_dcache(osa_mode_t mode, ulong_t start,
+				uint32_t size);
+extern void osa_clean_dcache(osa_mode_t mode, ulong_t start, uint32_t size);
+extern void osa_flush_dcache(osa_mode_t mode, ulong_t start, uint32_t size);
+extern void osa_flush_dcache_all(void);
+extern void osa_invalidate_l2dcache(osa_mode_t mode, ulong_t start,
+				uint32_t size);
+extern void osa_clean_l2dcache(osa_mode_t mode, ulong_t start, uint32_t size);
+extern void osa_flush_l2dcache(osa_mode_t mode, ulong_t start, uint32_t size);
+extern void osa_flush_l2dcache_all(void);
+extern void osa_flush_tlb(osa_mode_t mode, ulong_t start, uint32_t size);
+extern void osa_flush_tlb_all(void);
+
+#endif /* _OSA_MEM_H_ */
diff --git a/drivers/marvell/security/marvelltee/src/osa/include/osa_misc.h b/drivers/marvell/security/marvelltee/src/osa/include/osa_misc.h
new file mode 100644
index 0000000..460aec3
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/osa/include/osa_misc.h
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+
+#ifndef _OSA_MISC_H_
+#define _OSA_MISC_H_
+
+#define OSA_1K      (0x00000400)
+#define OSA_2K      (0x00000800)
+#define OSA_4K      (0x00001000)
+#define OSA_8K      (0x00002000)
+#define OSA_16K     (0x00004000)
+#define OSA_32K     (0x00008000)
+#define OSA_64K     (0x00010000)
+#define OSA_128K    (0x00020000)
+#define OSA_256K    (0x00040000)
+#define OSA_512K    (0x00080000)
+#define OSA_1M      (0x00100000)
+#define OSA_2M      (0x00200000)
+#define OSA_4M      (0x00400000)
+#define OSA_8M      (0x00800000)
+#define OSA_16M     (0x01000000)
+#define OSA_32M     (0x02000000)
+#define OSA_64M     (0x04000000)
+#define OSA_128M    (0x08000000)
+#define OSA_256M    (0x10000000)
+#define OSA_512M    (0x20000000)
+#define OSA_1G      (0x40000000)
+#define OSA_2G      (0x80000000)
+
+#endif /* _OSA_MISC_H_ */
diff --git a/drivers/marvell/security/marvelltee/src/osa/include/osa_sched.h b/drivers/marvell/security/marvelltee/src/osa/include/osa_sched.h
new file mode 100644
index 0000000..c7bc883
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/osa/include/osa_sched.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ * Filename     : osa_sched.h
+ * Author       : Dafu Lv
+ * Date Created : 28/08/08
+ * Description  : This is the header file of sched-related
+ * functions in osa layer.
+ *
+ */
+
+#ifndef _OSA_SCHED_H_
+#define _OSA_SCHED_H_
+
+#include <osa.h>
+
+extern void osa_enable_preempt(void);
+extern void osa_disable_preempt(void);
+extern void osa_yield(void);
+
+extern void osa_wakeup_process(struct task_struct *tsk);
+
+#endif /* _OSA_SCHED_H_ */
diff --git a/drivers/marvell/security/marvelltee/src/osa/include/osa_sync.h b/drivers/marvell/security/marvelltee/src/osa/include/osa_sync.h
new file mode 100644
index 0000000..e26eb43
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/osa/include/osa_sync.h
@@ -0,0 +1,50 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+
+#ifndef _OSA_SYNC_H_
+#define _OSA_SYNC_H_
+
+#include "osa.h"
+
+extern osa_sem_t osa_create_sem(int32_t init_val);
+extern void osa_destroy_sem(osa_sem_t handle);
+extern osa_err_t osa_wait_for_sem(osa_sem_t handle, int32_t msec);
+extern osa_err_t osa_try_to_wait_for_sem(osa_sem_t handle);
+extern void osa_release_sem(osa_sem_t handle);
+
+extern osa_sem_t osa_create_rw_sem(int32_t init_val);
+extern void osa_destroy_rw_sem(osa_sem_t handle);
+extern osa_err_t osa_wait_for_rw_sem(osa_sem_t handle, int32_t msec);
+extern osa_err_t osa_try_to_wait_for_rw_sem(osa_sem_t handle);
+extern void osa_release_rw_sem(osa_sem_t handle);
+
+extern osa_mutex_t osa_create_mutex(void);
+extern osa_mutex_t osa_create_mutex_locked(void);
+extern void osa_destroy_mutex(osa_mutex_t handle);
+extern osa_err_t osa_wait_for_mutex(osa_mutex_t handle, int32_t msec);
+extern osa_err_t osa_try_to_wait_for_mutex(osa_mutex_t handle);
+extern void osa_release_mutex(osa_mutex_t handle);
+
+extern osa_event_t osa_create_event(bool is_set);
+extern void osa_destroy_event(osa_event_t handle);
+extern osa_err_t osa_wait_for_event(osa_event_t handle, int32_t msec);
+extern osa_err_t osa_try_to_wait_for_event(osa_event_t handle);
+extern void osa_set_event(osa_event_t handle);
+extern void osa_reset_event(osa_event_t handle);
+
+#endif /* _OSA_SYNC_H_ */
diff --git a/drivers/marvell/security/marvelltee/src/osa/include/osa_thread.h b/drivers/marvell/security/marvelltee/src/osa/include/osa_thread.h
new file mode 100644
index 0000000..7d1e837
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/osa/include/osa_thread.h
@@ -0,0 +1,77 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ * Filename     : osa_thread.h
+ * Author       : Dafu Lv
+ * Date Created : 21/03/08
+ * Description  : This is the header file of thread-related functions in osa.
+ *
+ */
+
+#ifndef _OSA_THREAD_H_
+#define _OSA_THREAD_H_
+
+#include "osa.h"
+
+#define OSA_THRD_PRIO_TIME_CRITICAL (0)
+#define OSA_THRD_PRIO_HIGHEST       (1)
+#define OSA_THRD_PRIO_ABOVE_NORMAL  (2)
+#define OSA_THRD_PRIO_NORMAL        (3)
+#define OSA_THRD_PRIO_BELOW_NORMAL  (4)
+#define OSA_THRD_PRIO_LOWEST        (5)
+#define OSA_THRD_PRIO_ABOVE_IDLE    (6)
+#define OSA_THRD_PRIO_IDLE          (7)
+
+#define OSA_PF_FREEZER_SKIP	PF_FREEZER_SKIP	/* Freezer should not count it as freezable */
+
+struct osa_thread_attr {
+	uint8_t *name;
+	uint32_t prio;
+	void *stack_addr;
+	uint32_t stack_size;
+	uint32_t flags;
+};
+
+/* for OSA in secure world */
+typedef enum osa_thread_status {
+	OSA_THRD_STATUS_RUNNING = 0,
+	OSA_THRD_STATUS_SLEEPING,
+	OSA_THRD_STATUS_SUSPENDED,
+	OSA_THRD_STATUS_CREATING,
+	OSA_THRD_STATUS_EXITED,
+	OSA_THRD_STATUS_UNKNOWN,
+} osa_thread_status_t;
+
+extern osa_thread_t osa_create_thread(void (*func) (void *), void *arg,
+					struct osa_thread_attr *attr);
+extern void osa_destroy_thread(osa_thread_t handle);
+/* stop thread synchronously */
+extern osa_err_t osa_stop_thread(osa_thread_t handle);
+/* stop thread asynchronously */
+extern osa_err_t osa_stop_thread_async(osa_thread_t handle);
+/*
+ * user should check the return value of the function frequently
+ * in his main loop.
+ * if true, the user function should terminate itself as quickly as possible.
+ */
+extern bool osa_thread_should_stop(void);
+
+extern osa_thread_id_t osa_get_thread_id(osa_thread_t handle);
+extern osa_thread_id_t osa_get_thread_group_id(osa_thread_t handle);
+extern osa_thread_id_t osa_get_current_thread_id(void);
+extern osa_thread_id_t osa_get_current_thread_group_id(void);
+
+#endif /* _OSA_THREAD_H_ */
diff --git a/drivers/marvell/security/marvelltee/src/osa/include/osa_time.h b/drivers/marvell/security/marvelltee/src/osa/include/osa_time.h
new file mode 100644
index 0000000..6aaeb41
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/osa/include/osa_time.h
@@ -0,0 +1,31 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ * Filename     : osa_time.h
+ * Author       : Dafu Lv
+ * Date Created : 17/08/09
+ * Description  : This is the header file of time-related functions in osa.
+ *
+ */
+
+#ifndef _OSA_TIME_H_
+#define _OSA_TIME_H_
+
+#include <osa.h>
+
+extern osa_err_t osa_get_time(osa_time_t *time);
+
+#endif /* _OSA_TIME_H_ */
diff --git a/drivers/marvell/security/marvelltee/src/osa/include/osa_timer.h b/drivers/marvell/security/marvelltee/src/osa/include/osa_timer.h
new file mode 100644
index 0000000..5178456
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/osa/include/osa_timer.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ * Filename     : osa_timer.h
+ * Author       : Dafu Lv
+ * Date Created : 21/03/08
+ * Description  : This is the header file of timer-related functions in osa.
+ *
+ */
+
+#ifndef _OSA_TIMER_H_
+#define _OSA_TIMER_H_
+
+#include <osa.h>
+
+/* create a timer to call func with arg as the argument */
+osa_timer_t osa_create_timer(void (*func) (void *), void *arg, uint32_t msec);
+/* destroy the timer */
+void osa_destroy_timer(osa_timer_t handle);
+/* start the timer */
+osa_err_t osa_start_timer(osa_timer_t handle);
+/* cancel the timer */
+osa_err_t osa_cancel_timer(osa_timer_t handle);
+/* modify the timer */
+osa_err_t osa_modify_timer(osa_timer_t handle, uint32_t msec);
+
+/* APIs called by MARVELLTEE */
+/* init timer module */
+osa_err_t osa_init_timer_module(void);
+/* cleanup timer module */
+void osa_cleanup_timer_module(void);
+
+#endif /* _OSA_TIMER_H_ */
diff --git a/drivers/marvell/security/marvelltee/src/osa/osa.c b/drivers/marvell/security/marvelltee/src/osa/osa.c
new file mode 100644
index 0000000..482dd53
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/osa/osa.c
@@ -0,0 +1,70 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ * Filename     : osa.c
+ * Author       : Dafu Lv
+ * Date Created : 21/03/08
+ * Description  : This is the source code of init/cleanup functions in osa.
+ *
+ */
+
+/*
+ ******************************
+ *          HEADERS
+ ******************************
+ */
+
+#include <osa.h>
+
+/*
+ ******************************
+ *          FUNCTIONS
+ ******************************
+ */
+
+/*
+ * Name:        osa_init_module
+ *
+ * Description: the init function of osa module
+ *
+ * Params:      none
+ *
+ * Returns:     osa_err_t
+ *
+ * Notes:       the function is called in marvelltee
+ */
+osa_err_t osa_init_module(void)
+{
+	return OSA_OK;
+}
+OSA_EXPORT_SYMBOL(osa_init_module);
+
+/*
+ * Name:        osa_cleanup_module
+ *
+ * Description: the cleanup function of osa module
+ *
+ * Params:      none
+ *
+ * Returns:     none
+ *
+ * Notes:       the function is called in marvelltee
+ */
+void osa_cleanup_module(void)
+{
+	/* nothing */;
+}
+OSA_EXPORT_SYMBOL(osa_cleanup_module);
diff --git a/drivers/marvell/security/marvelltee/src/osa/osa_atomic.c b/drivers/marvell/security/marvelltee/src/osa/osa_atomic.c
new file mode 100644
index 0000000..cd06649
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/osa/osa_atomic.c
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+
+#include <osa.h>
+
+int osa_atomic_read(osa_atomic_t *v)
+{
+	return atomic_read(v);
+}
+OSA_EXPORT_SYMBOL(osa_atomic_read);
+
+void osa_atomic_set(osa_atomic_t *v, int i)
+{
+	atomic_set(v, i);
+}
+OSA_EXPORT_SYMBOL(osa_atomic_set);
+
+void osa_atomic_add(int i, osa_atomic_t *v)
+{
+	atomic_add(i, v);
+}
+OSA_EXPORT_SYMBOL(osa_atomic_add);
+
+void osa_atomic_sub(int i, osa_atomic_t *v)
+{
+	atomic_sub(i, v);
+}
+OSA_EXPORT_SYMBOL(osa_atomic_sub);
+
+void osa_atomic_inc(osa_atomic_t *v)
+{
+	atomic_inc(v);
+}
+OSA_EXPORT_SYMBOL(osa_atomic_inc);
+
+void osa_atomic_dec(osa_atomic_t *v)
+{
+	atomic_dec(v);
+}
+OSA_EXPORT_SYMBOL(osa_atomic_dec);
diff --git a/drivers/marvell/security/marvelltee/src/osa/osa_dbg.c b/drivers/marvell/security/marvelltee/src/osa/osa_dbg.c
new file mode 100644
index 0000000..6bc9b58
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/osa/osa_dbg.c
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+
+#include <osa.h>
+
+#ifdef OSA_DEBUG
+
+uint32_t osa_dbg_level = DBG_ALL;
+
+#else
+
+uint32_t osa_dbg_level = DBG_LOG;
+
+#endif
+
+uint32_t osa_dbg_print(uint32_t level, const void *format, ...)
+{
+	va_list args;
+	uint32_t ret = 0;
+
+	if (level >= osa_dbg_level) {
+		va_start(args, format);
+		ret = vprintk(format, args);
+		va_end(args);
+	}
+
+	return ret;
+}
+OSA_EXPORT_SYMBOL(osa_dbg_print);
+
+void osa_dbg_bt(void)
+{
+#ifdef OSA_DEBUG
+
+	dump_stack();
+
+#endif /* OSA_DEBUG */
+}
+OSA_EXPORT_SYMBOL(osa_dbg_bt);
diff --git a/drivers/marvell/security/marvelltee/src/osa/osa_delay.c b/drivers/marvell/security/marvelltee/src/osa/osa_delay.c
new file mode 100644
index 0000000..b57e8e3
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/osa/osa_delay.c
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ * Filename     : osa_delay.c
+ * Author       : Dafu Lv
+ * Date Created : 21/03/08
+ * Description  : This is the source code of delay-related functions in osa.
+ *
+ */
+
+/*
+ ******************************
+ *          HEADERS
+ ******************************
+ */
+
+#include <osa.h>
+
+/*
+ ******************************
+ *          FUNCTIONS
+ ******************************
+ */
+
+/*
+ * Name:        osa_sleep
+ *
+ * Description: sleep in about n micro-seconds.
+ *
+ * Params:      msec - number of the micro-seconds.
+ *
+ * Returns:     none
+ *
+ * Notes:       the function does yield CPU and cause task re-scheduling.
+ */
+void osa_sleep(uint32_t msec)
+{
+	msleep(msec);
+}
+OSA_EXPORT_SYMBOL(osa_sleep);
diff --git a/drivers/marvell/security/marvelltee/src/osa/osa_irq.c b/drivers/marvell/security/marvelltee/src/osa/osa_irq.c
new file mode 100644
index 0000000..e7b1398
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/osa/osa_irq.c
@@ -0,0 +1,306 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ * Filename     : osa_irq.c
+ * Author       : Dafu Lv
+ * Date Created : 21/03/08
+ * Description  : This is the source code of irq-related functions in osa.
+ *
+ */
+
+/*
+ ******************************
+ *          HEADERS
+ ******************************
+ */
+
+#include <osa.h>
+
+/*
+ ******************************
+ *          MACROS
+ ******************************
+ */
+
+#define INIT_IRQ_HANDLE_MAGIC(ih)               \
+do {                                            \
+	((struct _irq_handle *)ih)->magic[0] = 'I'; \
+	((struct _irq_handle *)ih)->magic[1] = 'r'; \
+	((struct _irq_handle *)ih)->magic[2] = 'Q'; \
+	((struct _irq_handle *)ih)->magic[3] = 'h'; \
+} while (0)
+
+#define IS_IRQ_HANDLE_VALID(ih)                 \
+	('I' == ((struct _irq_handle *)ih)->magic[0] && \
+	'r' == ((struct _irq_handle *)ih)->magic[1] && \
+	'Q' == ((struct _irq_handle *)ih)->magic[2] && \
+	'h' == ((struct _irq_handle *)ih)->magic[3])
+
+#define CLEAN_IRQ_HANDLE_MAGIC(ih)              \
+do {                                            \
+	((struct _irq_handle *)ih)->magic[0] = 0;   \
+	((struct _irq_handle *)ih)->magic[1] = 0;   \
+	((struct _irq_handle *)ih)->magic[2] = 0;   \
+	((struct _irq_handle *)ih)->magic[3] = 0;   \
+} while (0)
+
+/*
+ ******************************
+ *          TYPES
+ ******************************
+ */
+
+struct _irq_handle {
+	uint8_t magic[4];
+
+	int32_t irq;
+	void (*isr)(void *);
+	void (*dsr)(void *);
+	void *arg;
+
+	struct tasklet_struct tl;
+};
+
+/*
+ ******************************
+ *          FUNCTIONS
+ ******************************
+ */
+
+/*
+ * Name:        osa_disable_irq
+ *
+ * Description: disable the irqs
+ *
+ * Params:      none
+ *
+ * Returns:     none
+ *
+ * Notes:       none
+ */
+void osa_disable_irq(void)
+{
+	local_irq_disable();
+}
+OSA_EXPORT_SYMBOL(osa_disable_irq);
+
+/*
+ * Name:        osa_enable_irq
+ *
+ * Description: enable the irqs
+ *
+ * Params:      none
+ *
+ * Returns:     none
+ *
+ * Notes:       none
+ */
+void osa_enable_irq(void)
+{
+	local_irq_enable();
+}
+OSA_EXPORT_SYMBOL(osa_enable_irq);
+
+/*
+ * Name:        osa_save_irq
+ *
+ * Description: save the irq flags and disable the irqs
+ *
+ * Params:      flags - the irq flags to be saved
+ *
+ * Returns:     none
+ *
+ * Notes:       none
+ */
+void osa_save_irq(uint32_t *flags)
+{
+	if (flags)
+		local_irq_save(*((ulong_t *)(flags)));
+}
+OSA_EXPORT_SYMBOL(osa_save_irq);
+
+/*
+ * Name:        osa_restore_irq
+ *
+ * Description: restore the irq flags
+ *
+ * Params:      flags - the irq flags to be restored
+ *
+ * Returns:     none
+ *
+ * Notes:       none
+ */
+void osa_restore_irq(uint32_t *flags)
+{
+	OSA_ASSERT(flags);
+
+	local_irq_restore(*(ulong_t *)flags);
+}
+OSA_EXPORT_SYMBOL(osa_restore_irq);
+
+static irqreturn_t _isr_shell(int irq, void *dev_id)
+{
+	struct _irq_handle *irq_handle = (struct _irq_handle *)dev_id;
+
+	if (irq_handle->isr)
+		irq_handle->isr(irq_handle->arg);
+
+	/*
+	 * FIXME:
+	 * here is a bug.
+	 * isr should return the status whether the irq is handled.
+	 * that means isr needs a return value.
+	 */
+
+	if (irq_handle->dsr)
+		tasklet_schedule(&irq_handle->tl);
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * Name:        osa_hook_irq
+ *
+ * Description: request the irq and hook the callback isr
+ *
+ * Params:      irq - irq number to be hooked
+ *              isr - the interrupt service routine of the irq
+ *              dsr - the delayed service routine of the irq, no use in linux
+ *              arg - the argument of the isr/dsr when called
+ *              param       - the os-specific param of irq
+ *              param->flag - status flag of irq
+ *                SA_SHIRQ         interrupt is shared
+ *                SA_INTERRUPT     disable local interrupts while processing
+ *                SA_SAMPLE_RANDOM the interrupt can be used for entropy
+ *
+ * Returns:     osa_irq_t - the irq-hooking handle
+ *
+ * Notes:       none
+ */
+osa_irq_t osa_hook_irq(int32_t irq,
+		       void (*isr)(void *), void (*dsr)(void *),
+		       void *arg, struct osa_irq_param *param)
+{
+	struct _irq_handle *ret = NULL;
+	int32_t res;
+
+	OSA_ASSERT((irq >= 0) && (irq < NR_IRQS));
+	OSA_ASSERT(isr || dsr);
+	OSA_ASSERT(param);
+
+	ret = kmalloc(sizeof(struct _irq_handle), GFP_KERNEL);
+	if (!ret) {
+		osa_dbg_print(DBG_ERR, "ERROR - failed to create irq handle\n");
+		return NULL;
+	}
+
+	INIT_IRQ_HANDLE_MAGIC(ret);
+
+	ret->irq = irq;
+	ret->isr = isr;
+	ret->dsr = dsr;
+	ret->arg = arg;
+
+	if (dsr) {
+		ret->tl.next = NULL;
+		ret->tl.state = 0;
+		atomic_set(&ret->tl.count, 0);
+		ret->tl.func = (void (*)(ulong_t))dsr;
+		ret->tl.data = (ulong_t) arg;
+	}
+
+	res = request_irq(irq,
+			  _isr_shell,
+			  (ulong_t) param->flag, "osa", (void *)ret);
+	if (res == 0) {
+		ret = (osa_irq_t) ret;
+	} else {
+		osa_dbg_print(DBG_ERR, "ERROR - failed to hook irq %d\n", irq);
+		CLEAN_IRQ_HANDLE_MAGIC(ret);
+		kfree(ret);
+		ret = NULL;
+	}
+
+	return ret;
+}
+OSA_EXPORT_SYMBOL(osa_hook_irq);
+
+/*
+ * Name:        osa_free_irq
+ *
+ * Description: free the irq-hooking
+ *
+ * Params:      handle - the handle of irq-hooking
+ *
+ * Returns:     osa_err_t - the status of freeing irq, always OK.
+ *
+ * Notes:       none
+ */
+osa_err_t osa_free_irq(osa_irq_t handle)
+{
+	struct _irq_handle *irq_handle = handle;
+
+	OSA_ASSERT(IS_IRQ_HANDLE_VALID(irq_handle));
+	/*
+	 * to avoid the condition of freeing irq when isr is called,
+	 * the irq will be disabled and then enabled in free_irq.
+	 * so what we need to do here is to free_irq and then
+	 * to free irq handle.
+	 */
+	free_irq(irq_handle->irq, irq_handle);
+
+	CLEAN_IRQ_HANDLE_MAGIC(irq_handle);
+	kfree(irq_handle);
+
+	return OSA_OK;
+}
+OSA_EXPORT_SYMBOL(osa_free_irq);
+
+/*
+ * Name:        osa_mask_irq
+ *
+ * Description: mask the irq
+ *
+ * Params:      irq - the irq number to be masked
+ *
+ * Returns:     none
+ *
+ * Notes:       no implementation in linux currently
+ */
+void osa_mask_irq(uint32_t irq)
+{
+	OSA_ASSERT((irq >= 0) && (irq < NR_IRQS));
+	disable_irq(irq);
+}
+OSA_EXPORT_SYMBOL(osa_mask_irq);
+
+/*
+ * Name:        osa_unmask_irq
+ *
+ * Description: unmask the irq
+ *
+ * Params:      irq - the irq number to be unmasked
+ *
+ * Returns:     none
+ *
+ * Notes:       no implementation in linux currently
+ */
+void osa_unmask_irq(uint32_t irq)
+{
+	OSA_ASSERT((irq >= 0) && (irq < NR_IRQS));
+	enable_irq(irq);
+}
+OSA_EXPORT_SYMBOL(osa_unmask_irq);
diff --git a/drivers/marvell/security/marvelltee/src/osa/osa_list.c b/drivers/marvell/security/marvelltee/src/osa/osa_list.c
new file mode 100644
index 0000000..6c1b0f5
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/osa/osa_list.c
@@ -0,0 +1,80 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ * Filename     : osa_list.c
+ * Author       : Dafu Lv
+ * Date Created : 21/03/08
+ * Description  : This is the source code of list-related functions in osa.
+ *
+ */
+
+/*
+ ******************************
+ *          HEADERS
+ ******************************
+ */
+
+#include <osa.h>
+
+void osa_list_init_head(struct osa_list *head)
+{
+	OSA_ASSERT(head);
+
+	head->next = head;
+	head->prev = head;
+}
+OSA_EXPORT_SYMBOL(osa_list_init_head);
+
+void osa_list_add(struct osa_list *entry, struct osa_list *head)
+{
+	OSA_ASSERT(entry);
+	OSA_ASSERT(head);
+
+	entry->next = head->next;
+	entry->prev = head;
+	head->next->prev = entry;
+	head->next = entry;
+}
+OSA_EXPORT_SYMBOL(osa_list_add);
+
+void osa_list_add_tail(struct osa_list *entry, struct osa_list *head)
+{
+	OSA_ASSERT(entry);
+	OSA_ASSERT(head);
+
+	entry->next = head;
+	entry->prev = head->prev;
+	head->prev->next = entry;
+	head->prev = entry;
+}
+OSA_EXPORT_SYMBOL(osa_list_add_tail);
+
+void osa_list_del(struct osa_list *entry)
+{
+	OSA_ASSERT(entry);
+
+	entry->prev->next = entry->next;
+	entry->next->prev = entry->prev;
+}
+OSA_EXPORT_SYMBOL(osa_list_del);
+
+bool osa_list_empty(struct osa_list *head)
+{
+	OSA_ASSERT(head);
+
+	return ((head->next == head) && (head->prev == head));
+}
+OSA_EXPORT_SYMBOL(osa_list_empty);
diff --git a/drivers/marvell/security/marvelltee/src/osa/osa_mem.c b/drivers/marvell/security/marvelltee/src/osa/osa_mem.c
new file mode 100644
index 0000000..3101cc5
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/osa/osa_mem.c
@@ -0,0 +1,1121 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ * Filename     : osa_mem.c
+ * Author       : Dafu Lv
+ * Date Created : 21/03/08
+ * Description  : This is the source code of memory-related functions in osa.
+ *
+ */
+
+/*
+ ******************************
+ *          HEADERS
+ ******************************
+ */
+
+/*
+ * typically OSA supports the test of checking memory leak.
+ * all the memory alloc/free and new/delete will be overloaded
+ * by the memory-leak-checking tool.
+ * since osa_mem.c implements the memory management behaviors,
+ * the interfaces in this file should not be overloaded.
+ * the macro, "OSA_DISABLE_ML_OSA_MEM", makes this file invisible to
+ * the overloading behaviors of the memory-leak checking tool.
+ */
+#define OSA_DISABLE_ML_OSA_MEM
+
+#include <osa.h>
+
+/*
+ ******************************
+ *          MACROS
+ ******************************
+ */
+
+/*
+ * *normally* alloc_pages can support less than
+ * or equal to OSA_4M memory block.
+ * the capability of alloc_pages can be configured
+ * in .config. (CONFIG_FORCE_MAX_ZONEORDER)
+ */
+#define KMEM_ALLOC_MAX_SIZE     (OSA_4M)
+
+#define L1_CACHE_LINE_SIZE      (32)
+#define L2_CACHE_LINE_SIZE      (32)
+
+#define L1_CACHE_LINE_MASK      (0xFFFFFFE0)
+
+#define MAKE_PAGE_VALID(va)                                         \
+do {                                                                \
+	volatile uint32_t tmp;                                          \
+	uint32_t ret;                                                   \
+	uint32_t *p = (uint32_t *)&tmp;                                 \
+	ret = copy_from_user((void *)p, (void __user *)va, 1);          \
+	ret = copy_to_user((void __user *)va, (__force void *)p, 1);    \
+} while (0)
+
+/*
+ ******************************
+ *          TYPES
+ ******************************
+ */
+
+struct _pages_record {
+	struct osa_list node;
+
+	void __kernel *vir_addr;
+	uint32_t size;
+};
+
+struct _phys_mem_info_header {
+	void *alloc_virt_addr;
+	void *alloc_phys_addr;
+	uint32_t alloc_size;
+	bool is_cached;
+};
+
+/*
+ ******************************
+ *          VARIABLES
+ ******************************
+ */
+static struct osa_list _g_alloc_pages_list = OSA_LIST_HEAD(_g_alloc_pages_list);
+static DEFINE_SPINLOCK(_g_pg_walk_by_cp15_lock);
+
+static DEFINE_SEMAPHORE(_g_list_sema);
+
+/*
+ ******************************
+ *          FUNCTIONS
+ ******************************
+ */
+
+/*
+ * Name:        osa_kmem_alloc
+ *
+ * Description: allocate physical/virtual-sequential memory block in kernel
+ *
+ * Params:      size - the size of the memory block
+ *
+ * Returns:     void __kernel * - the pointer to the memory block allocated
+ *
+ * Notes:       no call in isr
+ */
+void __kernel *osa_kmem_alloc(uint32_t size)
+{
+	void __kernel *ret;
+
+	OSA_ASSERT(size);
+
+	if (size < OSA_128K)
+		ret =  kmalloc(size, GFP_KERNEL);
+	else if (size <= KMEM_ALLOC_MAX_SIZE) {
+		struct page *page;
+		struct _pages_record *record;
+
+		record =
+		    (struct _pages_record *)
+		    kmalloc(sizeof(struct _pages_record), GFP_KERNEL);
+		if (!record) {
+			osa_dbg_print(DBG_ERR,
+				      "ERROR - failed to alloc a page record in osa_kmem_alloc\n");
+			return NULL;
+		}
+
+		page = alloc_pages(GFP_KERNEL, get_order(size));
+		if (!page) {
+			osa_dbg_print(DBG_ERR,
+				      "ERROR - failed to alloc pages in osa_kmem_alloc\n");
+			kfree(record);
+			return NULL;
+		}
+
+		ret = (void __kernel *)page_address(page);
+
+		record->vir_addr = ret;
+		record->size = size;
+
+		down(&_g_list_sema);
+		osa_list_add(&record->node, &_g_alloc_pages_list);
+		up(&_g_list_sema);
+	} else {
+		osa_dbg_print(DBG_ERR,
+			      "ERROR - too large memory block required\n");
+		ret = NULL;
+	}
+
+	return ret;
+}
+OSA_EXPORT_SYMBOL(osa_kmem_alloc);
+
+/*
+ * Name:        osa_kmem_free
+ *
+ * Description: free the memory block allocated by osa_kmem_alloc
+ *
+ * Params:      addr - the pointer to the memory block to free
+ *
+ * Returns:     none
+ *
+ * Notes:       no call in isr
+ */
+void osa_kmem_free(void __kernel *addr)
+{
+	struct _pages_record *record = NULL;
+	struct osa_list *ptr = NULL;
+
+	OSA_ASSERT(addr);
+
+	down(&_g_list_sema);
+	osa_list_iterate(&_g_alloc_pages_list, ptr) {
+		OSA_LIST_ENTRY(ptr, struct _pages_record, node, record);
+		OSA_ASSERT(record);
+		if (record->vir_addr == addr)
+			break;
+	}
+
+	if (ptr != &_g_alloc_pages_list) {
+		/* find record in the list */
+		free_pages((ulong_t) addr, get_order(record->size));
+		osa_list_del(&record->node);
+		up(&_g_list_sema);
+		kfree(record);
+	} else {
+		up(&_g_list_sema);
+		kfree(addr);
+	}
+}
+OSA_EXPORT_SYMBOL(osa_kmem_free);
+
+/*
+ * Name:        osa_vmem_alloc
+ *
+ * Description: allocate the virtual-sequential memory block in kernel
+ *
+ * Params:      size - the size of the memory block
+ *              attr - attribute of the memory block, see osa_mem_attr_t
+ *
+ * Returns:     void __kernel * - the pointer to the memory block allocated
+ *
+ * Notes:       no call in isr
+ *              OSA_MEM_WRITE_ONLY is not supported in linux
+ */
+void __kernel *osa_vmem_alloc(uint32_t size, osa_mem_attr_t attr)
+{
+	void __kernel *ret = NULL;
+
+	OSA_ASSERT(size);
+
+	switch (attr) {
+	case OSA_MEM_NO_ACCESS:
+		ret = __vmalloc(size, GFP_KERNEL | __GFP_HIGHMEM, PAGE_NONE);
+		break;
+	case OSA_MEM_READ_ONLY:
+		ret =
+		    __vmalloc(size, GFP_KERNEL | __GFP_HIGHMEM, PAGE_READONLY);
+		break;
+	case OSA_MEM_WRITE_ONLY:
+		ret = __vmalloc(size, GFP_KERNEL | __GFP_HIGHMEM, PAGE_KERNEL);
+		break;
+	case OSA_MEM_READ_WRITE:
+		ret = __vmalloc(size, GFP_KERNEL | __GFP_HIGHMEM, PAGE_KERNEL);
+		break;
+	default:
+		OSA_ASSERT(0);
+	}
+
+	return ret;
+}
+OSA_EXPORT_SYMBOL(osa_vmem_alloc);
+
+/*
+ * Name:        osa_vmem_free
+ *
+ * Description: free the memory block allocated by osa_vmem_alloc
+ *
+ * Params:      addr - the pointer to the memory block to free
+ *
+ * Returns:     none
+ *
+ * Notes:       no call in isr
+ */
+void osa_vmem_free(void __kernel *addr)
+{
+	OSA_ASSERT(addr);
+
+	vfree(addr);
+}
+OSA_EXPORT_SYMBOL(osa_vmem_free);
+
+/*
+ * Name:        osa_pages_alloc
+ *
+ * Description: allocate pages in kernel
+ *
+ * Params:      nr - the number of pages
+ *
+ * Returns:     void __kernel * - the pointer to the memory block allocated
+ *
+ * Notes:       no call in isr
+ */
+void __kernel *osa_pages_alloc(uint32_t nr)
+{
+	void __kernel *ret;
+	uint32_t size = PAGE_SIZE * nr;
+
+	OSA_ASSERT(nr);
+
+	if (size <= KMEM_ALLOC_MAX_SIZE) {
+		struct page *page;
+		struct _pages_record *record;
+		void *phys;
+		uint32_t i;
+
+		record =
+		    (struct _pages_record *)
+		    kmalloc(sizeof(struct _pages_record), GFP_KERNEL);
+		if (!record) {
+			osa_dbg_print(DBG_ERR,
+				      "ERROR - failed to alloc a page record in osa_pages_alloc\n");
+			return NULL;
+		}
+
+		page = alloc_pages(GFP_KERNEL, get_order(size));
+		if (!page) {
+			osa_dbg_print(DBG_ERR,
+				      "ERROR - failed to alloc pages in osa_pages_alloc\n");
+			kfree(record);
+			return NULL;
+		}
+
+		ret = (void __kernel *)page_address(page);
+
+		/*
+		 * in the current kernel,
+		 * remap_pfn_range works in the condition of
+		 * PageReserved is set.
+		 */
+		phys = (void *)(ulong_t)
+			__virt_to_phys((ulong_t)ret);
+		for (i = 0; i < nr; i++) {
+			SetPageReserved(pfn_to_page
+					(((ulong_t) phys >> PAGE_SHIFT) + i));
+		}
+
+		record->vir_addr = ret;
+		record->size = size;
+
+		down(&_g_list_sema);
+		osa_list_add(&record->node, &_g_alloc_pages_list);
+		up(&_g_list_sema);
+	} else {
+		osa_dbg_print(DBG_ERR,
+			      "ERROR - too large memory block required\n");
+		ret = NULL;
+	}
+
+	return ret;
+}
+OSA_EXPORT_SYMBOL(osa_pages_alloc);
+
+/*
+ * Name:        osa_pages_free
+ *
+ * Description: free the memory block allocated by osa_pages_alloc
+ *
+ * Params:      addr - the pointer to the memory block to free
+ *
+ * Returns:     none
+ *
+ * Notes:       no call in isr
+ */
+void osa_pages_free(void __kernel *addr)
+{
+	struct _pages_record *record = NULL;
+	struct osa_list *ptr = NULL;
+	void *phys;
+	uint32_t nr;
+	uint32_t i;
+
+	OSA_ASSERT(addr);
+
+	down(&_g_list_sema);
+	osa_list_iterate(&_g_alloc_pages_list, ptr) {
+		OSA_LIST_ENTRY(ptr, struct _pages_record, node, record);
+		OSA_ASSERT(record);
+		if (record->vir_addr == addr)
+			break;
+	}
+
+	OSA_ASSERT(ptr != &_g_alloc_pages_list);
+
+	phys = (void *)(ulong_t)
+		__virt_to_phys((ulong_t)addr);
+	nr = record->size >> PAGE_SHIFT;
+	for (i = 0; i < nr; i++) {
+		ClearPageReserved(pfn_to_page
+				  (((ulong_t) phys >> PAGE_SHIFT) + i));
+	}
+
+	/* find record in the list */
+	free_pages((ulong_t) addr, get_order(record->size));
+	osa_list_del(&record->node);
+	up(&_g_list_sema);
+	kfree(record);
+}
+OSA_EXPORT_SYMBOL(osa_pages_free);
+
+osa_err_t osa_phys_mem_pool_init(void)
+{
+	return OSA_OK;
+}
+
+void osa_phys_mem_pool_cleanup(void)
+{
+}
+
+void *osa_alloc_phys_mem(uint32_t size, bool is_cached, uint32_t alignment,
+			 void **phys)
+{
+	uint32_t mem_blk_size;
+	void *alloc_virt_addr;
+	void *alloc_phys_addr;
+	void *ret_virt_addr;
+	struct _phys_mem_info_header *rec_virt_addr;
+
+	if (!size || !phys)
+		return NULL;
+
+	mem_blk_size = size + sizeof(struct _phys_mem_info_header) + alignment;
+
+	if (is_cached) {
+		alloc_virt_addr = kmalloc(mem_blk_size, GFP_KERNEL);
+		if (alloc_virt_addr == NULL) {
+			*phys = NULL;
+			return NULL;
+		}
+		alloc_phys_addr = (void *)(ulong_t)
+			__virt_to_phys((ulong_t)alloc_virt_addr);
+	} else {
+		alloc_virt_addr =
+		    dma_alloc_coherent(NULL, mem_blk_size,
+				       (dma_addr_t *)&alloc_phys_addr,
+				       GFP_KERNEL);
+		if (alloc_virt_addr == NULL) {
+			*phys = NULL;
+			return NULL;
+		}
+	}
+
+	/* calculate the virtual address returned */
+	ret_virt_addr = (void *)(((ulong_t)
+				  alloc_virt_addr + alignment -
+				  1) & (~(alignment - 1)));
+	do {
+		if (ret_virt_addr - alloc_virt_addr
+		    >= sizeof(struct _phys_mem_info_header)) {
+			rec_virt_addr =
+				(struct _phys_mem_info_header *)((ulong_t)
+					ret_virt_addr - sizeof(struct _phys_mem_info_header));
+			break;
+		}
+		ret_virt_addr = (void *)((ulong_t) ret_virt_addr + alignment);
+	} while (1);
+
+	OSA_ASSERT((ulong_t) rec_virt_addr >= (ulong_t) alloc_virt_addr);
+	OSA_ASSERT((ulong_t) ret_virt_addr + size
+			<= (ulong_t) alloc_virt_addr + mem_blk_size);
+
+	rec_virt_addr->alloc_virt_addr = alloc_virt_addr;
+	rec_virt_addr->alloc_phys_addr = alloc_phys_addr;
+	rec_virt_addr->alloc_size = mem_blk_size;
+	rec_virt_addr->is_cached = is_cached;
+
+	*phys = (void *)((ulong_t) alloc_phys_addr +
+			((ulong_t) ret_virt_addr - (ulong_t) alloc_virt_addr));
+
+	return ret_virt_addr;
+}
+OSA_EXPORT_SYMBOL(osa_alloc_phys_mem);
+
+void osa_free_phys_mem(void *virt)
+{
+	struct _phys_mem_info_header *rec_virt_addr;
+
+	OSA_ASSERT(virt);
+
+	rec_virt_addr = (struct _phys_mem_info_header *)((ulong_t)virt -
+					 sizeof(struct
+						_phys_mem_info_header));
+
+	if (rec_virt_addr->is_cached) {
+		kfree(rec_virt_addr->alloc_virt_addr);
+	} else {
+		dma_free_coherent(NULL, rec_virt_addr->alloc_size,
+				  rec_virt_addr->alloc_virt_addr,
+				  (dma_addr_t) rec_virt_addr->alloc_phys_addr);
+	}
+}
+OSA_EXPORT_SYMBOL(osa_free_phys_mem);
+
+/*
+ * Name:        _osa_iounmap
+ *
+ * Description: unmap a physical-sequential addressing space from kernel space
+ *
+ * Params:      vir_addr - the virtual address to be unmapped from
+ *              size     - the size of mapping memory block (no use)
+ *
+ * Returns:     status code
+ *              TZ_OK          - success
+ *              TZ_OSA_BAD_ARG - bad argument
+ *
+ * Notes:       none
+ */
+static osa_err_t _osa_iounmap(void __kernel *vir_addr, uint32_t size)
+{
+#ifdef MK2
+	__iounmap((void __iomem *)vir_addr);
+#else
+    #ifdef CONFIG_64BIT
+		__iounmap((void __iomem *)vir_addr);
+    #else
+		__arm_iounmap((void __iomem *)vir_addr);
+    #endif
+#endif
+	return OSA_OK;
+}
+
+/*
+ * Name:        osa_ioremap
+ *
+ * Description: the wrapper for mapping noncacheable-nonbufferable space
+ *
+ * Params:      phy_addr - the physical address of the addressing space
+ *              size     - the size of the addressing space (1M aligned)
+ *
+ * Returns:     void __kernel * - the virtual address of the mapping block
+ *                                NULL for an error occures.
+ *
+ * Notes:       none
+ */
+void __kernel *osa_ioremap(void *phy_addr, uint32_t size)
+{
+	return ioremap((ulong_t) phy_addr, size);
+}
+OSA_EXPORT_SYMBOL(osa_ioremap);
+
+/*
+ * Name:        osa_iounmap
+ *
+ * Description: the wrapper for unmapping noncacheable-nonbufferable space
+ *
+ * Params:      vir_addr - the virtual address to be unmapped from
+ *              size     - the size of mapping memory block (no use)
+ *
+ * Returns:     status code
+ *              TZ_OK          - success
+ *              TZ_OSA_BAD_ARG - bad argument
+ * Notes:       none
+ */
+osa_err_t osa_iounmap(void __kernel *vir_addr, uint32_t size)
+{
+	return _osa_iounmap((void __iomem *)vir_addr, size);
+}
+OSA_EXPORT_SYMBOL(osa_iounmap);
+
+/*
+ * Name:        osa_ioremap_cached
+ *
+ * Description: the wrapper for mapping cacheable-bufferable space
+ *
+ * Params:      phy_addr - the physical address of the addressing space
+ *              size     - the size of the addressing space (1M aligned)
+ *
+ * Returns:     void __kernel * - the virtual address of the mapping block
+ *                                NULL for an error occures.
+ *
+ * Notes:       none
+ */
+void __kernel *osa_ioremap_cached(void *phy_addr, uint32_t size)
+{
+#ifdef CONFIG_64BIT
+	return ioremap_cache((ulong_t) phy_addr, size);
+#else
+	return ioremap_cache((ulong_t) phy_addr, size);
+#endif
+}
+OSA_EXPORT_SYMBOL(osa_ioremap_cached);
+
+/*
+ * Name:        osa_iounmap_cached
+ *
+ * Description: the wrapper for unmapping cacheable-bufferable space
+ *
+ * Params:      vir_addr - the virtual address to be unmapped from
+ *              size     - the size of mapping memory block (no use)
+ *
+ * Returns:     status code
+ *              TZ_OK          - success
+ *              TZ_OSA_BAD_ARG - bad argument
+ *
+ * Notes:       none
+ */
+osa_err_t osa_iounmap_cached(void __kernel *vir_addr, uint32_t size)
+{
+	return _osa_iounmap((void __iomem *)vir_addr, size);
+}
+OSA_EXPORT_SYMBOL(osa_iounmap_cached);
+
+#ifdef CONFIG_64BIT
+#define GET_PET_ATTRIDX(pteval)		(uint32_t)(((pteval) & 0x1C) >> 2)
+#define GET_MAIR_ID(attr)		((attr) & 0x7)
+#else
+#ifdef CONFIG_ARM_LPAE
+#define GET_PET_ATTRIDX(pteval)		(uint32_t)(((pteval) & 0x1C) >> 2)
+#define GET_MAIR_NUM(attr)		(((attr) & 0x4) >> 2)
+#define GET_MAIR_ID(attr)		((attr) & 0x3)
+#else
+#define GET_PET_ATTRIDX(pteval)	(uint32_t)((((pteval) & (0x040)) >> 4) | \
+										(((pteval) & (0xC)) >> 2))
+#endif
+#endif
+static osa_err_t _virt_to_phys_by_pg_mapping_ex(struct mm_struct *mm,
+	ulong_t va, bool *cacheable, ulong_t *pa)
+{
+	pgd_t *pgd;
+	pud_t *pud;
+	pmd_t *pmd;
+	pte_t *pte;
+	ulong_t pfn;
+
+#ifdef CONFIG_64BIT
+	uint64_t mair;
+#else
+#ifdef CONFIG_ARM_LPAE
+	uint32_t mair;
+#endif
+#endif
+	uint8_t *pmair = (uint8_t *)&mair;
+
+#ifdef pte_offset_map_lock
+	spinlock_t *ptl;
+#endif
+	void *pa_wt = INVALID_PHYS_ADDR;
+
+	uint32_t attridx;
+
+	osa_err_t ret = OSA_ERR;
+
+	down_read(&mm->mmap_sem);
+
+	pgd = pgd_offset(mm, va);
+	if (pgd_none(*pgd) || pgd_bad(*pgd))
+		goto _bad_pgd;
+
+	pud = pud_offset(pgd, va);
+	if (pud_none(*pud) || pud_bad(*pud))
+		goto _bad_pud;
+
+	pmd = pmd_offset(pud, va);
+	if (pmd_none(*pmd) || pmd_bad(*pmd))
+		goto _bad_pmd;
+
+#ifdef pte_offset_map_lock
+	pte = pte_offset_map_lock(mm, pmd, va, &ptl);
+#else
+	pte = pte_offset_map(pmd, va);
+#endif
+	if (pte_none(*pmd))
+		goto _non_pte;
+
+	pfn = pte_pfn(pte_val(*pte));
+
+	pa_wt = (void *)((pfn << PAGE_SHIFT)
+			+ ((ulong_t) va & (~PAGE_MASK)));
+
+#ifdef CONFIG_64BIT
+	attridx = GET_PET_ATTRIDX(pte_val(*pte));
+
+	__asm__ __volatile__("mrs %0, mair_el1" : "=r"(mair) : );
+
+	if (pmair[GET_MAIR_ID(attridx)] == 0x0) {
+		/* device */
+	*cacheable = false;
+	} else if (pmair[GET_MAIR_ID(attridx)] == 0x44) {
+		*cacheable = false;
+	} else {
+		*cacheable = true;
+	}
+#else
+#ifdef CONFIG_ARM_LPAE
+	attridx = GET_PET_ATTRIDX(pte_val(*pte));
+	if (GET_MAIR_NUM(attridx)) {
+		/* MAIR1 */
+		__asm__ __volatile__("mrc p15, 0, %0, c10, c2, 1\n\t" : "=r"(mair) : );
+	} else {
+		/* MAIR0 */
+		__asm__ __volatile__("mrc p15, 0, %0, c10, c2, 0\n\t" : "=r"(mair) : );
+	}
+
+	if (pmair[GET_MAIR_ID(attridx)] == 0x0) {
+		/* device */
+		*cacheable = false;
+	} else if (pmair[GET_MAIR_ID(attridx)] == 0x44) {
+		*cacheable = false;
+	} else {
+		*cacheable = true;
+	}
+#else
+	uint32_t prrr;
+	uint32_t nmrr;
+
+	attridx = GET_PET_ATTRIDX(pte_val(*pte));
+	__asm__ __volatile__("mrc p15, 0, %0, c10, c2, 0\n\t" : "=r"(prrr) : );
+	__asm__ __volatile__("mrc p15, 0, %0, c10, c2, 1\n\t" : "=r"(nmrr) : );
+
+	if (attridx == 6)
+		OSA_ASSERT(0);
+
+	if ((prrr & (0x3 << (2*attridx))) == (0x1 << (2*attridx))) {
+		/* device */
+		*cacheable = false;
+	} else if ((prrr & (0x3 << (2*attridx))) == (0x00 << (2*attridx))) {
+		/* Strongly-ordered. */
+		*cacheable = false;
+	} else if ((prrr & (0x3 << (2*attridx))) == (0x10 << (2*attridx))) {
+		/* Normal memory. */
+		if (((nmrr & (0x3 << (2*attridx))) == (0x0 << (2*attridx))) &&
+			((nmrr & (0x3 << (2*attridx + 16))) == (0x0 << (2*attridx + 16)))) {
+			*cacheable = false;
+		} else {
+			*cacheable = true;
+		}
+	} else {
+		OSA_ASSERT(0);
+	}
+#endif
+#endif
+
+	*pa = (ulong_t)pa_wt;
+	ret = OSA_OK;
+
+_non_pte:
+#ifdef pte_offset_map_lock
+	pte_unmap_unlock(pte, ptl);
+#endif
+
+_bad_pmd:
+_bad_pud:
+_bad_pgd:
+	up_read(&mm->mmap_sem);
+
+	return ret;
+}
+
+#define PHYS_ADDR_BITS (0xFFFFFFFFFFFF)
+
+#define PAR_FAULT  (0x1)
+
+#ifdef CONFIG_64BIT
+typedef union {
+	struct {
+		ulong_t  rsvd:56;
+		uint32_t inner:4;
+		uint32_t outer:4;
+	} bits;
+	ulong_t all;
+} phy_addr_reg;
+#else
+#ifdef CONFIG_ARM_LPAE
+typedef union {
+	struct {
+		unsigned long long  rsvd:56;
+		uint32_t inner:4;
+		uint32_t outer:4;
+	} bits;
+	unsigned long long all;
+} phy_addr_reg;
+#else
+typedef union {
+	struct {
+		ulong_t  rsvd:2;
+		uint32_t outer:2;
+		uint32_t inner:3;
+	} bits;
+	uint32_t all;
+} phy_addr_reg;
+#endif
+#endif
+
+/* FIXME - cacheable may be wrong! */
+static osa_err_t _osa_virt_to_phys_by_cp15_ex(
+	ulong_t virt,
+	bool *cacheable,
+	ulong_t *phys)
+{
+#ifdef CONFIG_64BIT
+	volatile ulong_t pardata;
+	phy_addr_reg par;
+	ulong_t flags;
+
+	spin_lock_irqsave(&_g_pg_walk_by_cp15_lock, flags);
+
+	if (virt > VMALLOC_START)
+		__asm__ __volatile__("at s1e1r, %0" : : "r"(virt));
+	else
+		__asm__ __volatile__("at s1e0r, %0" : : "r"(virt));
+
+	__asm__ __volatile__("mrs %0, par_el1" : "=r"(pardata) : );
+
+	spin_unlock_irqrestore(&_g_pg_walk_by_cp15_lock, flags);
+
+	if (PAR_FAULT & pardata)
+		return OSA_ERR;
+
+	par.all = pardata;
+	if (par.bits.outer == 0x4 &&
+		par.bits.inner == 0x4)
+		*cacheable = false;
+	else
+		*cacheable = true;
+
+	pardata &= ~(PAGE_SIZE - 1);
+	pardata |= (virt & (PAGE_SIZE - 1));
+	pardata &= PHYS_ADDR_BITS;
+
+	*phys = pardata;
+
+	return OSA_OK;
+#else
+#ifdef CONFIG_ARM_LPAE
+	ulong_t flags;
+	volatile unsigned long long pardata;
+	phy_addr_reg par;
+
+	spin_lock_irqsave(&_g_pg_walk_by_cp15_lock, flags);
+
+	/* fail to get the phys_addr when using 0, c7, c8, 1 */
+	__asm__ __volatile__("mcr p15, 0, %1, c7, c8, 0\n\t"
+		"mrrc p15, 0, %Q0, %R0, c7\n\t" : "=r"(pardata) : "r"
+		(virt));
+
+	spin_unlock_irqrestore(&_g_pg_walk_by_cp15_lock, flags);
+
+	if (PAR_FAULT & pardata)
+		return OSA_ERR;
+
+	par.all = pardata;
+	if (par.bits.outer == 0x4 &&
+		par.bits.inner == 0x4)
+		*cacheable = false;
+	else
+		*cacheable = true;
+
+	pardata &= ~(PAGE_SIZE - 1);
+	pardata |= (virt & (PAGE_SIZE - 1));
+	pardata &= PHYS_ADDR_BITS;
+
+	*phys = pardata;
+
+	return OSA_OK;
+#else
+	ulong_t flags;
+	volatile ulong_t pardata;
+	phy_addr_reg par;
+
+	spin_lock_irqsave(&_g_pg_walk_by_cp15_lock, flags);
+
+	/* fail to get the phys_addr when using 0, c7, c8, 1 */
+	__asm__ __volatile__("mcr p15, 0, %1, c7, c8, 0\n\t"
+		"mrc p15, 0, %0, c7, c4, 0\n\t" : "=r"(pardata) : "r"
+		(virt));
+
+	spin_unlock_irqrestore(&_g_pg_walk_by_cp15_lock, flags);
+
+	if (PAR_FAULT & pardata)
+		return OSA_ERR;
+
+	par.all = pardata;
+	if (par.bits.outer == 0x0 &&
+		(par.bits.inner & 0x4) == 0x0)
+		*cacheable = false;
+	else if (par.bits.outer > 0x0 &&
+			(par.bits.inner & 0x4) == 0x4)
+		*cacheable = true;
+	else
+		OSA_ASSERT(0);
+	pardata &= ~(PAGE_SIZE - 1);
+	pardata |= (virt & (PAGE_SIZE - 1));
+
+	*phys = pardata;
+
+	return OSA_OK;
+#endif
+#endif
+}
+
+/*
+ * Name:        osa_virt_to_phys
+ *
+ * Description: translate virtual address to physical address
+ *
+ * Params:      virt_addr - the virtual address
+ *
+ * Returns:     void * - the physical address
+ *
+ * Notes:       page table directory is saved in swapper_pg_dir
+ */
+void *osa_virt_to_phys(void *virt_addr)
+{
+	bool cacheable;
+
+	return osa_virt_to_phys_ex(virt_addr, &cacheable);
+}
+OSA_EXPORT_SYMBOL(osa_virt_to_phys);
+
+void *osa_virt_to_phys_ex(void *virt_addr, bool *cacheable)
+{
+	osa_err_t ret;
+	ulong_t pa = 0;
+
+	if (virt_addr < high_memory &&
+		(ulong_t) virt_addr >= PAGE_OFFSET) {
+		*cacheable = true;
+		return (void *)(ulong_t)
+			__virt_to_phys((ulong_t)virt_addr);
+	} else {
+		ret = _osa_virt_to_phys_by_cp15_ex((ulong_t)virt_addr, cacheable, &pa);
+		if (ret != OSA_OK) {
+		ret = _virt_to_phys_by_pg_mapping_ex(current->mm,
+				(ulong_t)virt_addr, cacheable, &pa);
+		}
+		OSA_ASSERT(ret == OSA_OK);
+		return (void *)pa;
+	}
+}
+OSA_EXPORT_SYMBOL(osa_virt_to_phys_ex);
+
+/*
+ * Name:        osa_invalidate_dcache
+ *
+ * Description: invalidate the data cache by the range of [start, start + size)
+ *
+ * Params:      mode  - kernel or user mode
+ *              start - start address
+ *              size  - size of the range
+ *
+ * Returns:     none
+ *
+ * Notes:       invalidate the entry of the data cache only
+ */
+void osa_invalidate_dcache(osa_mode_t mode, ulong_t start, uint32_t size)
+{
+#ifndef CONFIG_64BIT
+	ulong_t end = start + size;
+
+	start = (start & L1_CACHE_LINE_MASK);
+	end = ((end + L1_CACHE_LINE_SIZE - 1) & L1_CACHE_LINE_MASK);
+
+	asm volatile (" \
+		    mov ip, #0; \
+		 1: mcr p15, 0, %0, c7, c6, 1; \
+		    add %0, %0, #32; \
+		    cmp %0, %1; \
+		    blo 1b; \
+		    mrc p15, 0, ip, c7, c10, 4; @ drain write buffer \
+		    mov ip, ip; \
+		    sub pc, pc, #4; \
+		    "
+		    :
+		    : "r" (start), "r"(end)
+		    : "ip");
+#endif
+}
+OSA_EXPORT_SYMBOL(osa_invalidate_dcache);
+
+/*
+ * Name:        osa_clean_dcache
+ *
+ * Description: clean the data cache by the range of [start, start + size)
+ *
+ * Params:      mode  - kernel or user mode
+ *              start - start address
+ *              size  - size of the range
+ *
+ * Returns:     none
+ *
+ * Notes:       write back the content of cache to the external memory only
+ */
+void osa_clean_dcache(osa_mode_t mode, ulong_t start, uint32_t size)
+{
+#ifndef CONFIG_64BIT
+	ulong_t end = start + size;
+
+	start = (start & L1_CACHE_LINE_MASK);
+	end = ((end + L1_CACHE_LINE_SIZE - 1) & L1_CACHE_LINE_MASK);
+
+	asm volatile (" \
+		    mov ip, #0; \
+		 1: mcr p15, 0, %0, c7, c10, 1; \
+		    add %0, %0, #32; \
+		    cmp %0, %1; \
+		    blo 1b; \
+		    mrc p15, 0, ip, c7, c10, 4; @ drain write buffer \
+		    mov ip, ip; \
+		    sub pc, pc, #4; \
+		    "
+		    :
+		    : "r" (start), "r"(end)
+		    : "ip");
+#endif
+}
+OSA_EXPORT_SYMBOL(osa_clean_dcache);
+
+#ifdef BUILD_IN
+/*
+ * Name:        osa_flush_dcache
+ *
+ * Description: flush the data cache by the range of [start, start + size)
+ *
+ * Params:      mode  - kernel or user mode
+ *              start - start address
+ *              size  - size of the range
+ *
+ * Returns:     none
+ *
+ * Notes:       flush = clean + invalidate
+ */
+void osa_flush_dcache(osa_mode_t mode, ulong_t start, uint32_t size)
+{
+	/* flush_cache_all(); */
+	dmac_flush_range((void *)start, (void *)(start + size));
+}
+OSA_EXPORT_SYMBOL(osa_flush_dcache);
+#endif
+
+/*
+ * Name:        osa_flush_dcache_all
+ *
+ * Description: flush all the data cache
+ *
+ * Params:      none
+ *
+ * Returns:     none
+ *
+ * Notes:       flush = clean + invalidate
+ */
+void osa_flush_dcache_all(void)
+{
+	flush_cache_all();
+}
+OSA_EXPORT_SYMBOL(osa_flush_dcache_all);
+
+osa_err_t osa_validate_vmem(void __user *vir_addr, uint32_t size)
+{
+	ulong_t start = ((ulong_t) vir_addr & PAGE_MASK);
+	ulong_t end = ((ulong_t) vir_addr + size + PAGE_SIZE - 1) & PAGE_MASK;
+
+	struct vm_area_struct *vma;
+	ulong_t cur = start, cur_end;
+	int32_t err, write;
+
+	if (!size)
+		return OSA_OK;
+
+	down_read(&current->mm->mmap_sem);
+
+	do {
+		vma = find_vma(current->mm, cur);
+		if (!vma) {
+			up_read(&current->mm->mmap_sem);
+			return OSA_ERR;
+		}
+		cur_end = ((end <= vma->vm_end) ? end : vma->vm_end);
+
+		/* this vma is NOT mmap-ed and pfn-direct mapped */
+		if (!(vma->vm_flags & (VM_IO | VM_PFNMAP))) {
+			write = ((vma->vm_flags & VM_WRITE) != 0);
+			err = get_user_pages(current, current->mm,
+					     (ulong_t) cur,
+					     (cur_end - cur) >> PAGE_SHIFT,
+					     write, 0, NULL, NULL);
+			if (err < 0) {
+				up_read(&current->mm->mmap_sem);
+				return OSA_ERR;
+			}
+		}
+
+		cur = cur_end;
+	} while (cur_end < end);
+
+	up_read(&current->mm->mmap_sem);
+
+	return OSA_OK;
+}
+OSA_EXPORT_SYMBOL(osa_validate_vmem);
+
+osa_err_t osa_invalidate_vmem(void __user *vir_addr, uint32_t size)
+{
+	return OSA_OK;
+}
+OSA_EXPORT_SYMBOL(osa_invalidate_vmem);
+
+/*
+ * Name:        osa_validate_string
+ *
+ * Description: validate the space of string in user space
+ *
+ * Params:      string - the virtual address of the string
+ *
+ * Returns:     status code
+ *              OSA_OK      - no error
+ *              OSA_BAD_ARG - bad argument
+ *
+ * Notes:       no size required in string
+ *              when allocating a *real* block for it.
+ */
+osa_err_t osa_validate_string(void __user *string)
+{
+	OSA_ASSERT(string);
+
+	return osa_validate_vmem(string, strlen_user(string) + 1);
+}
+OSA_EXPORT_SYMBOL(osa_validate_string);
+
+/*
+ * Name:        osa_invalidate_string
+ *
+ * Description: invalidate the memory of string in user space.
+ *              the memory is again suitable to be swapped by kswapd.
+ *
+ * Params:      string - the virtual address of the string
+ *
+ * Returns:     status code
+ *              OSA_OK      - no error
+ *              OSA_BAD_ARG - bad argument
+ *
+ * Notes:       since there is no swap action in arm linux,
+ *              this function is set (almost) NULL.
+ */
+osa_err_t osa_invalidate_string(void __user *string)
+{
+	OSA_ASSERT(string);
+
+	return osa_invalidate_vmem(string, strlen_user(string) + 1);
+}
+OSA_EXPORT_SYMBOL(osa_invalidate_string);
diff --git a/drivers/marvell/security/marvelltee/src/osa/osa_sched.c b/drivers/marvell/security/marvelltee/src/osa/osa_sched.c
new file mode 100644
index 0000000..9194398
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/osa/osa_sched.c
@@ -0,0 +1,24 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+
+#include <osa.h>
+
+void osa_wakeup_process(struct task_struct *tsk)
+{
+	wake_up_process(tsk);
+}
diff --git a/drivers/marvell/security/marvelltee/src/osa/osa_sync.c b/drivers/marvell/security/marvelltee/src/osa/osa_sync.c
new file mode 100644
index 0000000..03260dd
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/osa/osa_sync.c
@@ -0,0 +1,535 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+/*
+ ******************************
+ *          HEADERS
+ ******************************
+ */
+
+#include <osa.h>
+
+/*
+ ******************************
+ *          MACROS
+ ******************************
+ */
+
+#define INIT_SEM_MAGIC(s)               \
+do {                                    \
+	((struct _sem *)s)->magic[0] = 'S'; \
+	((struct _sem *)s)->magic[1] = 'e'; \
+	((struct _sem *)s)->magic[2] = 'M'; \
+	((struct _sem *)s)->magic[3] = 'a'; \
+} while (0)
+
+#define IS_SEM_VALID(s)                 \
+	('S' == ((struct _sem *)s)->magic[0] && \
+	 'e' == ((struct _sem *)s)->magic[1] && \
+	 'M' == ((struct _sem *)s)->magic[2] && \
+	 'a' == ((struct _sem *)s)->magic[3])
+
+#define CLEAN_SEM_MAGIC(s)            \
+do {                                  \
+	((struct _sem *)s)->magic[0] = 0; \
+	((struct _sem *)s)->magic[1] = 0; \
+	((struct _sem *)s)->magic[2] = 0; \
+	((struct _sem *)s)->magic[3] = 0; \
+} while (0)
+
+/*
+ ******************************
+ *          TYPES
+ ******************************
+ */
+
+struct _sem {
+	uint8_t magic[4];
+	struct semaphore sem;
+};
+
+struct _timeout_arg {
+	struct _sem *sem;
+	struct task_struct *task;
+
+	bool *sem_up;
+	bool *timeout;
+};
+
+struct _mutex {
+	/* no magic since there is one in struct _sem */
+	struct _sem *osa_sem;
+	spinlock_t lock;	/* to protect sem.counter */
+};
+
+/*
+ ******************************
+ *          FUNCTIONS
+ ******************************
+ */
+
+/*
+ * Name:        osa_create_sem
+ *
+ * Description: create a sempahore with timeout feature
+ *
+ * Params:      init_val - the initial value of the semaphore to create
+ *
+ * Returns:     osa_sem_t - the semaphore handle
+ *
+ * Notes:       none
+ */
+osa_sem_t osa_create_sem(int32_t init_val)
+{
+	struct _sem *sem;
+
+	sem = kmalloc(sizeof(struct _sem), GFP_KERNEL);
+	if (!sem) {
+		osa_dbg_print(DBG_ERR,
+			      "ERROR - failed to kmalloc in osa_create_sem\n");
+		return NULL;
+	}
+
+	INIT_SEM_MAGIC(sem);
+
+	sema_init(&(sem->sem), init_val);
+
+	return (osa_sem_t) sem;
+}
+OSA_EXPORT_SYMBOL(osa_create_sem);
+
+/*
+ * Name:        osa_destroy_sem
+ *
+ * Description: destroy the semaphore specified by handle
+ *
+ * Params:      handle - handle of the semaphore to destroy
+ *
+ * Returns:     none
+ *
+ * Notes:       none
+ */
+void osa_destroy_sem(osa_sem_t handle)
+{
+	struct _sem *sem = (struct _sem *)handle;
+
+	OSA_ASSERT(sem && IS_SEM_VALID(sem));
+
+	CLEAN_SEM_MAGIC(sem);
+	kfree(sem);
+}
+OSA_EXPORT_SYMBOL(osa_destroy_sem);
+
+/*
+ * Name:        osa_wait_for_sem
+ *
+ * Description: wait for the semaphore
+ *
+ * Params:      handle - handle of the semaphore to wait for
+ *              msec - the number in the unit of micro-second
+ *                     wait forever if msec < 0
+ *
+ * Returns:     status code
+ *              OSA_OK              - no error
+ *              OSA_SEM_WAIT_FAILED - failed to wait for the semaphore
+ *              OSA_SEM_WAIT_TO     - timeout when waiting for the semaphore
+ *
+ * Notes:       timeout is implemented by timer in kernel
+ */
+osa_err_t osa_wait_for_sem(osa_sem_t handle, int32_t msec)
+{
+	struct _sem *sem = (struct _sem *)handle;
+	int ret;
+
+	OSA_ASSERT(sem && IS_SEM_VALID(sem));
+
+	if (msec == 0) {
+		ret = down_trylock(&(sem->sem));
+		if (ret)
+			return OSA_SEM_WAIT_FAILED;
+		else
+			return OSA_OK;
+	} else if (msec > 0) {
+		ret = down_timeout(&(sem->sem), (msec * HZ + 500) / 1000);
+		if (ret < 0)
+			return OSA_SEM_WAIT_TO;
+	} else
+		down(&(sem->sem));
+
+	return OSA_OK;
+}
+OSA_EXPORT_SYMBOL(osa_wait_for_sem);
+
+/*
+ * Name:        osa_try_to_wait_for_sem
+ *
+ * Description: try to wait the semaphore
+ *
+ * Params:      handle - handle of the semaphore to wait for
+ *
+ * Returns:     status code
+ *              OSA_OK              - no error
+ *              OSA_SEM_WAIT_FAILED - failed to wait for the semaphore
+ *
+ * Notes:       none
+ */
+osa_err_t osa_try_to_wait_for_sem(osa_sem_t handle)
+{
+	struct _sem *sem = (struct _sem *)handle;
+	int ret;
+
+	OSA_ASSERT(sem && IS_SEM_VALID(sem));
+
+	ret = down_trylock(&(sem->sem));
+
+	if (ret)
+		return OSA_SEM_WAIT_FAILED;
+	else
+		return OSA_OK;
+}
+OSA_EXPORT_SYMBOL(osa_try_to_wait_for_sem);
+
+/*
+ * Name:        osa_release_sem
+ *
+ * Description: release the semaphore specified by handle
+ *
+ * Params:      handle - handle of the semaphore to release
+ *
+ * Returns:     none
+ *
+ * Notes:       none
+ */
+void osa_release_sem(osa_sem_t handle)
+{
+	struct _sem *sem = (struct _sem *)handle;
+
+	OSA_ASSERT(sem && IS_SEM_VALID(sem));
+
+	up(&(sem->sem));
+}
+OSA_EXPORT_SYMBOL(osa_release_sem);
+
+/*
+ * Name:        _osa_create_mutex
+ *
+ * Description: create a mutex with timeout feature
+ *
+ * Params:      init_val - initial value (0/1)
+ *
+ * Returns:     osa_mutex_t - the mutex handle
+ *
+ * Notes:       none
+ */
+static osa_mutex_t _osa_create_mutex(uint32_t init_val)
+{
+	struct _mutex *mutex;
+
+	mutex = kmalloc(sizeof(struct _mutex), GFP_KERNEL);
+	if (!mutex) {
+		osa_dbg_print(DBG_ERR,
+			"ERROR - failed to kmalloc in osa_create_mutex\n");
+		return NULL;
+	}
+
+	mutex->osa_sem = (struct _sem *)osa_create_sem(init_val);
+	if (!mutex->osa_sem) {
+		/* error log will be printed in osa_create_sem */
+		return NULL;
+	}
+
+	spin_lock_init(&mutex->lock);
+
+	return (osa_mutex_t) mutex;
+}
+
+/*
+ * Name:        osa_create_mutex
+ *
+ * Description: create a mutex with timeout feature
+ *
+ * Params:      none
+ *
+ * Returns:     osa_mutex_t - the mutex handle
+ *
+ * Notes:       none
+ */
+osa_mutex_t osa_create_mutex(void)
+{
+	return _osa_create_mutex(1);
+}
+OSA_EXPORT_SYMBOL(osa_create_mutex);
+
+/*
+ * Name:        osa_create_mutex_locked
+ *
+ * Description: create a mutex locked
+ *
+ * Params:      none
+ *
+ * Returns:     osa_mutex_t - the mutex handle
+ *
+ * Notes:       none
+ */
+osa_mutex_t osa_create_mutex_locked(void)
+{
+	return _osa_create_mutex(0);
+}
+OSA_EXPORT_SYMBOL(osa_create_mutex_locked);
+
+/*
+ * Name:        osa_destroy_mutex
+ *
+ * Description: destroy the mutex specified by handle
+ *
+ * Params:      handle - handle of the mutex to destroy
+ *
+ * Returns:     none
+ *
+ * Notes:       none
+ */
+void osa_destroy_mutex(osa_mutex_t handle)
+{
+	struct _mutex *mutex = (struct _mutex *)handle;
+
+	osa_destroy_sem(mutex->osa_sem);
+
+	kfree(mutex);
+}
+OSA_EXPORT_SYMBOL(osa_destroy_mutex);
+
+/*
+ * Name:        osa_wait_for_mutex
+ *
+ * Description: wait for the mutex
+ *
+ * Params:      handle - handle of the mutex to wait for
+ *              msec - the number in the unit of micro-second
+ *                     wait forever if msec < 0
+ *
+ * Returns:     status code
+ *              OSA_OK                - no error
+ *              OSA_MUTEX_WAIT_FAILED - failed to wait for the mutex
+ *              OSA_MUTEX_WAIT_TO     - timeout when waiting for the mutex
+ *
+ * Notes:       timeout is implemented by timer in kernel
+ */
+osa_err_t osa_wait_for_mutex(osa_mutex_t handle, int32_t msec)
+{
+	struct _mutex *mutex = (struct _mutex *)handle;
+	osa_err_t ret = osa_wait_for_sem(mutex->osa_sem, msec);
+
+	switch (ret) {
+	case OSA_OK:
+		return OSA_OK;
+	case OSA_SEM_WAIT_FAILED:
+		return OSA_MUTEX_WAIT_FAILED;
+	case OSA_SEM_WAIT_TO:
+		return OSA_MUTEX_WAIT_TO;
+	default:
+		OSA_ASSERT(0);
+		/* return OSA_ERR to avoid warnings */
+		return OSA_ERR;
+	}
+}
+OSA_EXPORT_SYMBOL(osa_wait_for_mutex);
+
+/*
+ * Name:        osa_try_to_wait_for_mutex
+ *
+ * Description: try to wait the mutex
+ *
+ * Params:      handle - handle of the mutex to wait for
+ *
+ * Returns:     status code
+ *              OSA_OK                - no error
+ *              OSA_MUTEX_WAIT_FAILED - failed to wait for the mutex
+ *
+ * Notes:       none
+ */
+osa_err_t osa_try_to_wait_for_mutex(osa_mutex_t handle)
+{
+	struct _mutex *mutex = (struct _mutex *)handle;
+	osa_err_t ret = osa_try_to_wait_for_sem(mutex->osa_sem);
+
+	switch (ret) {
+	case OSA_OK:
+		return OSA_OK;
+	case OSA_SEM_WAIT_FAILED:
+		return OSA_MUTEX_WAIT_FAILED;
+	default:
+		OSA_ASSERT(0);
+		/* return OSA_ERR to avoid warnings */
+		return OSA_ERR;
+	}
+}
+OSA_EXPORT_SYMBOL(osa_try_to_wait_for_mutex);
+
+/*
+ * Name:        osa_release_mutex
+ *
+ * Description: release the mutex specified by handle
+ *
+ * Params:      handle - handle of the mutex to release
+ *
+ * Returns:     none
+ *
+ * Notes:       none
+ */
+void osa_release_mutex(osa_mutex_t handle)
+{
+	struct _mutex *mutex = (struct _mutex *)handle;
+
+	/* here we need to check sem's magic first */
+	OSA_ASSERT(mutex->osa_sem && IS_SEM_VALID(mutex->osa_sem));
+
+	osa_release_sem(mutex->osa_sem);
+}
+OSA_EXPORT_SYMBOL(osa_release_mutex);
+
+/*
+ * Name:        osa_create_event
+ *
+ * Description: create an event with timeout feature
+ *
+ * Params:      is_set      - the event created is set or not.
+ *
+ * Returns:     osa_event_t - the event handle
+ *
+ * Notes:       none
+ */
+osa_event_t osa_create_event(bool is_set)
+{
+	osa_mutex_t ret;
+
+	if (is_set)
+		ret = osa_create_mutex();
+	else
+		ret = osa_create_mutex_locked();
+
+	if (!ret)
+		return (osa_event_t) NULL;
+
+	return (osa_event_t) ret;
+}
+OSA_EXPORT_SYMBOL(osa_create_event);
+
+/*
+ * Name:        osa_destroy_event
+ *
+ * Description: destroy the event specified by handle
+ *
+ * Params:      handle - handle of the event to destroy
+ *
+ * Returns:     none
+ *
+ * Notes:       none
+ */
+void osa_destroy_event(osa_event_t handle)
+{
+	osa_mutex_t mutex = (osa_mutex_t) handle;
+
+	return osa_destroy_mutex(mutex);
+}
+OSA_EXPORT_SYMBOL(osa_destroy_event);
+
+/*
+ * Name:        osa_wait_for_event
+ *
+ * Description: wait for the event
+ *
+ * Params:      handle - handle of the event to wait for
+ *              msec - the number in the unit of micro-second
+ *                     wait forever if msec < 0
+ *
+ * Returns:     status code
+ *              OSA_OK                - no error
+ *              OSA_EVENT_WAIT_TO     - timeout when waiting for the event
+ *
+ * Notes:       timeout is implemented by timer in kernel
+ */
+osa_err_t osa_wait_for_event(osa_event_t handle, int32_t msec)
+{
+	osa_err_t ret;
+
+	osa_mutex_t mutex = (osa_mutex_t) handle;
+
+	ret = osa_wait_for_mutex(mutex, msec);
+
+	if (ret == OSA_MUTEX_WAIT_TO)
+		ret = OSA_EVENT_WAIT_TO;
+
+	return ret;
+}
+OSA_EXPORT_SYMBOL(osa_wait_for_event);
+
+/*
+ * Name:        osa_try_to_wait_for_event
+ *
+ * Description: try to wait the event
+ *
+ * Params:      handle - handle of the event to wait for
+ *
+ * Returns:     status code
+ *              OSA_OK                - no error
+ *              OSA_EVENT_WAIT_FAILED - failed to wait for the event
+ *
+ * Notes:       none
+ */
+osa_err_t osa_try_to_wait_for_event(osa_event_t handle)
+{
+	return osa_wait_for_event(handle, 0);
+}
+OSA_EXPORT_SYMBOL(osa_try_to_wait_for_event);
+
+/*
+ * Name:        osa_set_event
+ *
+ * Description: set the event specified by handle
+ *
+ * Params:      handle - handle of the event to release
+ *
+ * Returns:     none
+ *
+ * Notes:       none
+ */
+void osa_set_event(osa_event_t handle)
+{
+	osa_mutex_t mutex = handle;
+
+	osa_release_mutex(mutex);
+}
+OSA_EXPORT_SYMBOL(osa_set_event);
+
+/*
+ * Name:        osa_reset_event
+ *
+ * Description: reset the event specified by handle
+ *
+ * Params:      handle - handle of the event to release
+ *
+ * Returns:     none
+ *
+ * Notes:       none
+ */
+void osa_reset_event(osa_event_t handle)
+{
+	osa_mutex_t mutex = handle;
+
+	(void)osa_try_to_wait_for_mutex(mutex);
+}
+OSA_EXPORT_SYMBOL(osa_reset_event);
diff --git a/drivers/marvell/security/marvelltee/src/osa/osa_thread.c b/drivers/marvell/security/marvelltee/src/osa/osa_thread.c
new file mode 100644
index 0000000..30a3fc5
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/osa/osa_thread.c
@@ -0,0 +1,464 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ * Filename     : osa_thread.c
+ * Author       : Dafu Lv
+ * Date Created : 21/03/08
+ * Description  : This is the source code of thread-related functions in osa.
+ *
+ */
+
+/*
+ ******************************
+ *          HEADERS
+ ******************************
+ */
+
+#include <osa.h>
+
+/*
+ ******************************
+ *          MACROS
+ ******************************
+ */
+
+#define INIT_THREAD_MAGIC(t)               \
+do {                                       \
+	((struct _thread *)t)->magic[0] = 'T'; \
+	((struct _thread *)t)->magic[1] = 'h'; \
+	((struct _thread *)t)->magic[2] = 'R'; \
+	((struct _thread *)t)->magic[3] = 'd'; \
+} while (0)
+
+#define IS_THREAD_VALID(t)                 \
+	('T' == ((struct _thread *)t)->magic[0] && \
+	 'h' == ((struct _thread *)t)->magic[1] && \
+	 'R' == ((struct _thread *)t)->magic[2] && \
+	 'd' == ((struct _thread *)t)->magic[3])
+
+#define CLEAN_THREAD_MAGIC(t)            \
+do {                                     \
+	((struct _thread *)t)->magic[0] = 0; \
+	((struct _thread *)t)->magic[1] = 0; \
+	((struct _thread *)t)->magic[2] = 0; \
+	((struct _thread *)t)->magic[3] = 0; \
+} while (0)
+
+/*
+ ******************************
+ *          TYPES
+ ******************************
+ */
+
+enum _thread_status {
+	_THREAD_UNKNOWN,
+	_THREAD_READY,
+	_THREAD_RUNNING,
+	_THREAD_STOPPED
+};
+
+struct _thread {
+	uint8_t magic[4];
+
+	void (*func)(void *);
+	void *arg;
+	long_t nice;
+
+	struct task_struct *task;
+	enum _thread_status status;
+	spinlock_t lock;
+};
+
+/*
+ ******************************
+ *          FUNCTIONS
+ ******************************
+ */
+
+/*
+ * local functions
+ */
+static void _stop_thread(struct _thread *_thrd);
+static void _stop_thread_lock(struct _thread *_thrd);
+
+/*
+ * Name:        _thread_func
+ *
+ * Description: the shell function of thread
+ *
+ * Params:      param - the member "arg" in struct _thread
+ *
+ * Returns:     int - 0 always
+ *
+ * Notes:       none
+ */
+static int _thread_func(void *param)
+{
+	struct _thread *_thrd = (struct _thread *)param;
+
+	OSA_ASSERT(_thrd);
+	OSA_ASSERT(IS_THREAD_VALID(_thrd));
+
+	/* 0~7 --> -20~19 */
+	set_user_nice(current, (_thrd->nice - 3) << 2);
+
+	spin_lock(&(_thrd->lock));
+	if (_thrd->status != _THREAD_STOPPED) {
+		_thrd->status = _THREAD_READY;
+		spin_unlock(&(_thrd->lock));
+	} else {
+		spin_unlock(&(_thrd->lock));
+		return 0;
+	}
+
+	/* further initialization here */
+
+	spin_lock(&(_thrd->lock));
+	if (_thrd->status != _THREAD_STOPPED) {
+		_thrd->status = _THREAD_RUNNING;
+		spin_unlock(&(_thrd->lock));
+	} else {
+		spin_unlock(&(_thrd->lock));
+		return 0;
+	}
+
+	if (_thrd->status != _THREAD_STOPPED) {
+		_thrd->func(_thrd->arg);
+
+		spin_lock(&(_thrd->lock));
+		_thrd->status = _THREAD_STOPPED;
+		spin_unlock(&(_thrd->lock));
+	}
+
+	/*
+	 * kthread_stop is a sync way to stop thread.
+	 * so here we need not send any event to show my stopping status.
+	 */
+
+	return 0;
+}
+
+/*
+ * Name:        osa_create_thread
+ *
+ * Description: create a kernel thread
+ *
+ * Params:      func - the function will be called in the kernel thread created
+ *              arg  - the argument of the function when called
+ *              attr - os-specific attributes of the kernel thread
+ *              attr->name - the name of the kernel thread, default "osa_thread"
+ *              attr->prio - the static priority of the thread, will be changed
+ *                           dynamically.
+ *                           range: 0~7 (mapping from -20~19 in linux kernel)
+ *                           the default is the lowest priority (7)
+ *              attr->stack_addr - no use in linux kernel
+ *              attr->stack_size - no use in linux kernel
+ *
+ * Returns:     osa_thread_t - handle of the kernel thread to create
+ *
+ * Notes:       none
+ */
+osa_thread_t osa_create_thread(void (*func) (void *), void *arg,
+			       struct osa_thread_attr *attr)
+{
+	struct _thread *ret = NULL;
+
+	OSA_ASSERT(func);
+	OSA_ASSERT(attr && (attr->prio >= 0) && (attr->prio <= 7));
+
+	ret = kmalloc(sizeof(struct _thread), GFP_KERNEL);
+	if (!ret) {
+		osa_dbg_print(DBG_ERR,
+			      "ERROR - failed to kmalloc in osa_create_thread\n");
+		return ret;
+	}
+
+	INIT_THREAD_MAGIC(ret);
+
+	ret->func = func;
+	ret->arg = arg;
+	ret->nice = (long_t) attr->prio;
+
+	spin_lock_init(&(ret->lock));
+
+	ret->status = _THREAD_UNKNOWN;
+
+	if (attr->name == NULL)
+		ret->task =
+		    kthread_run(_thread_func, (void *)ret, "osa_kthread");
+	else
+		ret->task = kthread_run(_thread_func, (void *)ret, attr->name);
+
+	if (!(ret->task)) {
+		osa_dbg_print(DBG_ERR,
+			      "ERROR - failed to create a thread in osa_create_thread\n");
+		CLEAN_THREAD_MAGIC(ret);
+		kfree(ret);
+		ret = NULL;
+		return ret;
+	}
+
+	if (attr->flags & OSA_PF_FREEZER_SKIP)
+		ret->task->flags |= attr->flags;
+
+	while (ret->status == _THREAD_UNKNOWN)
+		cond_resched();
+
+	return (osa_thread_t) ret;
+}
+OSA_EXPORT_SYMBOL(osa_create_thread);
+
+/*
+ * Name:        osa_destroy_thread
+ *
+ * Description: destroy the thread handle
+ *
+ * Params:      handle - handle of the thread to destroy
+ *
+ * Returns:     none
+ *
+ * Notes:       if the thread is not stopped,
+			 the function will call _stop_thread_lock
+ */
+void osa_destroy_thread(osa_thread_t handle)
+{
+	struct _thread *_thrd = (struct _thread *)handle;
+
+	OSA_ASSERT(_thrd && IS_THREAD_VALID(_thrd));
+
+	if (_thrd->status != _THREAD_STOPPED)
+		_stop_thread_lock(_thrd);
+
+	CLEAN_THREAD_MAGIC(_thrd);
+
+	kfree(_thrd);
+}
+OSA_EXPORT_SYMBOL(osa_destroy_thread);
+
+/*
+ * Name:        _stop_thread
+ *
+ * Description: stop the thread synchronously
+ *
+ * Params:      _thrd - the thread structure
+ *
+ * Returns:     none
+ *
+ * Notes:       caller must NOT hold the spinlock in thread struct
+ */
+static void _stop_thread(struct _thread *_thrd)
+{
+	/* kthread_stop is a sync way to stop thread */
+	kthread_stop(_thrd->task);
+	/* so here we need not wait for any stopped event */
+}
+
+/*
+ * Name:        osa_stop_thread
+ *
+ * Description: stop the thread synchronously
+ *
+ * Params:      handle - handle of the kernel thread to stop
+ *
+ * Returns:     status code
+ *              OSA_OK                    - no error
+ *              OSA_THREAD_BAD_STATUS - invalid status of the thread
+ *
+ * Notes:       none
+ */
+osa_err_t osa_stop_thread(osa_thread_t handle)
+{
+	osa_err_t ret;
+	struct _thread *_thrd = (struct _thread *)handle;
+
+	OSA_ASSERT(_thrd && IS_THREAD_VALID(_thrd));
+
+	spin_lock(&(_thrd->lock));
+	if (_thrd->status == _THREAD_UNKNOWN) {
+		_thrd->status = _THREAD_STOPPED;
+		spin_unlock(&(_thrd->lock));
+		ret = OSA_OK;
+	} else if ((_thrd->status != _THREAD_READY)
+		   && (_thrd->status != _THREAD_RUNNING)) {
+		spin_unlock(&(_thrd->lock));
+		osa_dbg_print(DBG_ERR,
+			      "ERROR - the status of thread is invalid when stopping\n");
+		ret = OSA_THREAD_BAD_STATUS;
+	} else {
+		spin_unlock(&(_thrd->lock));
+		_stop_thread(_thrd);
+		ret = OSA_OK;
+	}
+
+	return ret;
+}
+OSA_EXPORT_SYMBOL(osa_stop_thread);
+
+/*
+ * Name:        _stop_thread_lock
+ *
+ * Description: stop the thread synchronously with holding lock
+ *
+ * Params:      _thrd - the thread structure
+ *
+ * Returns:     none
+ *
+ * Notes:       none
+ */
+static void _stop_thread_lock(struct _thread *_thrd)
+{
+	spin_lock(&(_thrd->lock));
+	if (_thrd->status == _THREAD_UNKNOWN) {
+		_thrd->status = _THREAD_STOPPED;
+		spin_unlock(&(_thrd->lock));
+	} else {
+		spin_unlock(&(_thrd->lock));
+		_stop_thread(_thrd);
+	}
+}
+
+/*
+ * Name:        osa_stop_thread_async
+ *
+ * Description: stop the thread asynchronously
+ *
+ * Params:      handle - handle of the kernel thread to stop
+ *
+ * Returns:     status code
+ *              OSA_OK                 - no error
+ *              OSA_THREAD_BAD_STATUS  - invalid status of the thread
+ *              OSA_THREAD_STOP_FAILED - failed to invoke the stopping thread
+ *
+ * Notes:       no support in linux kernel
+ */
+osa_err_t osa_stop_thread_async(osa_thread_t handle)
+{
+	struct _thread *_thrd = (struct _thread *)handle;
+
+	OSA_ASSERT(_thrd && IS_THREAD_VALID(_thrd));
+
+	if ((_thrd->status != _THREAD_UNKNOWN)
+	    && (_thrd->status != _THREAD_READY)
+	    && (_thrd->status != _THREAD_RUNNING)) {
+		return OSA_THREAD_BAD_STATUS;
+	}
+
+	if (kthread_run
+	    ((int (*)(void *))_stop_thread_lock, _thrd,
+	     "osa_thread_stop_func"))
+		return OSA_OK;
+	else
+		return OSA_THREAD_STOP_FAILED;
+}
+OSA_EXPORT_SYMBOL(osa_stop_thread_async);
+
+/*
+ * Name:        osa_thread_should_stop
+ *
+ * Description: the function returns the flag to define
+			 whether the thread should be stopped
+ *
+ * Params:      none
+ *
+ * Returns:     bool
+ *              true  - the thread should be stopped as soon as possible
+ *              false - vice versa
+ *
+ * Notes:       the function should be called in the main loop
+ *              of the core function in kernel thread
+ */
+bool osa_thread_should_stop(void)
+{
+	return kthread_should_stop();
+}
+OSA_EXPORT_SYMBOL(osa_thread_should_stop);
+
+/*
+ * Name:        osa_get_thread_id
+ *
+ * Description: get the id of the kernel thread
+ *
+ * Params:      handle - handle of the kernel thread
+ *
+ * Returns:     osa_thread_id_t - the id number of the kernel thread
+ *
+ * Notes:       none
+ */
+osa_thread_id_t osa_get_thread_id(osa_thread_t handle)
+{
+	struct _thread *_thrd = (struct _thread *)handle;
+
+	OSA_ASSERT(_thrd && IS_THREAD_VALID(_thrd));
+
+	return (osa_thread_id_t)((ulong_t)(_thrd->task->pid));
+}
+OSA_EXPORT_SYMBOL(osa_get_thread_id);
+
+/*
+ * Name:        osa_get_thread_group_id
+ *
+ * Description: get the thread group id of the kernel thread
+ *
+ * Params:      handle - handle of the kernel thread
+ *
+ * Returns:     osa_thread_id_t -
+			 the thread group id number of the kernel thread
+ *
+ * Notes:       none
+ */
+osa_thread_id_t osa_get_thread_group_id(osa_thread_t handle)
+{
+	struct _thread *_thrd = (struct _thread *)handle;
+
+	OSA_ASSERT(_thrd && IS_THREAD_VALID(_thrd));
+
+	return (osa_thread_id_t)((ulong_t)(_thrd->task->tgid));
+}
+OSA_EXPORT_SYMBOL(osa_get_thread_group_id);
+
+/*
+ * Name:        osa_get_current_thread_id
+ *
+ * Description: get the current thread id
+ *
+ * Params:      none
+ *
+ * Returns:     osa_thread_id_t - the thread id
+ *
+ * Notes:       none
+ */
+osa_thread_id_t osa_get_current_thread_id(void)
+{
+	return (osa_thread_id_t)((ulong_t)(current->pid));
+}
+OSA_EXPORT_SYMBOL(osa_get_current_thread_id);
+
+/*
+ * Name:        osa_get_current_thread_group_id
+ *
+ * Description: get the current thread group id
+ *
+ * Params:      none
+ *
+ * Returns:     osa_thread_id_t - the thread group id
+ *
+ * Notes:       none
+ */
+osa_thread_id_t osa_get_current_thread_group_id(void)
+{
+	return (osa_thread_id_t)((ulong_t)(current->tgid));
+}
+OSA_EXPORT_SYMBOL(osa_get_current_thread_group_id);
diff --git a/drivers/marvell/security/marvelltee/src/perf/ntw/tee_perf_priv.h b/drivers/marvell/security/marvelltee/src/perf/ntw/tee_perf_priv.h
new file mode 100644
index 0000000..682e3c7
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/perf/ntw/tee_perf_priv.h
@@ -0,0 +1,21 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+#ifndef _TEE_PERF_PRIV_H_
+#define _TEE_PERF_PRIV_H_
+#include "linux/types.h"
+#endif
diff --git a/drivers/marvell/security/marvelltee/src/perf/parser/perf_parser.c b/drivers/marvell/security/marvelltee/src/perf/parser/perf_parser.c
new file mode 100644
index 0000000..264298f
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/perf/parser/perf_parser.c
@@ -0,0 +1,96 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include "tee_perf.h"
+
+/*
+   * arg1: src name
+   * arg2: dst name
+   * arg3: first record name
+   */
+int main(int argc, char *argv[])
+{
+	FILE *src_fd = NULL;
+	FILE *dst_fd = NULL;
+	unsigned int len;
+	unsigned int last_val = 0;
+	unsigned int total_val = 0;
+	tee_perf_desc head;
+	tee_perf_record current;
+	unsigned int found_header = 0;
+	unsigned int i = 0;
+
+	if (argc != 4) {
+		printf("please use below command line:\n");
+		printf("    ./perf_parser <src> <dst> <first_record_name>\n");
+		return -1;
+	}
+
+	src_fd = fopen(argv[1], "rb")
+	if (!src_fd) {
+		printf("open file src failed\n");
+		return -1;
+	}
+
+	dst_fd = fopen(argv[2], "wb")
+	if (!dst_fd) {
+		printf("open file dst failed\n");
+		fclose(src_fd);
+		return -1;
+	}
+	fread(&head, sizeof(tee_perf_desc), 1, src_fd);
+	for (i = 0; i < head.total; i++) {
+		if (found_header == 0) {
+			len =
+			    fread(&current, sizeof(tee_perf_record), 1, src_fd);
+			if (len < 1)
+				break;
+			if (!memcmp(current.name, argv[3], 4)) {
+				fprintf(dst_fd, "| %s-", argv[3]);
+				total_val = 0;
+				last_val = current.value;
+				found_header = 1;
+			} else {
+				continue;
+			}
+		}
+
+		len = fread(&current, sizeof(tee_perf_record), 1, src_fd);
+		if (len < 1)
+			break;
+		if (memcmp(current.name, argv[3], 4)) {
+			fprintf(dst_fd, "-%d-->%c%c%c%c-",
+				current.value - last_val, current.name[0],
+				current.name[1], current.name[2],
+				current.name[3]);
+			total_val += current.value - last_val;
+			last_val = current.value;
+		} else {
+			fprintf(dst_fd, "->| total %d\n| %s-", total_val,
+				argv[3]);
+			last_val = current.value;
+			total_val = 0;
+		}
+	}
+
+	fclose(dst_fd);
+	fclose(src_fd);
+
+	return 0;
+}
diff --git a/drivers/marvell/security/marvelltee/src/perf/tee_perf.c b/drivers/marvell/security/marvelltee/src/perf/tee_perf.c
new file mode 100644
index 0000000..4e3d49c
--- /dev/null
+++ b/drivers/marvell/security/marvelltee/src/perf/tee_perf.c
@@ -0,0 +1,178 @@
+/*
+ * Copyright (c) [2009-2013] Marvell International Ltd. and its affiliates.
+ * All rights reserved.
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * licensing terms.
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of
+ * the General Public License Version 2, June 1991 (the "GPL License"), a
+ * copy of which is available along with the File in the license.txt file
+ * or by writing to the Free Software Foundation, Inc. or on the worldwide web at
+ * http://www.gnu.org/licenses/gpl.txt. THE FILE IS DISTRIBUTED AS-IS,
+ * WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+ * DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ */
+#include "tee_perf_priv.h"
+#include "tee_perf.h"
+
+#define PMNC_MASK     0x3f	/* Mask for writable bits */
+#define PMNC_E        (1 << 0)	/* Enable all counters */
+#define PMNC_P        (1 << 1)	/* Reset all counters */
+#define PMNC_C        (1 << 2)	/* Cycle counter reset */
+#define PMNC_D        (1 << 3)	/* CCNT counts every 64th cpu cycle */
+#define PMNC_X        (1 << 4)	/* Export to ETM */
+#define PMNC_DP       (1 << 5)	/* Disable CCNT if non-invasive debug */
+
+#define FLAG_C        (1 << 31)
+#define FLAG_MASK     0x8000000f	/* Mask for writable bits */
+
+#define CNTENC_C      (1 << 31)
+#define CNTENC_MASK   0x8000000f	/* Mask for writable bits */
+
+#define CNTENS_C      (1 << 31)
+#define CNTENS_MASK   0x8000000f	/* Mask for writable bits */
+
+static inline uint32_t _tee_perf_pmnc_read(void)
+{
+	uint32_t val;
+
+	asm volatile ("mrc p15, 0, %0, c9, c12, 0"
+					: "=r" (val));
+	return val;
+}
+
+static inline void _tee_perf_pmnc_write(uint32_t val)
+{
+	val &= PMNC_MASK;
+	asm volatile ("mcr p15, 0, %0, c9, c12, 0"
+					:
+					: "r" (val));
+}
+
+static inline void _tee_perf_pmnc_disable_counter(void)
+{
+	uint32_t val;
+
+	val = CNTENC_C;
+
+	val &= CNTENC_MASK;
+	asm volatile ("mcr p15, 0, %0, c9, c12, 2"
+					:
+					: "r" (val));
+}
+
+static void _tee_perf_pmnc_reset_counter(void)
+{
+	uint32_t val = 0;
+
+	asm volatile ("mcr p15, 0, %0, c9, c13, 0"
+					:
+					: "r" (val));
+}
+
+static inline void _tee_perf_pmnc_enable_counter(void)
+{
+	uint32_t val;
+
+	val = CNTENS_C;
+	val &= CNTENS_MASK;
+	asm volatile ("mcr p15, 0, %0, c9, c12, 1"
+					:
+					: "r" (val));
+}
+
+static inline void _tee_perf_start_pmnc(void)
+{
+	_tee_perf_pmnc_write(_tee_perf_pmnc_read() | PMNC_E);
+}
+
+static inline void _tee_perf_stop_pmnc(void)
+{
+	_tee_perf_pmnc_write(_tee_perf_pmnc_read() & ~PMNC_E);
+}
+
+static inline uint32_t _tee_perf_pmnc_getreset_flags(void)
+{
+	uint32_t val;
+
+	/* Read */
+	asm volatile ("mrc p15, 0, %0, c9, c12, 3"
+					: "=r" (val));
+
+	/* Write to clear flags */
+	val &= FLAG_MASK;
+	asm volatile ("mcr p15, 0, %0, c9, c12, 3"
+					:
+					: "r" (val));
+
+	return val;
+}
+
+static uint32_t tee_perf_counter_read(void)
+{
+	uint32_t val;
+
+	asm volatile ("mrc p15, 0, %0, c9, c13, 0"
+					: "=r" (val));
+	return val;
+}
+
+static uint32_t tee_perf_start_counter(void)
+{
+	uint32_t val;
+
+	_tee_perf_pmnc_write(PMNC_P | PMNC_C);
+	_tee_perf_pmnc_disable_counter();
+	_tee_perf_pmnc_reset_counter();
+	_tee_perf_pmnc_enable_counter();
+	val = tee_perf_counter_read();
+	_tee_perf_start_pmnc();
+	return val;
+}
+
+static uint32_t tee_perf_stop_counter(void)
+{
+	uint32_t val;
+
+	_tee_perf_stop_pmnc();
+	val = tee_perf_counter_read();
+	return val;
+}
+
+static tee_perf_desc *g_tee_perf_header;
+static tee_perf_record *g_tee_perf_base;
+
+void tee_perf_init(uint32_t *buffer)
+{
+	g_tee_perf_header = (tee_perf_desc *)buffer;
+	g_tee_perf_base =
+	    (tee_perf_record *) (buffer +
+				 sizeof(tee_perf_desc) / sizeof(uint32_t));
+	g_tee_perf_header->offset = 0;
+}
+
+void tee_prepare_record_time(void)
+{
+	g_tee_perf_header->offset = 0;
+	tee_perf_start_counter();
+}
+
+void tee_add_time_record_point(char name[4])
+{
+	tee_perf_record *current_record =
+	    g_tee_perf_base + g_tee_perf_header->offset;
+	uint32_t *record_name = (uint32_t *) (current_record->name);
+	*record_name = *(uint32_t *) name;
+	current_record->value = tee_perf_counter_read();
+	g_tee_perf_header->offset++;
+}
+
+void tee_finish_record_time(void)
+{
+	tee_perf_stop_counter();
+	g_tee_perf_header->total = g_tee_perf_header->offset;
+	g_tee_perf_header->offset = 0;
+}
-- 
2.7.4

